
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BetterAuthUser
 * 
 */
export type BetterAuthUser = $Result.DefaultSelection<Prisma.$BetterAuthUserPayload>
/**
 * Model BetterAuthSession
 * 
 */
export type BetterAuthSession = $Result.DefaultSelection<Prisma.$BetterAuthSessionPayload>
/**
 * Model BetterAuthAccount
 * 
 */
export type BetterAuthAccount = $Result.DefaultSelection<Prisma.$BetterAuthAccountPayload>
/**
 * Model BetterAuthVerification
 * 
 */
export type BetterAuthVerification = $Result.DefaultSelection<Prisma.$BetterAuthVerificationPayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Ikohza
 * 
 */
export type Ikohza = $Result.DefaultSelection<Prisma.$IkohzaPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyBranch
 * 
 */
export type CompanyBranch = $Result.DefaultSelection<Prisma.$CompanyBranchPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AuthProvider
 * 
 */
export type AuthProvider = $Result.DefaultSelection<Prisma.$AuthProviderPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServicePricing
 * 
 */
export type ServicePricing = $Result.DefaultSelection<Prisma.$ServicePricingPayload>
/**
 * Model BookingRequest
 * 
 */
export type BookingRequest = $Result.DefaultSelection<Prisma.$BookingRequestPayload>
/**
 * Model BookingServiceItem
 * 
 */
export type BookingServiceItem = $Result.DefaultSelection<Prisma.$BookingServiceItemPayload>
/**
 * Model SampleModification
 * 
 */
export type SampleModification = $Result.DefaultSelection<Prisma.$SampleModificationPayload>
/**
 * Model ServiceForm
 * 
 */
export type ServiceForm = $Result.DefaultSelection<Prisma.$ServiceFormPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model SampleTracking
 * 
 */
export type SampleTracking = $Result.DefaultSelection<Prisma.$SampleTrackingPayload>
/**
 * Model WorkspaceBooking
 * 
 */
export type WorkspaceBooking = $Result.DefaultSelection<Prisma.$WorkspaceBookingPayload>
/**
 * Model LabEquipment
 * 
 */
export type LabEquipment = $Result.DefaultSelection<Prisma.$LabEquipmentPayload>
/**
 * Model WorkspaceEquipmentUsage
 * 
 */
export type WorkspaceEquipmentUsage = $Result.DefaultSelection<Prisma.$WorkspaceEquipmentUsagePayload>
/**
 * Model SampleEquipmentUsage
 * 
 */
export type SampleEquipmentUsage = $Result.DefaultSelection<Prisma.$SampleEquipmentUsagePayload>
/**
 * Model AnalysisResult
 * 
 */
export type AnalysisResult = $Result.DefaultSelection<Prisma.$AnalysisResultPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model GlobalAddOnCatalog
 * 
 */
export type GlobalAddOnCatalog = $Result.DefaultSelection<Prisma.$GlobalAddOnCatalogPayload>
/**
 * Model ServiceAddOnMapping
 * 
 */
export type ServiceAddOnMapping = $Result.DefaultSelection<Prisma.$ServiceAddOnMappingPayload>
/**
 * Model ServiceAddOn
 * 
 */
export type ServiceAddOn = $Result.DefaultSelection<Prisma.$ServiceAddOnPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const user_type_enum: {
  mjiit_member: 'mjiit_member',
  utm_member: 'utm_member',
  external_member: 'external_member',
  lab_administrator: 'lab_administrator'
};

export type user_type_enum = (typeof user_type_enum)[keyof typeof user_type_enum]


export const user_status_enum: {
  pending: 'pending',
  active: 'active',
  inactive: 'inactive',
  rejected: 'rejected',
  suspended: 'suspended'
};

export type user_status_enum = (typeof user_status_enum)[keyof typeof user_status_enum]


export const academic_type_enum: {
  student: 'student',
  staff: 'staff',
  none: 'none'
};

export type academic_type_enum = (typeof academic_type_enum)[keyof typeof academic_type_enum]


export const UTM: {
  johor_bahru: 'johor_bahru',
  kuala_lumpur: 'kuala_lumpur',
  none: 'none'
};

export type UTM = (typeof UTM)[keyof typeof UTM]


export const service_category_enum: {
  ftir_atr: 'ftir_atr',
  ftir_kbr: 'ftir_kbr',
  uv_vis_absorbance: 'uv_vis_absorbance',
  uv_vis_reflectance: 'uv_vis_reflectance',
  bet_analysis: 'bet_analysis',
  hplc_pda: 'hplc_pda',
  working_space: 'working_space'
};

export type service_category_enum = (typeof service_category_enum)[keyof typeof service_category_enum]


export const booking_status_enum: {
  draft: 'draft',
  pending_user_verification: 'pending_user_verification',
  pending_approval: 'pending_approval',
  approved: 'approved',
  rejected: 'rejected',
  in_progress: 'in_progress',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type booking_status_enum = (typeof booking_status_enum)[keyof typeof booking_status_enum]


export const modification_status_enum: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type modification_status_enum = (typeof modification_status_enum)[keyof typeof modification_status_enum]


export const form_status_enum: {
  generated: 'generated',
  downloaded: 'downloaded',
  signed_forms_uploaded: 'signed_forms_uploaded',
  expired: 'expired'
};

export type form_status_enum = (typeof form_status_enum)[keyof typeof form_status_enum]


export const invoice_status_enum: {
  pending: 'pending',
  sent: 'sent',
  paid: 'paid',
  overdue: 'overdue',
  cancelled: 'cancelled'
};

export type invoice_status_enum = (typeof invoice_status_enum)[keyof typeof invoice_status_enum]


export const payment_method_enum: {
  eft: 'eft',
  vote_transfer: 'vote_transfer',
  local_order: 'local_order'
};

export type payment_method_enum = (typeof payment_method_enum)[keyof typeof payment_method_enum]


export const payment_status_enum: {
  pending: 'pending',
  verified: 'verified',
  rejected: 'rejected'
};

export type payment_status_enum = (typeof payment_status_enum)[keyof typeof payment_status_enum]


export const sample_status_enum: {
  pending: 'pending',
  received: 'received',
  in_analysis: 'in_analysis',
  analysis_complete: 'analysis_complete',
  return_requested: 'return_requested',
  returned: 'returned'
};

export type sample_status_enum = (typeof sample_status_enum)[keyof typeof sample_status_enum]


export const notification_type_enum: {
  booking_submitted: 'booking_submitted',
  booking_pending_verification: 'booking_pending_verification',
  booking_approved: 'booking_approved',
  booking_rejected: 'booking_rejected',
  service_modification_requested: 'service_modification_requested',
  service_form_ready: 'service_form_ready',
  forms_signed_uploaded: 'forms_signed_uploaded',
  invoice_uploaded: 'invoice_uploaded',
  payment_reminder: 'payment_reminder',
  payment_verified: 'payment_verified',
  results_available: 'results_available',
  sample_return_requested: 'sample_return_requested',
  sample_returned: 'sample_returned',
  process_complete: 'process_complete'
};

export type notification_type_enum = (typeof notification_type_enum)[keyof typeof notification_type_enum]

}

export type user_type_enum = $Enums.user_type_enum

export const user_type_enum: typeof $Enums.user_type_enum

export type user_status_enum = $Enums.user_status_enum

export const user_status_enum: typeof $Enums.user_status_enum

export type academic_type_enum = $Enums.academic_type_enum

export const academic_type_enum: typeof $Enums.academic_type_enum

export type UTM = $Enums.UTM

export const UTM: typeof $Enums.UTM

export type service_category_enum = $Enums.service_category_enum

export const service_category_enum: typeof $Enums.service_category_enum

export type booking_status_enum = $Enums.booking_status_enum

export const booking_status_enum: typeof $Enums.booking_status_enum

export type modification_status_enum = $Enums.modification_status_enum

export const modification_status_enum: typeof $Enums.modification_status_enum

export type form_status_enum = $Enums.form_status_enum

export const form_status_enum: typeof $Enums.form_status_enum

export type invoice_status_enum = $Enums.invoice_status_enum

export const invoice_status_enum: typeof $Enums.invoice_status_enum

export type payment_method_enum = $Enums.payment_method_enum

export const payment_method_enum: typeof $Enums.payment_method_enum

export type payment_status_enum = $Enums.payment_status_enum

export const payment_status_enum: typeof $Enums.payment_status_enum

export type sample_status_enum = $Enums.sample_status_enum

export const sample_status_enum: typeof $Enums.sample_status_enum

export type notification_type_enum = $Enums.notification_type_enum

export const notification_type_enum: typeof $Enums.notification_type_enum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BetterAuthUsers
 * const betterAuthUsers = await prisma.betterAuthUser.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BetterAuthUsers
   * const betterAuthUsers = await prisma.betterAuthUser.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.betterAuthUser`: Exposes CRUD operations for the **BetterAuthUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetterAuthUsers
    * const betterAuthUsers = await prisma.betterAuthUser.findMany()
    * ```
    */
  get betterAuthUser(): Prisma.BetterAuthUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.betterAuthSession`: Exposes CRUD operations for the **BetterAuthSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetterAuthSessions
    * const betterAuthSessions = await prisma.betterAuthSession.findMany()
    * ```
    */
  get betterAuthSession(): Prisma.BetterAuthSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.betterAuthAccount`: Exposes CRUD operations for the **BetterAuthAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetterAuthAccounts
    * const betterAuthAccounts = await prisma.betterAuthAccount.findMany()
    * ```
    */
  get betterAuthAccount(): Prisma.BetterAuthAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.betterAuthVerification`: Exposes CRUD operations for the **BetterAuthVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetterAuthVerifications
    * const betterAuthVerifications = await prisma.betterAuthVerification.findMany()
    * ```
    */
  get betterAuthVerification(): Prisma.BetterAuthVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ikohza`: Exposes CRUD operations for the **Ikohza** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ikohzas
    * const ikohzas = await prisma.ikohza.findMany()
    * ```
    */
  get ikohza(): Prisma.IkohzaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyBranch`: Exposes CRUD operations for the **CompanyBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyBranches
    * const companyBranches = await prisma.companyBranch.findMany()
    * ```
    */
  get companyBranch(): Prisma.CompanyBranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authProvider`: Exposes CRUD operations for the **AuthProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthProviders
    * const authProviders = await prisma.authProvider.findMany()
    * ```
    */
  get authProvider(): Prisma.AuthProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicePricing`: Exposes CRUD operations for the **ServicePricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePricings
    * const servicePricings = await prisma.servicePricing.findMany()
    * ```
    */
  get servicePricing(): Prisma.ServicePricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingRequest`: Exposes CRUD operations for the **BookingRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingRequests
    * const bookingRequests = await prisma.bookingRequest.findMany()
    * ```
    */
  get bookingRequest(): Prisma.BookingRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingServiceItem`: Exposes CRUD operations for the **BookingServiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingServiceItems
    * const bookingServiceItems = await prisma.bookingServiceItem.findMany()
    * ```
    */
  get bookingServiceItem(): Prisma.BookingServiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sampleModification`: Exposes CRUD operations for the **SampleModification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SampleModifications
    * const sampleModifications = await prisma.sampleModification.findMany()
    * ```
    */
  get sampleModification(): Prisma.SampleModificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceForm`: Exposes CRUD operations for the **ServiceForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceForms
    * const serviceForms = await prisma.serviceForm.findMany()
    * ```
    */
  get serviceForm(): Prisma.ServiceFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sampleTracking`: Exposes CRUD operations for the **SampleTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SampleTrackings
    * const sampleTrackings = await prisma.sampleTracking.findMany()
    * ```
    */
  get sampleTracking(): Prisma.SampleTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceBooking`: Exposes CRUD operations for the **WorkspaceBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceBookings
    * const workspaceBookings = await prisma.workspaceBooking.findMany()
    * ```
    */
  get workspaceBooking(): Prisma.WorkspaceBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labEquipment`: Exposes CRUD operations for the **LabEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabEquipments
    * const labEquipments = await prisma.labEquipment.findMany()
    * ```
    */
  get labEquipment(): Prisma.LabEquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceEquipmentUsage`: Exposes CRUD operations for the **WorkspaceEquipmentUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceEquipmentUsages
    * const workspaceEquipmentUsages = await prisma.workspaceEquipmentUsage.findMany()
    * ```
    */
  get workspaceEquipmentUsage(): Prisma.WorkspaceEquipmentUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sampleEquipmentUsage`: Exposes CRUD operations for the **SampleEquipmentUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SampleEquipmentUsages
    * const sampleEquipmentUsages = await prisma.sampleEquipmentUsage.findMany()
    * ```
    */
  get sampleEquipmentUsage(): Prisma.SampleEquipmentUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analysisResult`: Exposes CRUD operations for the **AnalysisResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalysisResults
    * const analysisResults = await prisma.analysisResult.findMany()
    * ```
    */
  get analysisResult(): Prisma.AnalysisResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.globalAddOnCatalog`: Exposes CRUD operations for the **GlobalAddOnCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalAddOnCatalogs
    * const globalAddOnCatalogs = await prisma.globalAddOnCatalog.findMany()
    * ```
    */
  get globalAddOnCatalog(): Prisma.GlobalAddOnCatalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceAddOnMapping`: Exposes CRUD operations for the **ServiceAddOnMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAddOnMappings
    * const serviceAddOnMappings = await prisma.serviceAddOnMapping.findMany()
    * ```
    */
  get serviceAddOnMapping(): Prisma.ServiceAddOnMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceAddOn`: Exposes CRUD operations for the **ServiceAddOn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAddOns
    * const serviceAddOns = await prisma.serviceAddOn.findMany()
    * ```
    */
  get serviceAddOn(): Prisma.ServiceAddOnDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BetterAuthUser: 'BetterAuthUser',
    BetterAuthSession: 'BetterAuthSession',
    BetterAuthAccount: 'BetterAuthAccount',
    BetterAuthVerification: 'BetterAuthVerification',
    Faculty: 'Faculty',
    Department: 'Department',
    Ikohza: 'Ikohza',
    Company: 'Company',
    CompanyBranch: 'CompanyBranch',
    User: 'User',
    AuthProvider: 'AuthProvider',
    Service: 'Service',
    ServicePricing: 'ServicePricing',
    BookingRequest: 'BookingRequest',
    BookingServiceItem: 'BookingServiceItem',
    SampleModification: 'SampleModification',
    ServiceForm: 'ServiceForm',
    Invoice: 'Invoice',
    Payment: 'Payment',
    SampleTracking: 'SampleTracking',
    WorkspaceBooking: 'WorkspaceBooking',
    LabEquipment: 'LabEquipment',
    WorkspaceEquipmentUsage: 'WorkspaceEquipmentUsage',
    SampleEquipmentUsage: 'SampleEquipmentUsage',
    AnalysisResult: 'AnalysisResult',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    GlobalAddOnCatalog: 'GlobalAddOnCatalog',
    ServiceAddOnMapping: 'ServiceAddOnMapping',
    ServiceAddOn: 'ServiceAddOn'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "betterAuthUser" | "betterAuthSession" | "betterAuthAccount" | "betterAuthVerification" | "faculty" | "department" | "ikohza" | "company" | "companyBranch" | "user" | "authProvider" | "service" | "servicePricing" | "bookingRequest" | "bookingServiceItem" | "sampleModification" | "serviceForm" | "invoice" | "payment" | "sampleTracking" | "workspaceBooking" | "labEquipment" | "workspaceEquipmentUsage" | "sampleEquipmentUsage" | "analysisResult" | "notification" | "auditLog" | "globalAddOnCatalog" | "serviceAddOnMapping" | "serviceAddOn"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BetterAuthUser: {
        payload: Prisma.$BetterAuthUserPayload<ExtArgs>
        fields: Prisma.BetterAuthUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetterAuthUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetterAuthUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>
          }
          findFirst: {
            args: Prisma.BetterAuthUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetterAuthUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>
          }
          findMany: {
            args: Prisma.BetterAuthUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>[]
          }
          create: {
            args: Prisma.BetterAuthUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>
          }
          createMany: {
            args: Prisma.BetterAuthUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetterAuthUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>[]
          }
          delete: {
            args: Prisma.BetterAuthUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>
          }
          update: {
            args: Prisma.BetterAuthUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>
          }
          deleteMany: {
            args: Prisma.BetterAuthUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetterAuthUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetterAuthUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>[]
          }
          upsert: {
            args: Prisma.BetterAuthUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthUserPayload>
          }
          aggregate: {
            args: Prisma.BetterAuthUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetterAuthUser>
          }
          groupBy: {
            args: Prisma.BetterAuthUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetterAuthUserCountArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthUserCountAggregateOutputType> | number
          }
        }
      }
      BetterAuthSession: {
        payload: Prisma.$BetterAuthSessionPayload<ExtArgs>
        fields: Prisma.BetterAuthSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetterAuthSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetterAuthSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>
          }
          findFirst: {
            args: Prisma.BetterAuthSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetterAuthSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>
          }
          findMany: {
            args: Prisma.BetterAuthSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>[]
          }
          create: {
            args: Prisma.BetterAuthSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>
          }
          createMany: {
            args: Prisma.BetterAuthSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetterAuthSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>[]
          }
          delete: {
            args: Prisma.BetterAuthSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>
          }
          update: {
            args: Prisma.BetterAuthSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>
          }
          deleteMany: {
            args: Prisma.BetterAuthSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetterAuthSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetterAuthSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>[]
          }
          upsert: {
            args: Prisma.BetterAuthSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthSessionPayload>
          }
          aggregate: {
            args: Prisma.BetterAuthSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetterAuthSession>
          }
          groupBy: {
            args: Prisma.BetterAuthSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetterAuthSessionCountArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthSessionCountAggregateOutputType> | number
          }
        }
      }
      BetterAuthAccount: {
        payload: Prisma.$BetterAuthAccountPayload<ExtArgs>
        fields: Prisma.BetterAuthAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetterAuthAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetterAuthAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>
          }
          findFirst: {
            args: Prisma.BetterAuthAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetterAuthAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>
          }
          findMany: {
            args: Prisma.BetterAuthAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>[]
          }
          create: {
            args: Prisma.BetterAuthAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>
          }
          createMany: {
            args: Prisma.BetterAuthAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetterAuthAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>[]
          }
          delete: {
            args: Prisma.BetterAuthAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>
          }
          update: {
            args: Prisma.BetterAuthAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>
          }
          deleteMany: {
            args: Prisma.BetterAuthAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetterAuthAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetterAuthAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>[]
          }
          upsert: {
            args: Prisma.BetterAuthAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthAccountPayload>
          }
          aggregate: {
            args: Prisma.BetterAuthAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetterAuthAccount>
          }
          groupBy: {
            args: Prisma.BetterAuthAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetterAuthAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthAccountCountAggregateOutputType> | number
          }
        }
      }
      BetterAuthVerification: {
        payload: Prisma.$BetterAuthVerificationPayload<ExtArgs>
        fields: Prisma.BetterAuthVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetterAuthVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetterAuthVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>
          }
          findFirst: {
            args: Prisma.BetterAuthVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetterAuthVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>
          }
          findMany: {
            args: Prisma.BetterAuthVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>[]
          }
          create: {
            args: Prisma.BetterAuthVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>
          }
          createMany: {
            args: Prisma.BetterAuthVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetterAuthVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>[]
          }
          delete: {
            args: Prisma.BetterAuthVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>
          }
          update: {
            args: Prisma.BetterAuthVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>
          }
          deleteMany: {
            args: Prisma.BetterAuthVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetterAuthVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BetterAuthVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>[]
          }
          upsert: {
            args: Prisma.BetterAuthVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetterAuthVerificationPayload>
          }
          aggregate: {
            args: Prisma.BetterAuthVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetterAuthVerification>
          }
          groupBy: {
            args: Prisma.BetterAuthVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetterAuthVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<BetterAuthVerificationCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Ikohza: {
        payload: Prisma.$IkohzaPayload<ExtArgs>
        fields: Prisma.IkohzaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IkohzaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IkohzaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>
          }
          findFirst: {
            args: Prisma.IkohzaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IkohzaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>
          }
          findMany: {
            args: Prisma.IkohzaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>[]
          }
          create: {
            args: Prisma.IkohzaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>
          }
          createMany: {
            args: Prisma.IkohzaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IkohzaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>[]
          }
          delete: {
            args: Prisma.IkohzaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>
          }
          update: {
            args: Prisma.IkohzaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>
          }
          deleteMany: {
            args: Prisma.IkohzaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IkohzaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IkohzaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>[]
          }
          upsert: {
            args: Prisma.IkohzaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IkohzaPayload>
          }
          aggregate: {
            args: Prisma.IkohzaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIkohza>
          }
          groupBy: {
            args: Prisma.IkohzaGroupByArgs<ExtArgs>
            result: $Utils.Optional<IkohzaGroupByOutputType>[]
          }
          count: {
            args: Prisma.IkohzaCountArgs<ExtArgs>
            result: $Utils.Optional<IkohzaCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyBranch: {
        payload: Prisma.$CompanyBranchPayload<ExtArgs>
        fields: Prisma.CompanyBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          findFirst: {
            args: Prisma.CompanyBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          findMany: {
            args: Prisma.CompanyBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>[]
          }
          create: {
            args: Prisma.CompanyBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          createMany: {
            args: Prisma.CompanyBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>[]
          }
          delete: {
            args: Prisma.CompanyBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          update: {
            args: Prisma.CompanyBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          deleteMany: {
            args: Prisma.CompanyBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyBranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>[]
          }
          upsert: {
            args: Prisma.CompanyBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBranchPayload>
          }
          aggregate: {
            args: Prisma.CompanyBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyBranch>
          }
          groupBy: {
            args: Prisma.CompanyBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyBranchCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyBranchCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AuthProvider: {
        payload: Prisma.$AuthProviderPayload<ExtArgs>
        fields: Prisma.AuthProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          findFirst: {
            args: Prisma.AuthProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          findMany: {
            args: Prisma.AuthProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>[]
          }
          create: {
            args: Prisma.AuthProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          createMany: {
            args: Prisma.AuthProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>[]
          }
          delete: {
            args: Prisma.AuthProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          update: {
            args: Prisma.AuthProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          deleteMany: {
            args: Prisma.AuthProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>[]
          }
          upsert: {
            args: Prisma.AuthProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          aggregate: {
            args: Prisma.AuthProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthProvider>
          }
          groupBy: {
            args: Prisma.AuthProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthProviderCountArgs<ExtArgs>
            result: $Utils.Optional<AuthProviderCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServicePricing: {
        payload: Prisma.$ServicePricingPayload<ExtArgs>
        fields: Prisma.ServicePricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>
          }
          findFirst: {
            args: Prisma.ServicePricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>
          }
          findMany: {
            args: Prisma.ServicePricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>[]
          }
          create: {
            args: Prisma.ServicePricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>
          }
          createMany: {
            args: Prisma.ServicePricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>[]
          }
          delete: {
            args: Prisma.ServicePricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>
          }
          update: {
            args: Prisma.ServicePricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>
          }
          deleteMany: {
            args: Prisma.ServicePricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicePricingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>[]
          }
          upsert: {
            args: Prisma.ServicePricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingPayload>
          }
          aggregate: {
            args: Prisma.ServicePricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePricing>
          }
          groupBy: {
            args: Prisma.ServicePricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePricingCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePricingCountAggregateOutputType> | number
          }
        }
      }
      BookingRequest: {
        payload: Prisma.$BookingRequestPayload<ExtArgs>
        fields: Prisma.BookingRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          findFirst: {
            args: Prisma.BookingRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          findMany: {
            args: Prisma.BookingRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>[]
          }
          create: {
            args: Prisma.BookingRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          createMany: {
            args: Prisma.BookingRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>[]
          }
          delete: {
            args: Prisma.BookingRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          update: {
            args: Prisma.BookingRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          deleteMany: {
            args: Prisma.BookingRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>[]
          }
          upsert: {
            args: Prisma.BookingRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          aggregate: {
            args: Prisma.BookingRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingRequest>
          }
          groupBy: {
            args: Prisma.BookingRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingRequestCountArgs<ExtArgs>
            result: $Utils.Optional<BookingRequestCountAggregateOutputType> | number
          }
        }
      }
      BookingServiceItem: {
        payload: Prisma.$BookingServiceItemPayload<ExtArgs>
        fields: Prisma.BookingServiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingServiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingServiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>
          }
          findFirst: {
            args: Prisma.BookingServiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingServiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>
          }
          findMany: {
            args: Prisma.BookingServiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>[]
          }
          create: {
            args: Prisma.BookingServiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>
          }
          createMany: {
            args: Prisma.BookingServiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingServiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>[]
          }
          delete: {
            args: Prisma.BookingServiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>
          }
          update: {
            args: Prisma.BookingServiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>
          }
          deleteMany: {
            args: Prisma.BookingServiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingServiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingServiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>[]
          }
          upsert: {
            args: Prisma.BookingServiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServiceItemPayload>
          }
          aggregate: {
            args: Prisma.BookingServiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingServiceItem>
          }
          groupBy: {
            args: Prisma.BookingServiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingServiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceItemCountAggregateOutputType> | number
          }
        }
      }
      SampleModification: {
        payload: Prisma.$SampleModificationPayload<ExtArgs>
        fields: Prisma.SampleModificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SampleModificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SampleModificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>
          }
          findFirst: {
            args: Prisma.SampleModificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SampleModificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>
          }
          findMany: {
            args: Prisma.SampleModificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>[]
          }
          create: {
            args: Prisma.SampleModificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>
          }
          createMany: {
            args: Prisma.SampleModificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SampleModificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>[]
          }
          delete: {
            args: Prisma.SampleModificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>
          }
          update: {
            args: Prisma.SampleModificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>
          }
          deleteMany: {
            args: Prisma.SampleModificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SampleModificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SampleModificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>[]
          }
          upsert: {
            args: Prisma.SampleModificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleModificationPayload>
          }
          aggregate: {
            args: Prisma.SampleModificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSampleModification>
          }
          groupBy: {
            args: Prisma.SampleModificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SampleModificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SampleModificationCountArgs<ExtArgs>
            result: $Utils.Optional<SampleModificationCountAggregateOutputType> | number
          }
        }
      }
      ServiceForm: {
        payload: Prisma.$ServiceFormPayload<ExtArgs>
        fields: Prisma.ServiceFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          findFirst: {
            args: Prisma.ServiceFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          findMany: {
            args: Prisma.ServiceFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>[]
          }
          create: {
            args: Prisma.ServiceFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          createMany: {
            args: Prisma.ServiceFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>[]
          }
          delete: {
            args: Prisma.ServiceFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          update: {
            args: Prisma.ServiceFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          deleteMany: {
            args: Prisma.ServiceFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>[]
          }
          upsert: {
            args: Prisma.ServiceFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFormPayload>
          }
          aggregate: {
            args: Prisma.ServiceFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceForm>
          }
          groupBy: {
            args: Prisma.ServiceFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceFormCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceFormCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      SampleTracking: {
        payload: Prisma.$SampleTrackingPayload<ExtArgs>
        fields: Prisma.SampleTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SampleTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SampleTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>
          }
          findFirst: {
            args: Prisma.SampleTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SampleTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>
          }
          findMany: {
            args: Prisma.SampleTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>[]
          }
          create: {
            args: Prisma.SampleTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>
          }
          createMany: {
            args: Prisma.SampleTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SampleTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>[]
          }
          delete: {
            args: Prisma.SampleTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>
          }
          update: {
            args: Prisma.SampleTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>
          }
          deleteMany: {
            args: Prisma.SampleTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SampleTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SampleTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>[]
          }
          upsert: {
            args: Prisma.SampleTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleTrackingPayload>
          }
          aggregate: {
            args: Prisma.SampleTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSampleTracking>
          }
          groupBy: {
            args: Prisma.SampleTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SampleTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SampleTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<SampleTrackingCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceBooking: {
        payload: Prisma.$WorkspaceBookingPayload<ExtArgs>
        fields: Prisma.WorkspaceBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>
          }
          findMany: {
            args: Prisma.WorkspaceBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>[]
          }
          create: {
            args: Prisma.WorkspaceBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>
          }
          createMany: {
            args: Prisma.WorkspaceBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>
          }
          update: {
            args: Prisma.WorkspaceBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceBookingPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceBooking>
          }
          groupBy: {
            args: Prisma.WorkspaceBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceBookingCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceBookingCountAggregateOutputType> | number
          }
        }
      }
      LabEquipment: {
        payload: Prisma.$LabEquipmentPayload<ExtArgs>
        fields: Prisma.LabEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>
          }
          findFirst: {
            args: Prisma.LabEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>
          }
          findMany: {
            args: Prisma.LabEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>[]
          }
          create: {
            args: Prisma.LabEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>
          }
          createMany: {
            args: Prisma.LabEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>[]
          }
          delete: {
            args: Prisma.LabEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>
          }
          update: {
            args: Prisma.LabEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.LabEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabEquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>[]
          }
          upsert: {
            args: Prisma.LabEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabEquipmentPayload>
          }
          aggregate: {
            args: Prisma.LabEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabEquipment>
          }
          groupBy: {
            args: Prisma.LabEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<LabEquipmentCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceEquipmentUsage: {
        payload: Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>
        fields: Prisma.WorkspaceEquipmentUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceEquipmentUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceEquipmentUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceEquipmentUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceEquipmentUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>
          }
          findMany: {
            args: Prisma.WorkspaceEquipmentUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>[]
          }
          create: {
            args: Prisma.WorkspaceEquipmentUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>
          }
          createMany: {
            args: Prisma.WorkspaceEquipmentUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceEquipmentUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceEquipmentUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>
          }
          update: {
            args: Prisma.WorkspaceEquipmentUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceEquipmentUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceEquipmentUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceEquipmentUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceEquipmentUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceEquipmentUsagePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceEquipmentUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceEquipmentUsage>
          }
          groupBy: {
            args: Prisma.WorkspaceEquipmentUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceEquipmentUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceEquipmentUsageCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceEquipmentUsageCountAggregateOutputType> | number
          }
        }
      }
      SampleEquipmentUsage: {
        payload: Prisma.$SampleEquipmentUsagePayload<ExtArgs>
        fields: Prisma.SampleEquipmentUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SampleEquipmentUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SampleEquipmentUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>
          }
          findFirst: {
            args: Prisma.SampleEquipmentUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SampleEquipmentUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>
          }
          findMany: {
            args: Prisma.SampleEquipmentUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>[]
          }
          create: {
            args: Prisma.SampleEquipmentUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>
          }
          createMany: {
            args: Prisma.SampleEquipmentUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SampleEquipmentUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>[]
          }
          delete: {
            args: Prisma.SampleEquipmentUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>
          }
          update: {
            args: Prisma.SampleEquipmentUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>
          }
          deleteMany: {
            args: Prisma.SampleEquipmentUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SampleEquipmentUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SampleEquipmentUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>[]
          }
          upsert: {
            args: Prisma.SampleEquipmentUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SampleEquipmentUsagePayload>
          }
          aggregate: {
            args: Prisma.SampleEquipmentUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSampleEquipmentUsage>
          }
          groupBy: {
            args: Prisma.SampleEquipmentUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SampleEquipmentUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SampleEquipmentUsageCountArgs<ExtArgs>
            result: $Utils.Optional<SampleEquipmentUsageCountAggregateOutputType> | number
          }
        }
      }
      AnalysisResult: {
        payload: Prisma.$AnalysisResultPayload<ExtArgs>
        fields: Prisma.AnalysisResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalysisResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalysisResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>
          }
          findFirst: {
            args: Prisma.AnalysisResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalysisResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>
          }
          findMany: {
            args: Prisma.AnalysisResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>[]
          }
          create: {
            args: Prisma.AnalysisResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>
          }
          createMany: {
            args: Prisma.AnalysisResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalysisResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>[]
          }
          delete: {
            args: Prisma.AnalysisResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>
          }
          update: {
            args: Prisma.AnalysisResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>
          }
          deleteMany: {
            args: Prisma.AnalysisResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalysisResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalysisResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>[]
          }
          upsert: {
            args: Prisma.AnalysisResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalysisResultPayload>
          }
          aggregate: {
            args: Prisma.AnalysisResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalysisResult>
          }
          groupBy: {
            args: Prisma.AnalysisResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalysisResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalysisResultCountArgs<ExtArgs>
            result: $Utils.Optional<AnalysisResultCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      GlobalAddOnCatalog: {
        payload: Prisma.$GlobalAddOnCatalogPayload<ExtArgs>
        fields: Prisma.GlobalAddOnCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalAddOnCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalAddOnCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>
          }
          findFirst: {
            args: Prisma.GlobalAddOnCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalAddOnCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>
          }
          findMany: {
            args: Prisma.GlobalAddOnCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>[]
          }
          create: {
            args: Prisma.GlobalAddOnCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>
          }
          createMany: {
            args: Prisma.GlobalAddOnCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalAddOnCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>[]
          }
          delete: {
            args: Prisma.GlobalAddOnCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>
          }
          update: {
            args: Prisma.GlobalAddOnCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>
          }
          deleteMany: {
            args: Prisma.GlobalAddOnCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalAddOnCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlobalAddOnCatalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>[]
          }
          upsert: {
            args: Prisma.GlobalAddOnCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalAddOnCatalogPayload>
          }
          aggregate: {
            args: Prisma.GlobalAddOnCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalAddOnCatalog>
          }
          groupBy: {
            args: Prisma.GlobalAddOnCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalAddOnCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalAddOnCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalAddOnCatalogCountAggregateOutputType> | number
          }
        }
      }
      ServiceAddOnMapping: {
        payload: Prisma.$ServiceAddOnMappingPayload<ExtArgs>
        fields: Prisma.ServiceAddOnMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAddOnMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAddOnMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>
          }
          findFirst: {
            args: Prisma.ServiceAddOnMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAddOnMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>
          }
          findMany: {
            args: Prisma.ServiceAddOnMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>[]
          }
          create: {
            args: Prisma.ServiceAddOnMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>
          }
          createMany: {
            args: Prisma.ServiceAddOnMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAddOnMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>[]
          }
          delete: {
            args: Prisma.ServiceAddOnMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>
          }
          update: {
            args: Prisma.ServiceAddOnMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAddOnMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAddOnMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceAddOnMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>[]
          }
          upsert: {
            args: Prisma.ServiceAddOnMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnMappingPayload>
          }
          aggregate: {
            args: Prisma.ServiceAddOnMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAddOnMapping>
          }
          groupBy: {
            args: Prisma.ServiceAddOnMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAddOnMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAddOnMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAddOnMappingCountAggregateOutputType> | number
          }
        }
      }
      ServiceAddOn: {
        payload: Prisma.$ServiceAddOnPayload<ExtArgs>
        fields: Prisma.ServiceAddOnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAddOnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAddOnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>
          }
          findFirst: {
            args: Prisma.ServiceAddOnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAddOnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>
          }
          findMany: {
            args: Prisma.ServiceAddOnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>[]
          }
          create: {
            args: Prisma.ServiceAddOnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>
          }
          createMany: {
            args: Prisma.ServiceAddOnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAddOnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>[]
          }
          delete: {
            args: Prisma.ServiceAddOnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>
          }
          update: {
            args: Prisma.ServiceAddOnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAddOnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAddOnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceAddOnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>[]
          }
          upsert: {
            args: Prisma.ServiceAddOnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAddOnPayload>
          }
          aggregate: {
            args: Prisma.ServiceAddOnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAddOn>
          }
          groupBy: {
            args: Prisma.ServiceAddOnGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAddOnGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAddOnCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAddOnCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    betterAuthUser?: BetterAuthUserOmit
    betterAuthSession?: BetterAuthSessionOmit
    betterAuthAccount?: BetterAuthAccountOmit
    betterAuthVerification?: BetterAuthVerificationOmit
    faculty?: FacultyOmit
    department?: DepartmentOmit
    ikohza?: IkohzaOmit
    company?: CompanyOmit
    companyBranch?: CompanyBranchOmit
    user?: UserOmit
    authProvider?: AuthProviderOmit
    service?: ServiceOmit
    servicePricing?: ServicePricingOmit
    bookingRequest?: BookingRequestOmit
    bookingServiceItem?: BookingServiceItemOmit
    sampleModification?: SampleModificationOmit
    serviceForm?: ServiceFormOmit
    invoice?: InvoiceOmit
    payment?: PaymentOmit
    sampleTracking?: SampleTrackingOmit
    workspaceBooking?: WorkspaceBookingOmit
    labEquipment?: LabEquipmentOmit
    workspaceEquipmentUsage?: WorkspaceEquipmentUsageOmit
    sampleEquipmentUsage?: SampleEquipmentUsageOmit
    analysisResult?: AnalysisResultOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    globalAddOnCatalog?: GlobalAddOnCatalogOmit
    serviceAddOnMapping?: ServiceAddOnMappingOmit
    serviceAddOn?: ServiceAddOnOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BetterAuthUserCountOutputType
   */

  export type BetterAuthUserCountOutputType = {
    sessions: number
    accounts: number
    verifications: number
  }

  export type BetterAuthUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | BetterAuthUserCountOutputTypeCountSessionsArgs
    accounts?: boolean | BetterAuthUserCountOutputTypeCountAccountsArgs
    verifications?: boolean | BetterAuthUserCountOutputTypeCountVerificationsArgs
  }

  // Custom InputTypes
  /**
   * BetterAuthUserCountOutputType without action
   */
  export type BetterAuthUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUserCountOutputType
     */
    select?: BetterAuthUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BetterAuthUserCountOutputType without action
   */
  export type BetterAuthUserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthSessionWhereInput
  }

  /**
   * BetterAuthUserCountOutputType without action
   */
  export type BetterAuthUserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthAccountWhereInput
  }

  /**
   * BetterAuthUserCountOutputType without action
   */
  export type BetterAuthUserCountOutputTypeCountVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthVerificationWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    departments: number
    ikohzas: number
    users: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | FacultyCountOutputTypeCountDepartmentsArgs
    ikohzas?: boolean | FacultyCountOutputTypeCountIkohzasArgs
    users?: boolean | FacultyCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountIkohzasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IkohzaWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    users: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type IkohzaCountOutputType
   */

  export type IkohzaCountOutputType = {
    users: number
  }

  export type IkohzaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | IkohzaCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * IkohzaCountOutputType without action
   */
  export type IkohzaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IkohzaCountOutputType
     */
    select?: IkohzaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IkohzaCountOutputType without action
   */
  export type IkohzaCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    branches: number
    users: number
    bookings: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | CompanyCountOutputTypeCountBranchesArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    bookings?: boolean | CompanyCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBranchWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
  }


  /**
   * Count Type CompanyBranchCountOutputType
   */

  export type CompanyBranchCountOutputType = {
    users: number
    bookings: number
  }

  export type CompanyBranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyBranchCountOutputTypeCountUsersArgs
    bookings?: boolean | CompanyBranchCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * CompanyBranchCountOutputType without action
   */
  export type CompanyBranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranchCountOutputType
     */
    select?: CompanyBranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyBranchCountOutputType without action
   */
  export type CompanyBranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyBranchCountOutputType without action
   */
  export type CompanyBranchCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    approvedUsers: number
    authProviders: number
    auditLogs: number
    bookingRequests: number
    approvedBookings: number
    serviceForms: number
    uploadedInvoices: number
    verifiedPayments: number
    uploadedResults: number
    notifications: number
    sampleTracking: number
    createdModifications: number
    approvedModifications: number
    uploadedPayments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedUsers?: boolean | UserCountOutputTypeCountApprovedUsersArgs
    authProviders?: boolean | UserCountOutputTypeCountAuthProvidersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    bookingRequests?: boolean | UserCountOutputTypeCountBookingRequestsArgs
    approvedBookings?: boolean | UserCountOutputTypeCountApprovedBookingsArgs
    serviceForms?: boolean | UserCountOutputTypeCountServiceFormsArgs
    uploadedInvoices?: boolean | UserCountOutputTypeCountUploadedInvoicesArgs
    verifiedPayments?: boolean | UserCountOutputTypeCountVerifiedPaymentsArgs
    uploadedResults?: boolean | UserCountOutputTypeCountUploadedResultsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sampleTracking?: boolean | UserCountOutputTypeCountSampleTrackingArgs
    createdModifications?: boolean | UserCountOutputTypeCountCreatedModificationsArgs
    approvedModifications?: boolean | UserCountOutputTypeCountApprovedModificationsArgs
    uploadedPayments?: boolean | UserCountOutputTypeCountUploadedPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthProviderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerifiedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisResultWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSampleTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleTrackingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedModificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleModificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedModificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleModificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    pricing: number
    bookingItems: number
    addOnMappings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricing?: boolean | ServiceCountOutputTypeCountPricingArgs
    bookingItems?: boolean | ServiceCountOutputTypeCountBookingItemsArgs
    addOnMappings?: boolean | ServiceCountOutputTypeCountAddOnMappingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePricingWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceItemWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAddOnMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnMappingWhereInput
  }


  /**
   * Count Type BookingRequestCountOutputType
   */

  export type BookingRequestCountOutputType = {
    serviceItems: number
    workspaceBookings: number
    serviceForms: number
  }

  export type BookingRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceItems?: boolean | BookingRequestCountOutputTypeCountServiceItemsArgs
    workspaceBookings?: boolean | BookingRequestCountOutputTypeCountWorkspaceBookingsArgs
    serviceForms?: boolean | BookingRequestCountOutputTypeCountServiceFormsArgs
  }

  // Custom InputTypes
  /**
   * BookingRequestCountOutputType without action
   */
  export type BookingRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequestCountOutputType
     */
    select?: BookingRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingRequestCountOutputType without action
   */
  export type BookingRequestCountOutputTypeCountServiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceItemWhereInput
  }

  /**
   * BookingRequestCountOutputType without action
   */
  export type BookingRequestCountOutputTypeCountWorkspaceBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceBookingWhereInput
  }

  /**
   * BookingRequestCountOutputType without action
   */
  export type BookingRequestCountOutputTypeCountServiceFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
  }


  /**
   * Count Type BookingServiceItemCountOutputType
   */

  export type BookingServiceItemCountOutputType = {
    equipmentUsages: number
    modifications: number
    sampleTracking: number
    serviceAddOns: number
  }

  export type BookingServiceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipmentUsages?: boolean | BookingServiceItemCountOutputTypeCountEquipmentUsagesArgs
    modifications?: boolean | BookingServiceItemCountOutputTypeCountModificationsArgs
    sampleTracking?: boolean | BookingServiceItemCountOutputTypeCountSampleTrackingArgs
    serviceAddOns?: boolean | BookingServiceItemCountOutputTypeCountServiceAddOnsArgs
  }

  // Custom InputTypes
  /**
   * BookingServiceItemCountOutputType without action
   */
  export type BookingServiceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItemCountOutputType
     */
    select?: BookingServiceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingServiceItemCountOutputType without action
   */
  export type BookingServiceItemCountOutputTypeCountEquipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleEquipmentUsageWhereInput
  }

  /**
   * BookingServiceItemCountOutputType without action
   */
  export type BookingServiceItemCountOutputTypeCountModificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleModificationWhereInput
  }

  /**
   * BookingServiceItemCountOutputType without action
   */
  export type BookingServiceItemCountOutputTypeCountSampleTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleTrackingWhereInput
  }

  /**
   * BookingServiceItemCountOutputType without action
   */
  export type BookingServiceItemCountOutputTypeCountServiceAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnWhereInput
  }


  /**
   * Count Type ServiceFormCountOutputType
   */

  export type ServiceFormCountOutputType = {
    invoices: number
  }

  export type ServiceFormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | ServiceFormCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceFormCountOutputType without action
   */
  export type ServiceFormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFormCountOutputType
     */
    select?: ServiceFormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceFormCountOutputType without action
   */
  export type ServiceFormCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type SampleTrackingCountOutputType
   */

  export type SampleTrackingCountOutputType = {
    analysisResults: number
  }

  export type SampleTrackingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    analysisResults?: boolean | SampleTrackingCountOutputTypeCountAnalysisResultsArgs
  }

  // Custom InputTypes
  /**
   * SampleTrackingCountOutputType without action
   */
  export type SampleTrackingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTrackingCountOutputType
     */
    select?: SampleTrackingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SampleTrackingCountOutputType without action
   */
  export type SampleTrackingCountOutputTypeCountAnalysisResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisResultWhereInput
  }


  /**
   * Count Type WorkspaceBookingCountOutputType
   */

  export type WorkspaceBookingCountOutputType = {
    equipmentUsages: number
    serviceAddOns: number
  }

  export type WorkspaceBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipmentUsages?: boolean | WorkspaceBookingCountOutputTypeCountEquipmentUsagesArgs
    serviceAddOns?: boolean | WorkspaceBookingCountOutputTypeCountServiceAddOnsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceBookingCountOutputType without action
   */
  export type WorkspaceBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBookingCountOutputType
     */
    select?: WorkspaceBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceBookingCountOutputType without action
   */
  export type WorkspaceBookingCountOutputTypeCountEquipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceEquipmentUsageWhereInput
  }

  /**
   * WorkspaceBookingCountOutputType without action
   */
  export type WorkspaceBookingCountOutputTypeCountServiceAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnWhereInput
  }


  /**
   * Count Type LabEquipmentCountOutputType
   */

  export type LabEquipmentCountOutputType = {
    workspaceUsages: number
    sampleUsages: number
  }

  export type LabEquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaceUsages?: boolean | LabEquipmentCountOutputTypeCountWorkspaceUsagesArgs
    sampleUsages?: boolean | LabEquipmentCountOutputTypeCountSampleUsagesArgs
  }

  // Custom InputTypes
  /**
   * LabEquipmentCountOutputType without action
   */
  export type LabEquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipmentCountOutputType
     */
    select?: LabEquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabEquipmentCountOutputType without action
   */
  export type LabEquipmentCountOutputTypeCountWorkspaceUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceEquipmentUsageWhereInput
  }

  /**
   * LabEquipmentCountOutputType without action
   */
  export type LabEquipmentCountOutputTypeCountSampleUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleEquipmentUsageWhereInput
  }


  /**
   * Count Type GlobalAddOnCatalogCountOutputType
   */

  export type GlobalAddOnCatalogCountOutputType = {
    serviceMappings: number
    serviceAddOns: number
  }

  export type GlobalAddOnCatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceMappings?: boolean | GlobalAddOnCatalogCountOutputTypeCountServiceMappingsArgs
    serviceAddOns?: boolean | GlobalAddOnCatalogCountOutputTypeCountServiceAddOnsArgs
  }

  // Custom InputTypes
  /**
   * GlobalAddOnCatalogCountOutputType without action
   */
  export type GlobalAddOnCatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalogCountOutputType
     */
    select?: GlobalAddOnCatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GlobalAddOnCatalogCountOutputType without action
   */
  export type GlobalAddOnCatalogCountOutputTypeCountServiceMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnMappingWhereInput
  }

  /**
   * GlobalAddOnCatalogCountOutputType without action
   */
  export type GlobalAddOnCatalogCountOutputTypeCountServiceAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BetterAuthUser
   */

  export type AggregateBetterAuthUser = {
    _count: BetterAuthUserCountAggregateOutputType | null
    _min: BetterAuthUserMinAggregateOutputType | null
    _max: BetterAuthUserMaxAggregateOutputType | null
  }

  export type BetterAuthUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetterAuthUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetterAuthUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BetterAuthUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetterAuthUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetterAuthUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BetterAuthUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthUser to aggregate.
     */
    where?: BetterAuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthUsers to fetch.
     */
    orderBy?: BetterAuthUserOrderByWithRelationInput | BetterAuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetterAuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetterAuthUsers
    **/
    _count?: true | BetterAuthUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetterAuthUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetterAuthUserMaxAggregateInputType
  }

  export type GetBetterAuthUserAggregateType<T extends BetterAuthUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBetterAuthUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetterAuthUser[P]>
      : GetScalarType<T[P], AggregateBetterAuthUser[P]>
  }




  export type BetterAuthUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthUserWhereInput
    orderBy?: BetterAuthUserOrderByWithAggregationInput | BetterAuthUserOrderByWithAggregationInput[]
    by: BetterAuthUserScalarFieldEnum[] | BetterAuthUserScalarFieldEnum
    having?: BetterAuthUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetterAuthUserCountAggregateInputType | true
    _min?: BetterAuthUserMinAggregateInputType
    _max?: BetterAuthUserMaxAggregateInputType
  }

  export type BetterAuthUserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: BetterAuthUserCountAggregateOutputType | null
    _min: BetterAuthUserMinAggregateOutputType | null
    _max: BetterAuthUserMaxAggregateOutputType | null
  }

  type GetBetterAuthUserGroupByPayload<T extends BetterAuthUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetterAuthUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetterAuthUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetterAuthUserGroupByOutputType[P]>
            : GetScalarType<T[P], BetterAuthUserGroupByOutputType[P]>
        }
      >
    >


  export type BetterAuthUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | BetterAuthUser$sessionsArgs<ExtArgs>
    accounts?: boolean | BetterAuthUser$accountsArgs<ExtArgs>
    verifications?: boolean | BetterAuthUser$verificationsArgs<ExtArgs>
    _count?: boolean | BetterAuthUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthUser"]>

  export type BetterAuthUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["betterAuthUser"]>

  export type BetterAuthUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["betterAuthUser"]>

  export type BetterAuthUserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BetterAuthUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["betterAuthUser"]>
  export type BetterAuthUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | BetterAuthUser$sessionsArgs<ExtArgs>
    accounts?: boolean | BetterAuthUser$accountsArgs<ExtArgs>
    verifications?: boolean | BetterAuthUser$verificationsArgs<ExtArgs>
    _count?: boolean | BetterAuthUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BetterAuthUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BetterAuthUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BetterAuthUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetterAuthUser"
    objects: {
      sessions: Prisma.$BetterAuthSessionPayload<ExtArgs>[]
      accounts: Prisma.$BetterAuthAccountPayload<ExtArgs>[]
      verifications: Prisma.$BetterAuthVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["betterAuthUser"]>
    composites: {}
  }

  type BetterAuthUserGetPayload<S extends boolean | null | undefined | BetterAuthUserDefaultArgs> = $Result.GetResult<Prisma.$BetterAuthUserPayload, S>

  type BetterAuthUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetterAuthUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetterAuthUserCountAggregateInputType | true
    }

  export interface BetterAuthUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetterAuthUser'], meta: { name: 'BetterAuthUser' } }
    /**
     * Find zero or one BetterAuthUser that matches the filter.
     * @param {BetterAuthUserFindUniqueArgs} args - Arguments to find a BetterAuthUser
     * @example
     * // Get one BetterAuthUser
     * const betterAuthUser = await prisma.betterAuthUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetterAuthUserFindUniqueArgs>(args: SelectSubset<T, BetterAuthUserFindUniqueArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetterAuthUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetterAuthUserFindUniqueOrThrowArgs} args - Arguments to find a BetterAuthUser
     * @example
     * // Get one BetterAuthUser
     * const betterAuthUser = await prisma.betterAuthUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetterAuthUserFindUniqueOrThrowArgs>(args: SelectSubset<T, BetterAuthUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserFindFirstArgs} args - Arguments to find a BetterAuthUser
     * @example
     * // Get one BetterAuthUser
     * const betterAuthUser = await prisma.betterAuthUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetterAuthUserFindFirstArgs>(args?: SelectSubset<T, BetterAuthUserFindFirstArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserFindFirstOrThrowArgs} args - Arguments to find a BetterAuthUser
     * @example
     * // Get one BetterAuthUser
     * const betterAuthUser = await prisma.betterAuthUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetterAuthUserFindFirstOrThrowArgs>(args?: SelectSubset<T, BetterAuthUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetterAuthUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetterAuthUsers
     * const betterAuthUsers = await prisma.betterAuthUser.findMany()
     * 
     * // Get first 10 BetterAuthUsers
     * const betterAuthUsers = await prisma.betterAuthUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betterAuthUserWithIdOnly = await prisma.betterAuthUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetterAuthUserFindManyArgs>(args?: SelectSubset<T, BetterAuthUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetterAuthUser.
     * @param {BetterAuthUserCreateArgs} args - Arguments to create a BetterAuthUser.
     * @example
     * // Create one BetterAuthUser
     * const BetterAuthUser = await prisma.betterAuthUser.create({
     *   data: {
     *     // ... data to create a BetterAuthUser
     *   }
     * })
     * 
     */
    create<T extends BetterAuthUserCreateArgs>(args: SelectSubset<T, BetterAuthUserCreateArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetterAuthUsers.
     * @param {BetterAuthUserCreateManyArgs} args - Arguments to create many BetterAuthUsers.
     * @example
     * // Create many BetterAuthUsers
     * const betterAuthUser = await prisma.betterAuthUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetterAuthUserCreateManyArgs>(args?: SelectSubset<T, BetterAuthUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetterAuthUsers and returns the data saved in the database.
     * @param {BetterAuthUserCreateManyAndReturnArgs} args - Arguments to create many BetterAuthUsers.
     * @example
     * // Create many BetterAuthUsers
     * const betterAuthUser = await prisma.betterAuthUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetterAuthUsers and only return the `id`
     * const betterAuthUserWithIdOnly = await prisma.betterAuthUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetterAuthUserCreateManyAndReturnArgs>(args?: SelectSubset<T, BetterAuthUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetterAuthUser.
     * @param {BetterAuthUserDeleteArgs} args - Arguments to delete one BetterAuthUser.
     * @example
     * // Delete one BetterAuthUser
     * const BetterAuthUser = await prisma.betterAuthUser.delete({
     *   where: {
     *     // ... filter to delete one BetterAuthUser
     *   }
     * })
     * 
     */
    delete<T extends BetterAuthUserDeleteArgs>(args: SelectSubset<T, BetterAuthUserDeleteArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetterAuthUser.
     * @param {BetterAuthUserUpdateArgs} args - Arguments to update one BetterAuthUser.
     * @example
     * // Update one BetterAuthUser
     * const betterAuthUser = await prisma.betterAuthUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetterAuthUserUpdateArgs>(args: SelectSubset<T, BetterAuthUserUpdateArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetterAuthUsers.
     * @param {BetterAuthUserDeleteManyArgs} args - Arguments to filter BetterAuthUsers to delete.
     * @example
     * // Delete a few BetterAuthUsers
     * const { count } = await prisma.betterAuthUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetterAuthUserDeleteManyArgs>(args?: SelectSubset<T, BetterAuthUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetterAuthUsers
     * const betterAuthUser = await prisma.betterAuthUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetterAuthUserUpdateManyArgs>(args: SelectSubset<T, BetterAuthUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthUsers and returns the data updated in the database.
     * @param {BetterAuthUserUpdateManyAndReturnArgs} args - Arguments to update many BetterAuthUsers.
     * @example
     * // Update many BetterAuthUsers
     * const betterAuthUser = await prisma.betterAuthUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetterAuthUsers and only return the `id`
     * const betterAuthUserWithIdOnly = await prisma.betterAuthUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetterAuthUserUpdateManyAndReturnArgs>(args: SelectSubset<T, BetterAuthUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetterAuthUser.
     * @param {BetterAuthUserUpsertArgs} args - Arguments to update or create a BetterAuthUser.
     * @example
     * // Update or create a BetterAuthUser
     * const betterAuthUser = await prisma.betterAuthUser.upsert({
     *   create: {
     *     // ... data to create a BetterAuthUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetterAuthUser we want to update
     *   }
     * })
     */
    upsert<T extends BetterAuthUserUpsertArgs>(args: SelectSubset<T, BetterAuthUserUpsertArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetterAuthUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserCountArgs} args - Arguments to filter BetterAuthUsers to count.
     * @example
     * // Count the number of BetterAuthUsers
     * const count = await prisma.betterAuthUser.count({
     *   where: {
     *     // ... the filter for the BetterAuthUsers we want to count
     *   }
     * })
    **/
    count<T extends BetterAuthUserCountArgs>(
      args?: Subset<T, BetterAuthUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetterAuthUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetterAuthUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetterAuthUserAggregateArgs>(args: Subset<T, BetterAuthUserAggregateArgs>): Prisma.PrismaPromise<GetBetterAuthUserAggregateType<T>>

    /**
     * Group by BetterAuthUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetterAuthUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetterAuthUserGroupByArgs['orderBy'] }
        : { orderBy?: BetterAuthUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetterAuthUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetterAuthUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetterAuthUser model
   */
  readonly fields: BetterAuthUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetterAuthUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetterAuthUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends BetterAuthUser$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, BetterAuthUser$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends BetterAuthUser$accountsArgs<ExtArgs> = {}>(args?: Subset<T, BetterAuthUser$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifications<T extends BetterAuthUser$verificationsArgs<ExtArgs> = {}>(args?: Subset<T, BetterAuthUser$verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetterAuthUser model
   */
  interface BetterAuthUserFieldRefs {
    readonly id: FieldRef<"BetterAuthUser", 'String'>
    readonly name: FieldRef<"BetterAuthUser", 'String'>
    readonly email: FieldRef<"BetterAuthUser", 'String'>
    readonly emailVerified: FieldRef<"BetterAuthUser", 'Boolean'>
    readonly image: FieldRef<"BetterAuthUser", 'String'>
    readonly createdAt: FieldRef<"BetterAuthUser", 'DateTime'>
    readonly updatedAt: FieldRef<"BetterAuthUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetterAuthUser findUnique
   */
  export type BetterAuthUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthUser to fetch.
     */
    where: BetterAuthUserWhereUniqueInput
  }

  /**
   * BetterAuthUser findUniqueOrThrow
   */
  export type BetterAuthUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthUser to fetch.
     */
    where: BetterAuthUserWhereUniqueInput
  }

  /**
   * BetterAuthUser findFirst
   */
  export type BetterAuthUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthUser to fetch.
     */
    where?: BetterAuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthUsers to fetch.
     */
    orderBy?: BetterAuthUserOrderByWithRelationInput | BetterAuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthUsers.
     */
    cursor?: BetterAuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthUsers.
     */
    distinct?: BetterAuthUserScalarFieldEnum | BetterAuthUserScalarFieldEnum[]
  }

  /**
   * BetterAuthUser findFirstOrThrow
   */
  export type BetterAuthUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthUser to fetch.
     */
    where?: BetterAuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthUsers to fetch.
     */
    orderBy?: BetterAuthUserOrderByWithRelationInput | BetterAuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthUsers.
     */
    cursor?: BetterAuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthUsers.
     */
    distinct?: BetterAuthUserScalarFieldEnum | BetterAuthUserScalarFieldEnum[]
  }

  /**
   * BetterAuthUser findMany
   */
  export type BetterAuthUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthUsers to fetch.
     */
    where?: BetterAuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthUsers to fetch.
     */
    orderBy?: BetterAuthUserOrderByWithRelationInput | BetterAuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetterAuthUsers.
     */
    cursor?: BetterAuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthUsers.
     */
    skip?: number
    distinct?: BetterAuthUserScalarFieldEnum | BetterAuthUserScalarFieldEnum[]
  }

  /**
   * BetterAuthUser create
   */
  export type BetterAuthUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BetterAuthUser.
     */
    data: XOR<BetterAuthUserCreateInput, BetterAuthUserUncheckedCreateInput>
  }

  /**
   * BetterAuthUser createMany
   */
  export type BetterAuthUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetterAuthUsers.
     */
    data: BetterAuthUserCreateManyInput | BetterAuthUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetterAuthUser createManyAndReturn
   */
  export type BetterAuthUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * The data used to create many BetterAuthUsers.
     */
    data: BetterAuthUserCreateManyInput | BetterAuthUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetterAuthUser update
   */
  export type BetterAuthUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BetterAuthUser.
     */
    data: XOR<BetterAuthUserUpdateInput, BetterAuthUserUncheckedUpdateInput>
    /**
     * Choose, which BetterAuthUser to update.
     */
    where: BetterAuthUserWhereUniqueInput
  }

  /**
   * BetterAuthUser updateMany
   */
  export type BetterAuthUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetterAuthUsers.
     */
    data: XOR<BetterAuthUserUpdateManyMutationInput, BetterAuthUserUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthUsers to update
     */
    where?: BetterAuthUserWhereInput
    /**
     * Limit how many BetterAuthUsers to update.
     */
    limit?: number
  }

  /**
   * BetterAuthUser updateManyAndReturn
   */
  export type BetterAuthUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * The data used to update BetterAuthUsers.
     */
    data: XOR<BetterAuthUserUpdateManyMutationInput, BetterAuthUserUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthUsers to update
     */
    where?: BetterAuthUserWhereInput
    /**
     * Limit how many BetterAuthUsers to update.
     */
    limit?: number
  }

  /**
   * BetterAuthUser upsert
   */
  export type BetterAuthUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BetterAuthUser to update in case it exists.
     */
    where: BetterAuthUserWhereUniqueInput
    /**
     * In case the BetterAuthUser found by the `where` argument doesn't exist, create a new BetterAuthUser with this data.
     */
    create: XOR<BetterAuthUserCreateInput, BetterAuthUserUncheckedCreateInput>
    /**
     * In case the BetterAuthUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetterAuthUserUpdateInput, BetterAuthUserUncheckedUpdateInput>
  }

  /**
   * BetterAuthUser delete
   */
  export type BetterAuthUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    /**
     * Filter which BetterAuthUser to delete.
     */
    where: BetterAuthUserWhereUniqueInput
  }

  /**
   * BetterAuthUser deleteMany
   */
  export type BetterAuthUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthUsers to delete
     */
    where?: BetterAuthUserWhereInput
    /**
     * Limit how many BetterAuthUsers to delete.
     */
    limit?: number
  }

  /**
   * BetterAuthUser.sessions
   */
  export type BetterAuthUser$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    where?: BetterAuthSessionWhereInput
    orderBy?: BetterAuthSessionOrderByWithRelationInput | BetterAuthSessionOrderByWithRelationInput[]
    cursor?: BetterAuthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetterAuthSessionScalarFieldEnum | BetterAuthSessionScalarFieldEnum[]
  }

  /**
   * BetterAuthUser.accounts
   */
  export type BetterAuthUser$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    where?: BetterAuthAccountWhereInput
    orderBy?: BetterAuthAccountOrderByWithRelationInput | BetterAuthAccountOrderByWithRelationInput[]
    cursor?: BetterAuthAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetterAuthAccountScalarFieldEnum | BetterAuthAccountScalarFieldEnum[]
  }

  /**
   * BetterAuthUser.verifications
   */
  export type BetterAuthUser$verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    where?: BetterAuthVerificationWhereInput
    orderBy?: BetterAuthVerificationOrderByWithRelationInput | BetterAuthVerificationOrderByWithRelationInput[]
    cursor?: BetterAuthVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BetterAuthVerificationScalarFieldEnum | BetterAuthVerificationScalarFieldEnum[]
  }

  /**
   * BetterAuthUser without action
   */
  export type BetterAuthUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
  }


  /**
   * Model BetterAuthSession
   */

  export type AggregateBetterAuthSession = {
    _count: BetterAuthSessionCountAggregateOutputType | null
    _min: BetterAuthSessionMinAggregateOutputType | null
    _max: BetterAuthSessionMaxAggregateOutputType | null
  }

  export type BetterAuthSessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetterAuthSessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetterAuthSessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    ipAddress: number
    userAgent: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BetterAuthSessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetterAuthSessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetterAuthSessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BetterAuthSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthSession to aggregate.
     */
    where?: BetterAuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthSessions to fetch.
     */
    orderBy?: BetterAuthSessionOrderByWithRelationInput | BetterAuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetterAuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetterAuthSessions
    **/
    _count?: true | BetterAuthSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetterAuthSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetterAuthSessionMaxAggregateInputType
  }

  export type GetBetterAuthSessionAggregateType<T extends BetterAuthSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBetterAuthSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetterAuthSession[P]>
      : GetScalarType<T[P], AggregateBetterAuthSession[P]>
  }




  export type BetterAuthSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthSessionWhereInput
    orderBy?: BetterAuthSessionOrderByWithAggregationInput | BetterAuthSessionOrderByWithAggregationInput[]
    by: BetterAuthSessionScalarFieldEnum[] | BetterAuthSessionScalarFieldEnum
    having?: BetterAuthSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetterAuthSessionCountAggregateInputType | true
    _min?: BetterAuthSessionMinAggregateInputType
    _max?: BetterAuthSessionMaxAggregateInputType
  }

  export type BetterAuthSessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    ipAddress: string | null
    userAgent: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: BetterAuthSessionCountAggregateOutputType | null
    _min: BetterAuthSessionMinAggregateOutputType | null
    _max: BetterAuthSessionMaxAggregateOutputType | null
  }

  type GetBetterAuthSessionGroupByPayload<T extends BetterAuthSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetterAuthSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetterAuthSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetterAuthSessionGroupByOutputType[P]>
            : GetScalarType<T[P], BetterAuthSessionGroupByOutputType[P]>
        }
      >
    >


  export type BetterAuthSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthSession"]>

  export type BetterAuthSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthSession"]>

  export type BetterAuthSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthSession"]>

  export type BetterAuthSessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BetterAuthSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "ipAddress" | "userAgent" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["betterAuthSession"]>
  export type BetterAuthSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }
  export type BetterAuthSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }
  export type BetterAuthSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }

  export type $BetterAuthSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetterAuthSession"
    objects: {
      user: Prisma.$BetterAuthUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      ipAddress: string | null
      userAgent: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["betterAuthSession"]>
    composites: {}
  }

  type BetterAuthSessionGetPayload<S extends boolean | null | undefined | BetterAuthSessionDefaultArgs> = $Result.GetResult<Prisma.$BetterAuthSessionPayload, S>

  type BetterAuthSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetterAuthSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetterAuthSessionCountAggregateInputType | true
    }

  export interface BetterAuthSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetterAuthSession'], meta: { name: 'BetterAuthSession' } }
    /**
     * Find zero or one BetterAuthSession that matches the filter.
     * @param {BetterAuthSessionFindUniqueArgs} args - Arguments to find a BetterAuthSession
     * @example
     * // Get one BetterAuthSession
     * const betterAuthSession = await prisma.betterAuthSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetterAuthSessionFindUniqueArgs>(args: SelectSubset<T, BetterAuthSessionFindUniqueArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetterAuthSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetterAuthSessionFindUniqueOrThrowArgs} args - Arguments to find a BetterAuthSession
     * @example
     * // Get one BetterAuthSession
     * const betterAuthSession = await prisma.betterAuthSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetterAuthSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, BetterAuthSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionFindFirstArgs} args - Arguments to find a BetterAuthSession
     * @example
     * // Get one BetterAuthSession
     * const betterAuthSession = await prisma.betterAuthSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetterAuthSessionFindFirstArgs>(args?: SelectSubset<T, BetterAuthSessionFindFirstArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionFindFirstOrThrowArgs} args - Arguments to find a BetterAuthSession
     * @example
     * // Get one BetterAuthSession
     * const betterAuthSession = await prisma.betterAuthSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetterAuthSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, BetterAuthSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetterAuthSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetterAuthSessions
     * const betterAuthSessions = await prisma.betterAuthSession.findMany()
     * 
     * // Get first 10 BetterAuthSessions
     * const betterAuthSessions = await prisma.betterAuthSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betterAuthSessionWithIdOnly = await prisma.betterAuthSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetterAuthSessionFindManyArgs>(args?: SelectSubset<T, BetterAuthSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetterAuthSession.
     * @param {BetterAuthSessionCreateArgs} args - Arguments to create a BetterAuthSession.
     * @example
     * // Create one BetterAuthSession
     * const BetterAuthSession = await prisma.betterAuthSession.create({
     *   data: {
     *     // ... data to create a BetterAuthSession
     *   }
     * })
     * 
     */
    create<T extends BetterAuthSessionCreateArgs>(args: SelectSubset<T, BetterAuthSessionCreateArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetterAuthSessions.
     * @param {BetterAuthSessionCreateManyArgs} args - Arguments to create many BetterAuthSessions.
     * @example
     * // Create many BetterAuthSessions
     * const betterAuthSession = await prisma.betterAuthSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetterAuthSessionCreateManyArgs>(args?: SelectSubset<T, BetterAuthSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetterAuthSessions and returns the data saved in the database.
     * @param {BetterAuthSessionCreateManyAndReturnArgs} args - Arguments to create many BetterAuthSessions.
     * @example
     * // Create many BetterAuthSessions
     * const betterAuthSession = await prisma.betterAuthSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetterAuthSessions and only return the `id`
     * const betterAuthSessionWithIdOnly = await prisma.betterAuthSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetterAuthSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, BetterAuthSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetterAuthSession.
     * @param {BetterAuthSessionDeleteArgs} args - Arguments to delete one BetterAuthSession.
     * @example
     * // Delete one BetterAuthSession
     * const BetterAuthSession = await prisma.betterAuthSession.delete({
     *   where: {
     *     // ... filter to delete one BetterAuthSession
     *   }
     * })
     * 
     */
    delete<T extends BetterAuthSessionDeleteArgs>(args: SelectSubset<T, BetterAuthSessionDeleteArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetterAuthSession.
     * @param {BetterAuthSessionUpdateArgs} args - Arguments to update one BetterAuthSession.
     * @example
     * // Update one BetterAuthSession
     * const betterAuthSession = await prisma.betterAuthSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetterAuthSessionUpdateArgs>(args: SelectSubset<T, BetterAuthSessionUpdateArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetterAuthSessions.
     * @param {BetterAuthSessionDeleteManyArgs} args - Arguments to filter BetterAuthSessions to delete.
     * @example
     * // Delete a few BetterAuthSessions
     * const { count } = await prisma.betterAuthSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetterAuthSessionDeleteManyArgs>(args?: SelectSubset<T, BetterAuthSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetterAuthSessions
     * const betterAuthSession = await prisma.betterAuthSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetterAuthSessionUpdateManyArgs>(args: SelectSubset<T, BetterAuthSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthSessions and returns the data updated in the database.
     * @param {BetterAuthSessionUpdateManyAndReturnArgs} args - Arguments to update many BetterAuthSessions.
     * @example
     * // Update many BetterAuthSessions
     * const betterAuthSession = await prisma.betterAuthSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetterAuthSessions and only return the `id`
     * const betterAuthSessionWithIdOnly = await prisma.betterAuthSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetterAuthSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, BetterAuthSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetterAuthSession.
     * @param {BetterAuthSessionUpsertArgs} args - Arguments to update or create a BetterAuthSession.
     * @example
     * // Update or create a BetterAuthSession
     * const betterAuthSession = await prisma.betterAuthSession.upsert({
     *   create: {
     *     // ... data to create a BetterAuthSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetterAuthSession we want to update
     *   }
     * })
     */
    upsert<T extends BetterAuthSessionUpsertArgs>(args: SelectSubset<T, BetterAuthSessionUpsertArgs<ExtArgs>>): Prisma__BetterAuthSessionClient<$Result.GetResult<Prisma.$BetterAuthSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetterAuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionCountArgs} args - Arguments to filter BetterAuthSessions to count.
     * @example
     * // Count the number of BetterAuthSessions
     * const count = await prisma.betterAuthSession.count({
     *   where: {
     *     // ... the filter for the BetterAuthSessions we want to count
     *   }
     * })
    **/
    count<T extends BetterAuthSessionCountArgs>(
      args?: Subset<T, BetterAuthSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetterAuthSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetterAuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetterAuthSessionAggregateArgs>(args: Subset<T, BetterAuthSessionAggregateArgs>): Prisma.PrismaPromise<GetBetterAuthSessionAggregateType<T>>

    /**
     * Group by BetterAuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetterAuthSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetterAuthSessionGroupByArgs['orderBy'] }
        : { orderBy?: BetterAuthSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetterAuthSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetterAuthSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetterAuthSession model
   */
  readonly fields: BetterAuthSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetterAuthSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetterAuthSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BetterAuthUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetterAuthUserDefaultArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetterAuthSession model
   */
  interface BetterAuthSessionFieldRefs {
    readonly id: FieldRef<"BetterAuthSession", 'String'>
    readonly expiresAt: FieldRef<"BetterAuthSession", 'DateTime'>
    readonly token: FieldRef<"BetterAuthSession", 'String'>
    readonly ipAddress: FieldRef<"BetterAuthSession", 'String'>
    readonly userAgent: FieldRef<"BetterAuthSession", 'String'>
    readonly userId: FieldRef<"BetterAuthSession", 'String'>
    readonly createdAt: FieldRef<"BetterAuthSession", 'DateTime'>
    readonly updatedAt: FieldRef<"BetterAuthSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetterAuthSession findUnique
   */
  export type BetterAuthSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthSession to fetch.
     */
    where: BetterAuthSessionWhereUniqueInput
  }

  /**
   * BetterAuthSession findUniqueOrThrow
   */
  export type BetterAuthSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthSession to fetch.
     */
    where: BetterAuthSessionWhereUniqueInput
  }

  /**
   * BetterAuthSession findFirst
   */
  export type BetterAuthSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthSession to fetch.
     */
    where?: BetterAuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthSessions to fetch.
     */
    orderBy?: BetterAuthSessionOrderByWithRelationInput | BetterAuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthSessions.
     */
    cursor?: BetterAuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthSessions.
     */
    distinct?: BetterAuthSessionScalarFieldEnum | BetterAuthSessionScalarFieldEnum[]
  }

  /**
   * BetterAuthSession findFirstOrThrow
   */
  export type BetterAuthSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthSession to fetch.
     */
    where?: BetterAuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthSessions to fetch.
     */
    orderBy?: BetterAuthSessionOrderByWithRelationInput | BetterAuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthSessions.
     */
    cursor?: BetterAuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthSessions.
     */
    distinct?: BetterAuthSessionScalarFieldEnum | BetterAuthSessionScalarFieldEnum[]
  }

  /**
   * BetterAuthSession findMany
   */
  export type BetterAuthSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthSessions to fetch.
     */
    where?: BetterAuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthSessions to fetch.
     */
    orderBy?: BetterAuthSessionOrderByWithRelationInput | BetterAuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetterAuthSessions.
     */
    cursor?: BetterAuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthSessions.
     */
    skip?: number
    distinct?: BetterAuthSessionScalarFieldEnum | BetterAuthSessionScalarFieldEnum[]
  }

  /**
   * BetterAuthSession create
   */
  export type BetterAuthSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a BetterAuthSession.
     */
    data: XOR<BetterAuthSessionCreateInput, BetterAuthSessionUncheckedCreateInput>
  }

  /**
   * BetterAuthSession createMany
   */
  export type BetterAuthSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetterAuthSessions.
     */
    data: BetterAuthSessionCreateManyInput | BetterAuthSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetterAuthSession createManyAndReturn
   */
  export type BetterAuthSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * The data used to create many BetterAuthSessions.
     */
    data: BetterAuthSessionCreateManyInput | BetterAuthSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetterAuthSession update
   */
  export type BetterAuthSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a BetterAuthSession.
     */
    data: XOR<BetterAuthSessionUpdateInput, BetterAuthSessionUncheckedUpdateInput>
    /**
     * Choose, which BetterAuthSession to update.
     */
    where: BetterAuthSessionWhereUniqueInput
  }

  /**
   * BetterAuthSession updateMany
   */
  export type BetterAuthSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetterAuthSessions.
     */
    data: XOR<BetterAuthSessionUpdateManyMutationInput, BetterAuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthSessions to update
     */
    where?: BetterAuthSessionWhereInput
    /**
     * Limit how many BetterAuthSessions to update.
     */
    limit?: number
  }

  /**
   * BetterAuthSession updateManyAndReturn
   */
  export type BetterAuthSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * The data used to update BetterAuthSessions.
     */
    data: XOR<BetterAuthSessionUpdateManyMutationInput, BetterAuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthSessions to update
     */
    where?: BetterAuthSessionWhereInput
    /**
     * Limit how many BetterAuthSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetterAuthSession upsert
   */
  export type BetterAuthSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the BetterAuthSession to update in case it exists.
     */
    where: BetterAuthSessionWhereUniqueInput
    /**
     * In case the BetterAuthSession found by the `where` argument doesn't exist, create a new BetterAuthSession with this data.
     */
    create: XOR<BetterAuthSessionCreateInput, BetterAuthSessionUncheckedCreateInput>
    /**
     * In case the BetterAuthSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetterAuthSessionUpdateInput, BetterAuthSessionUncheckedUpdateInput>
  }

  /**
   * BetterAuthSession delete
   */
  export type BetterAuthSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
    /**
     * Filter which BetterAuthSession to delete.
     */
    where: BetterAuthSessionWhereUniqueInput
  }

  /**
   * BetterAuthSession deleteMany
   */
  export type BetterAuthSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthSessions to delete
     */
    where?: BetterAuthSessionWhereInput
    /**
     * Limit how many BetterAuthSessions to delete.
     */
    limit?: number
  }

  /**
   * BetterAuthSession without action
   */
  export type BetterAuthSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthSession
     */
    select?: BetterAuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthSession
     */
    omit?: BetterAuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthSessionInclude<ExtArgs> | null
  }


  /**
   * Model BetterAuthAccount
   */

  export type AggregateBetterAuthAccount = {
    _count: BetterAuthAccountCountAggregateOutputType | null
    _min: BetterAuthAccountMinAggregateOutputType | null
    _max: BetterAuthAccountMaxAggregateOutputType | null
  }

  export type BetterAuthAccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetterAuthAccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BetterAuthAccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BetterAuthAccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetterAuthAccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BetterAuthAccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BetterAuthAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthAccount to aggregate.
     */
    where?: BetterAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthAccounts to fetch.
     */
    orderBy?: BetterAuthAccountOrderByWithRelationInput | BetterAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetterAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetterAuthAccounts
    **/
    _count?: true | BetterAuthAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetterAuthAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetterAuthAccountMaxAggregateInputType
  }

  export type GetBetterAuthAccountAggregateType<T extends BetterAuthAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBetterAuthAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetterAuthAccount[P]>
      : GetScalarType<T[P], AggregateBetterAuthAccount[P]>
  }




  export type BetterAuthAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthAccountWhereInput
    orderBy?: BetterAuthAccountOrderByWithAggregationInput | BetterAuthAccountOrderByWithAggregationInput[]
    by: BetterAuthAccountScalarFieldEnum[] | BetterAuthAccountScalarFieldEnum
    having?: BetterAuthAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetterAuthAccountCountAggregateInputType | true
    _min?: BetterAuthAccountMinAggregateInputType
    _max?: BetterAuthAccountMaxAggregateInputType
  }

  export type BetterAuthAccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: BetterAuthAccountCountAggregateOutputType | null
    _min: BetterAuthAccountMinAggregateOutputType | null
    _max: BetterAuthAccountMaxAggregateOutputType | null
  }

  type GetBetterAuthAccountGroupByPayload<T extends BetterAuthAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetterAuthAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetterAuthAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetterAuthAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BetterAuthAccountGroupByOutputType[P]>
        }
      >
    >


  export type BetterAuthAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthAccount"]>

  export type BetterAuthAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthAccount"]>

  export type BetterAuthAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthAccount"]>

  export type BetterAuthAccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BetterAuthAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["betterAuthAccount"]>
  export type BetterAuthAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }
  export type BetterAuthAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }
  export type BetterAuthAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthUserDefaultArgs<ExtArgs>
  }

  export type $BetterAuthAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetterAuthAccount"
    objects: {
      user: Prisma.$BetterAuthUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["betterAuthAccount"]>
    composites: {}
  }

  type BetterAuthAccountGetPayload<S extends boolean | null | undefined | BetterAuthAccountDefaultArgs> = $Result.GetResult<Prisma.$BetterAuthAccountPayload, S>

  type BetterAuthAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetterAuthAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetterAuthAccountCountAggregateInputType | true
    }

  export interface BetterAuthAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetterAuthAccount'], meta: { name: 'BetterAuthAccount' } }
    /**
     * Find zero or one BetterAuthAccount that matches the filter.
     * @param {BetterAuthAccountFindUniqueArgs} args - Arguments to find a BetterAuthAccount
     * @example
     * // Get one BetterAuthAccount
     * const betterAuthAccount = await prisma.betterAuthAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetterAuthAccountFindUniqueArgs>(args: SelectSubset<T, BetterAuthAccountFindUniqueArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetterAuthAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetterAuthAccountFindUniqueOrThrowArgs} args - Arguments to find a BetterAuthAccount
     * @example
     * // Get one BetterAuthAccount
     * const betterAuthAccount = await prisma.betterAuthAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetterAuthAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BetterAuthAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountFindFirstArgs} args - Arguments to find a BetterAuthAccount
     * @example
     * // Get one BetterAuthAccount
     * const betterAuthAccount = await prisma.betterAuthAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetterAuthAccountFindFirstArgs>(args?: SelectSubset<T, BetterAuthAccountFindFirstArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountFindFirstOrThrowArgs} args - Arguments to find a BetterAuthAccount
     * @example
     * // Get one BetterAuthAccount
     * const betterAuthAccount = await prisma.betterAuthAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetterAuthAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BetterAuthAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetterAuthAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetterAuthAccounts
     * const betterAuthAccounts = await prisma.betterAuthAccount.findMany()
     * 
     * // Get first 10 BetterAuthAccounts
     * const betterAuthAccounts = await prisma.betterAuthAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betterAuthAccountWithIdOnly = await prisma.betterAuthAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetterAuthAccountFindManyArgs>(args?: SelectSubset<T, BetterAuthAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetterAuthAccount.
     * @param {BetterAuthAccountCreateArgs} args - Arguments to create a BetterAuthAccount.
     * @example
     * // Create one BetterAuthAccount
     * const BetterAuthAccount = await prisma.betterAuthAccount.create({
     *   data: {
     *     // ... data to create a BetterAuthAccount
     *   }
     * })
     * 
     */
    create<T extends BetterAuthAccountCreateArgs>(args: SelectSubset<T, BetterAuthAccountCreateArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetterAuthAccounts.
     * @param {BetterAuthAccountCreateManyArgs} args - Arguments to create many BetterAuthAccounts.
     * @example
     * // Create many BetterAuthAccounts
     * const betterAuthAccount = await prisma.betterAuthAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetterAuthAccountCreateManyArgs>(args?: SelectSubset<T, BetterAuthAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetterAuthAccounts and returns the data saved in the database.
     * @param {BetterAuthAccountCreateManyAndReturnArgs} args - Arguments to create many BetterAuthAccounts.
     * @example
     * // Create many BetterAuthAccounts
     * const betterAuthAccount = await prisma.betterAuthAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetterAuthAccounts and only return the `id`
     * const betterAuthAccountWithIdOnly = await prisma.betterAuthAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetterAuthAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BetterAuthAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetterAuthAccount.
     * @param {BetterAuthAccountDeleteArgs} args - Arguments to delete one BetterAuthAccount.
     * @example
     * // Delete one BetterAuthAccount
     * const BetterAuthAccount = await prisma.betterAuthAccount.delete({
     *   where: {
     *     // ... filter to delete one BetterAuthAccount
     *   }
     * })
     * 
     */
    delete<T extends BetterAuthAccountDeleteArgs>(args: SelectSubset<T, BetterAuthAccountDeleteArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetterAuthAccount.
     * @param {BetterAuthAccountUpdateArgs} args - Arguments to update one BetterAuthAccount.
     * @example
     * // Update one BetterAuthAccount
     * const betterAuthAccount = await prisma.betterAuthAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetterAuthAccountUpdateArgs>(args: SelectSubset<T, BetterAuthAccountUpdateArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetterAuthAccounts.
     * @param {BetterAuthAccountDeleteManyArgs} args - Arguments to filter BetterAuthAccounts to delete.
     * @example
     * // Delete a few BetterAuthAccounts
     * const { count } = await prisma.betterAuthAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetterAuthAccountDeleteManyArgs>(args?: SelectSubset<T, BetterAuthAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetterAuthAccounts
     * const betterAuthAccount = await prisma.betterAuthAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetterAuthAccountUpdateManyArgs>(args: SelectSubset<T, BetterAuthAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthAccounts and returns the data updated in the database.
     * @param {BetterAuthAccountUpdateManyAndReturnArgs} args - Arguments to update many BetterAuthAccounts.
     * @example
     * // Update many BetterAuthAccounts
     * const betterAuthAccount = await prisma.betterAuthAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetterAuthAccounts and only return the `id`
     * const betterAuthAccountWithIdOnly = await prisma.betterAuthAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetterAuthAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BetterAuthAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetterAuthAccount.
     * @param {BetterAuthAccountUpsertArgs} args - Arguments to update or create a BetterAuthAccount.
     * @example
     * // Update or create a BetterAuthAccount
     * const betterAuthAccount = await prisma.betterAuthAccount.upsert({
     *   create: {
     *     // ... data to create a BetterAuthAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetterAuthAccount we want to update
     *   }
     * })
     */
    upsert<T extends BetterAuthAccountUpsertArgs>(args: SelectSubset<T, BetterAuthAccountUpsertArgs<ExtArgs>>): Prisma__BetterAuthAccountClient<$Result.GetResult<Prisma.$BetterAuthAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetterAuthAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountCountArgs} args - Arguments to filter BetterAuthAccounts to count.
     * @example
     * // Count the number of BetterAuthAccounts
     * const count = await prisma.betterAuthAccount.count({
     *   where: {
     *     // ... the filter for the BetterAuthAccounts we want to count
     *   }
     * })
    **/
    count<T extends BetterAuthAccountCountArgs>(
      args?: Subset<T, BetterAuthAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetterAuthAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetterAuthAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetterAuthAccountAggregateArgs>(args: Subset<T, BetterAuthAccountAggregateArgs>): Prisma.PrismaPromise<GetBetterAuthAccountAggregateType<T>>

    /**
     * Group by BetterAuthAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetterAuthAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetterAuthAccountGroupByArgs['orderBy'] }
        : { orderBy?: BetterAuthAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetterAuthAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetterAuthAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetterAuthAccount model
   */
  readonly fields: BetterAuthAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetterAuthAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetterAuthAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BetterAuthUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BetterAuthUserDefaultArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetterAuthAccount model
   */
  interface BetterAuthAccountFieldRefs {
    readonly id: FieldRef<"BetterAuthAccount", 'String'>
    readonly accountId: FieldRef<"BetterAuthAccount", 'String'>
    readonly providerId: FieldRef<"BetterAuthAccount", 'String'>
    readonly userId: FieldRef<"BetterAuthAccount", 'String'>
    readonly accessToken: FieldRef<"BetterAuthAccount", 'String'>
    readonly refreshToken: FieldRef<"BetterAuthAccount", 'String'>
    readonly idToken: FieldRef<"BetterAuthAccount", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"BetterAuthAccount", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"BetterAuthAccount", 'DateTime'>
    readonly scope: FieldRef<"BetterAuthAccount", 'String'>
    readonly password: FieldRef<"BetterAuthAccount", 'String'>
    readonly createdAt: FieldRef<"BetterAuthAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BetterAuthAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetterAuthAccount findUnique
   */
  export type BetterAuthAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthAccount to fetch.
     */
    where: BetterAuthAccountWhereUniqueInput
  }

  /**
   * BetterAuthAccount findUniqueOrThrow
   */
  export type BetterAuthAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthAccount to fetch.
     */
    where: BetterAuthAccountWhereUniqueInput
  }

  /**
   * BetterAuthAccount findFirst
   */
  export type BetterAuthAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthAccount to fetch.
     */
    where?: BetterAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthAccounts to fetch.
     */
    orderBy?: BetterAuthAccountOrderByWithRelationInput | BetterAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthAccounts.
     */
    cursor?: BetterAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthAccounts.
     */
    distinct?: BetterAuthAccountScalarFieldEnum | BetterAuthAccountScalarFieldEnum[]
  }

  /**
   * BetterAuthAccount findFirstOrThrow
   */
  export type BetterAuthAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthAccount to fetch.
     */
    where?: BetterAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthAccounts to fetch.
     */
    orderBy?: BetterAuthAccountOrderByWithRelationInput | BetterAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthAccounts.
     */
    cursor?: BetterAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthAccounts.
     */
    distinct?: BetterAuthAccountScalarFieldEnum | BetterAuthAccountScalarFieldEnum[]
  }

  /**
   * BetterAuthAccount findMany
   */
  export type BetterAuthAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthAccounts to fetch.
     */
    where?: BetterAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthAccounts to fetch.
     */
    orderBy?: BetterAuthAccountOrderByWithRelationInput | BetterAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetterAuthAccounts.
     */
    cursor?: BetterAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthAccounts.
     */
    skip?: number
    distinct?: BetterAuthAccountScalarFieldEnum | BetterAuthAccountScalarFieldEnum[]
  }

  /**
   * BetterAuthAccount create
   */
  export type BetterAuthAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BetterAuthAccount.
     */
    data: XOR<BetterAuthAccountCreateInput, BetterAuthAccountUncheckedCreateInput>
  }

  /**
   * BetterAuthAccount createMany
   */
  export type BetterAuthAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetterAuthAccounts.
     */
    data: BetterAuthAccountCreateManyInput | BetterAuthAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetterAuthAccount createManyAndReturn
   */
  export type BetterAuthAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BetterAuthAccounts.
     */
    data: BetterAuthAccountCreateManyInput | BetterAuthAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetterAuthAccount update
   */
  export type BetterAuthAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BetterAuthAccount.
     */
    data: XOR<BetterAuthAccountUpdateInput, BetterAuthAccountUncheckedUpdateInput>
    /**
     * Choose, which BetterAuthAccount to update.
     */
    where: BetterAuthAccountWhereUniqueInput
  }

  /**
   * BetterAuthAccount updateMany
   */
  export type BetterAuthAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetterAuthAccounts.
     */
    data: XOR<BetterAuthAccountUpdateManyMutationInput, BetterAuthAccountUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthAccounts to update
     */
    where?: BetterAuthAccountWhereInput
    /**
     * Limit how many BetterAuthAccounts to update.
     */
    limit?: number
  }

  /**
   * BetterAuthAccount updateManyAndReturn
   */
  export type BetterAuthAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * The data used to update BetterAuthAccounts.
     */
    data: XOR<BetterAuthAccountUpdateManyMutationInput, BetterAuthAccountUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthAccounts to update
     */
    where?: BetterAuthAccountWhereInput
    /**
     * Limit how many BetterAuthAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetterAuthAccount upsert
   */
  export type BetterAuthAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BetterAuthAccount to update in case it exists.
     */
    where: BetterAuthAccountWhereUniqueInput
    /**
     * In case the BetterAuthAccount found by the `where` argument doesn't exist, create a new BetterAuthAccount with this data.
     */
    create: XOR<BetterAuthAccountCreateInput, BetterAuthAccountUncheckedCreateInput>
    /**
     * In case the BetterAuthAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetterAuthAccountUpdateInput, BetterAuthAccountUncheckedUpdateInput>
  }

  /**
   * BetterAuthAccount delete
   */
  export type BetterAuthAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
    /**
     * Filter which BetterAuthAccount to delete.
     */
    where: BetterAuthAccountWhereUniqueInput
  }

  /**
   * BetterAuthAccount deleteMany
   */
  export type BetterAuthAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthAccounts to delete
     */
    where?: BetterAuthAccountWhereInput
    /**
     * Limit how many BetterAuthAccounts to delete.
     */
    limit?: number
  }

  /**
   * BetterAuthAccount without action
   */
  export type BetterAuthAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthAccount
     */
    select?: BetterAuthAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthAccount
     */
    omit?: BetterAuthAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthAccountInclude<ExtArgs> | null
  }


  /**
   * Model BetterAuthVerification
   */

  export type AggregateBetterAuthVerification = {
    _count: BetterAuthVerificationCountAggregateOutputType | null
    _min: BetterAuthVerificationMinAggregateOutputType | null
    _max: BetterAuthVerificationMaxAggregateOutputType | null
  }

  export type BetterAuthVerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type BetterAuthVerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type BetterAuthVerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type BetterAuthVerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type BetterAuthVerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type BetterAuthVerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type BetterAuthVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthVerification to aggregate.
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthVerifications to fetch.
     */
    orderBy?: BetterAuthVerificationOrderByWithRelationInput | BetterAuthVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetterAuthVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetterAuthVerifications
    **/
    _count?: true | BetterAuthVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetterAuthVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetterAuthVerificationMaxAggregateInputType
  }

  export type GetBetterAuthVerificationAggregateType<T extends BetterAuthVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateBetterAuthVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetterAuthVerification[P]>
      : GetScalarType<T[P], AggregateBetterAuthVerification[P]>
  }




  export type BetterAuthVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetterAuthVerificationWhereInput
    orderBy?: BetterAuthVerificationOrderByWithAggregationInput | BetterAuthVerificationOrderByWithAggregationInput[]
    by: BetterAuthVerificationScalarFieldEnum[] | BetterAuthVerificationScalarFieldEnum
    having?: BetterAuthVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetterAuthVerificationCountAggregateInputType | true
    _min?: BetterAuthVerificationMinAggregateInputType
    _max?: BetterAuthVerificationMaxAggregateInputType
  }

  export type BetterAuthVerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: BetterAuthVerificationCountAggregateOutputType | null
    _min: BetterAuthVerificationMinAggregateOutputType | null
    _max: BetterAuthVerificationMaxAggregateOutputType | null
  }

  type GetBetterAuthVerificationGroupByPayload<T extends BetterAuthVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetterAuthVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetterAuthVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetterAuthVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], BetterAuthVerificationGroupByOutputType[P]>
        }
      >
    >


  export type BetterAuthVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | BetterAuthVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthVerification"]>

  export type BetterAuthVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | BetterAuthVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthVerification"]>

  export type BetterAuthVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | BetterAuthVerification$userArgs<ExtArgs>
  }, ExtArgs["result"]["betterAuthVerification"]>

  export type BetterAuthVerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type BetterAuthVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["betterAuthVerification"]>
  export type BetterAuthVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthVerification$userArgs<ExtArgs>
  }
  export type BetterAuthVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthVerification$userArgs<ExtArgs>
  }
  export type BetterAuthVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | BetterAuthVerification$userArgs<ExtArgs>
  }

  export type $BetterAuthVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetterAuthVerification"
    objects: {
      user: Prisma.$BetterAuthUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["betterAuthVerification"]>
    composites: {}
  }

  type BetterAuthVerificationGetPayload<S extends boolean | null | undefined | BetterAuthVerificationDefaultArgs> = $Result.GetResult<Prisma.$BetterAuthVerificationPayload, S>

  type BetterAuthVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BetterAuthVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BetterAuthVerificationCountAggregateInputType | true
    }

  export interface BetterAuthVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetterAuthVerification'], meta: { name: 'BetterAuthVerification' } }
    /**
     * Find zero or one BetterAuthVerification that matches the filter.
     * @param {BetterAuthVerificationFindUniqueArgs} args - Arguments to find a BetterAuthVerification
     * @example
     * // Get one BetterAuthVerification
     * const betterAuthVerification = await prisma.betterAuthVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetterAuthVerificationFindUniqueArgs>(args: SelectSubset<T, BetterAuthVerificationFindUniqueArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BetterAuthVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BetterAuthVerificationFindUniqueOrThrowArgs} args - Arguments to find a BetterAuthVerification
     * @example
     * // Get one BetterAuthVerification
     * const betterAuthVerification = await prisma.betterAuthVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetterAuthVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, BetterAuthVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationFindFirstArgs} args - Arguments to find a BetterAuthVerification
     * @example
     * // Get one BetterAuthVerification
     * const betterAuthVerification = await prisma.betterAuthVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetterAuthVerificationFindFirstArgs>(args?: SelectSubset<T, BetterAuthVerificationFindFirstArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BetterAuthVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationFindFirstOrThrowArgs} args - Arguments to find a BetterAuthVerification
     * @example
     * // Get one BetterAuthVerification
     * const betterAuthVerification = await prisma.betterAuthVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetterAuthVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, BetterAuthVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BetterAuthVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetterAuthVerifications
     * const betterAuthVerifications = await prisma.betterAuthVerification.findMany()
     * 
     * // Get first 10 BetterAuthVerifications
     * const betterAuthVerifications = await prisma.betterAuthVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betterAuthVerificationWithIdOnly = await prisma.betterAuthVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetterAuthVerificationFindManyArgs>(args?: SelectSubset<T, BetterAuthVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BetterAuthVerification.
     * @param {BetterAuthVerificationCreateArgs} args - Arguments to create a BetterAuthVerification.
     * @example
     * // Create one BetterAuthVerification
     * const BetterAuthVerification = await prisma.betterAuthVerification.create({
     *   data: {
     *     // ... data to create a BetterAuthVerification
     *   }
     * })
     * 
     */
    create<T extends BetterAuthVerificationCreateArgs>(args: SelectSubset<T, BetterAuthVerificationCreateArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BetterAuthVerifications.
     * @param {BetterAuthVerificationCreateManyArgs} args - Arguments to create many BetterAuthVerifications.
     * @example
     * // Create many BetterAuthVerifications
     * const betterAuthVerification = await prisma.betterAuthVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetterAuthVerificationCreateManyArgs>(args?: SelectSubset<T, BetterAuthVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetterAuthVerifications and returns the data saved in the database.
     * @param {BetterAuthVerificationCreateManyAndReturnArgs} args - Arguments to create many BetterAuthVerifications.
     * @example
     * // Create many BetterAuthVerifications
     * const betterAuthVerification = await prisma.betterAuthVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetterAuthVerifications and only return the `id`
     * const betterAuthVerificationWithIdOnly = await prisma.betterAuthVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetterAuthVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, BetterAuthVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BetterAuthVerification.
     * @param {BetterAuthVerificationDeleteArgs} args - Arguments to delete one BetterAuthVerification.
     * @example
     * // Delete one BetterAuthVerification
     * const BetterAuthVerification = await prisma.betterAuthVerification.delete({
     *   where: {
     *     // ... filter to delete one BetterAuthVerification
     *   }
     * })
     * 
     */
    delete<T extends BetterAuthVerificationDeleteArgs>(args: SelectSubset<T, BetterAuthVerificationDeleteArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BetterAuthVerification.
     * @param {BetterAuthVerificationUpdateArgs} args - Arguments to update one BetterAuthVerification.
     * @example
     * // Update one BetterAuthVerification
     * const betterAuthVerification = await prisma.betterAuthVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetterAuthVerificationUpdateArgs>(args: SelectSubset<T, BetterAuthVerificationUpdateArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BetterAuthVerifications.
     * @param {BetterAuthVerificationDeleteManyArgs} args - Arguments to filter BetterAuthVerifications to delete.
     * @example
     * // Delete a few BetterAuthVerifications
     * const { count } = await prisma.betterAuthVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetterAuthVerificationDeleteManyArgs>(args?: SelectSubset<T, BetterAuthVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetterAuthVerifications
     * const betterAuthVerification = await prisma.betterAuthVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetterAuthVerificationUpdateManyArgs>(args: SelectSubset<T, BetterAuthVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetterAuthVerifications and returns the data updated in the database.
     * @param {BetterAuthVerificationUpdateManyAndReturnArgs} args - Arguments to update many BetterAuthVerifications.
     * @example
     * // Update many BetterAuthVerifications
     * const betterAuthVerification = await prisma.betterAuthVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BetterAuthVerifications and only return the `id`
     * const betterAuthVerificationWithIdOnly = await prisma.betterAuthVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BetterAuthVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, BetterAuthVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BetterAuthVerification.
     * @param {BetterAuthVerificationUpsertArgs} args - Arguments to update or create a BetterAuthVerification.
     * @example
     * // Update or create a BetterAuthVerification
     * const betterAuthVerification = await prisma.betterAuthVerification.upsert({
     *   create: {
     *     // ... data to create a BetterAuthVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetterAuthVerification we want to update
     *   }
     * })
     */
    upsert<T extends BetterAuthVerificationUpsertArgs>(args: SelectSubset<T, BetterAuthVerificationUpsertArgs<ExtArgs>>): Prisma__BetterAuthVerificationClient<$Result.GetResult<Prisma.$BetterAuthVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BetterAuthVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationCountArgs} args - Arguments to filter BetterAuthVerifications to count.
     * @example
     * // Count the number of BetterAuthVerifications
     * const count = await prisma.betterAuthVerification.count({
     *   where: {
     *     // ... the filter for the BetterAuthVerifications we want to count
     *   }
     * })
    **/
    count<T extends BetterAuthVerificationCountArgs>(
      args?: Subset<T, BetterAuthVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetterAuthVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetterAuthVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetterAuthVerificationAggregateArgs>(args: Subset<T, BetterAuthVerificationAggregateArgs>): Prisma.PrismaPromise<GetBetterAuthVerificationAggregateType<T>>

    /**
     * Group by BetterAuthVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetterAuthVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetterAuthVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetterAuthVerificationGroupByArgs['orderBy'] }
        : { orderBy?: BetterAuthVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetterAuthVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetterAuthVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetterAuthVerification model
   */
  readonly fields: BetterAuthVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetterAuthVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetterAuthVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends BetterAuthVerification$userArgs<ExtArgs> = {}>(args?: Subset<T, BetterAuthVerification$userArgs<ExtArgs>>): Prisma__BetterAuthUserClient<$Result.GetResult<Prisma.$BetterAuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetterAuthVerification model
   */
  interface BetterAuthVerificationFieldRefs {
    readonly id: FieldRef<"BetterAuthVerification", 'String'>
    readonly identifier: FieldRef<"BetterAuthVerification", 'String'>
    readonly value: FieldRef<"BetterAuthVerification", 'String'>
    readonly expiresAt: FieldRef<"BetterAuthVerification", 'DateTime'>
    readonly createdAt: FieldRef<"BetterAuthVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"BetterAuthVerification", 'DateTime'>
    readonly userId: FieldRef<"BetterAuthVerification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BetterAuthVerification findUnique
   */
  export type BetterAuthVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthVerification to fetch.
     */
    where: BetterAuthVerificationWhereUniqueInput
  }

  /**
   * BetterAuthVerification findUniqueOrThrow
   */
  export type BetterAuthVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthVerification to fetch.
     */
    where: BetterAuthVerificationWhereUniqueInput
  }

  /**
   * BetterAuthVerification findFirst
   */
  export type BetterAuthVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthVerification to fetch.
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthVerifications to fetch.
     */
    orderBy?: BetterAuthVerificationOrderByWithRelationInput | BetterAuthVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthVerifications.
     */
    cursor?: BetterAuthVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthVerifications.
     */
    distinct?: BetterAuthVerificationScalarFieldEnum | BetterAuthVerificationScalarFieldEnum[]
  }

  /**
   * BetterAuthVerification findFirstOrThrow
   */
  export type BetterAuthVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthVerification to fetch.
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthVerifications to fetch.
     */
    orderBy?: BetterAuthVerificationOrderByWithRelationInput | BetterAuthVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetterAuthVerifications.
     */
    cursor?: BetterAuthVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetterAuthVerifications.
     */
    distinct?: BetterAuthVerificationScalarFieldEnum | BetterAuthVerificationScalarFieldEnum[]
  }

  /**
   * BetterAuthVerification findMany
   */
  export type BetterAuthVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * Filter, which BetterAuthVerifications to fetch.
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetterAuthVerifications to fetch.
     */
    orderBy?: BetterAuthVerificationOrderByWithRelationInput | BetterAuthVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetterAuthVerifications.
     */
    cursor?: BetterAuthVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetterAuthVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetterAuthVerifications.
     */
    skip?: number
    distinct?: BetterAuthVerificationScalarFieldEnum | BetterAuthVerificationScalarFieldEnum[]
  }

  /**
   * BetterAuthVerification create
   */
  export type BetterAuthVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a BetterAuthVerification.
     */
    data: XOR<BetterAuthVerificationCreateInput, BetterAuthVerificationUncheckedCreateInput>
  }

  /**
   * BetterAuthVerification createMany
   */
  export type BetterAuthVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetterAuthVerifications.
     */
    data: BetterAuthVerificationCreateManyInput | BetterAuthVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetterAuthVerification createManyAndReturn
   */
  export type BetterAuthVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many BetterAuthVerifications.
     */
    data: BetterAuthVerificationCreateManyInput | BetterAuthVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetterAuthVerification update
   */
  export type BetterAuthVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a BetterAuthVerification.
     */
    data: XOR<BetterAuthVerificationUpdateInput, BetterAuthVerificationUncheckedUpdateInput>
    /**
     * Choose, which BetterAuthVerification to update.
     */
    where: BetterAuthVerificationWhereUniqueInput
  }

  /**
   * BetterAuthVerification updateMany
   */
  export type BetterAuthVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetterAuthVerifications.
     */
    data: XOR<BetterAuthVerificationUpdateManyMutationInput, BetterAuthVerificationUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthVerifications to update
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * Limit how many BetterAuthVerifications to update.
     */
    limit?: number
  }

  /**
   * BetterAuthVerification updateManyAndReturn
   */
  export type BetterAuthVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * The data used to update BetterAuthVerifications.
     */
    data: XOR<BetterAuthVerificationUpdateManyMutationInput, BetterAuthVerificationUncheckedUpdateManyInput>
    /**
     * Filter which BetterAuthVerifications to update
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * Limit how many BetterAuthVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BetterAuthVerification upsert
   */
  export type BetterAuthVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the BetterAuthVerification to update in case it exists.
     */
    where: BetterAuthVerificationWhereUniqueInput
    /**
     * In case the BetterAuthVerification found by the `where` argument doesn't exist, create a new BetterAuthVerification with this data.
     */
    create: XOR<BetterAuthVerificationCreateInput, BetterAuthVerificationUncheckedCreateInput>
    /**
     * In case the BetterAuthVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetterAuthVerificationUpdateInput, BetterAuthVerificationUncheckedUpdateInput>
  }

  /**
   * BetterAuthVerification delete
   */
  export type BetterAuthVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
    /**
     * Filter which BetterAuthVerification to delete.
     */
    where: BetterAuthVerificationWhereUniqueInput
  }

  /**
   * BetterAuthVerification deleteMany
   */
  export type BetterAuthVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetterAuthVerifications to delete
     */
    where?: BetterAuthVerificationWhereInput
    /**
     * Limit how many BetterAuthVerifications to delete.
     */
    limit?: number
  }

  /**
   * BetterAuthVerification.user
   */
  export type BetterAuthVerification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthUser
     */
    select?: BetterAuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthUser
     */
    omit?: BetterAuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthUserInclude<ExtArgs> | null
    where?: BetterAuthUserWhereInput
  }

  /**
   * BetterAuthVerification without action
   */
  export type BetterAuthVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetterAuthVerification
     */
    select?: BetterAuthVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BetterAuthVerification
     */
    omit?: BetterAuthVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BetterAuthVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacultyMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | Faculty$departmentsArgs<ExtArgs>
    ikohzas?: boolean | Faculty$ikohzasArgs<ExtArgs>
    users?: boolean | Faculty$usersArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["faculty"]>
  export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Faculty$departmentsArgs<ExtArgs>
    ikohzas?: boolean | Faculty$ikohzasArgs<ExtArgs>
    users?: boolean | Faculty$usersArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FacultyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      ikohzas: Prisma.$IkohzaPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultyFindManyArgs>(args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends FacultyCreateArgs>(args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyCreateManyArgs>(args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Faculties and returns the data saved in the database.
     * @param {FacultyCreateManyAndReturnArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultyCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends FacultyDeleteArgs>(args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyUpdateArgs>(args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyDeleteManyArgs>(args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyUpdateManyArgs>(args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties and returns the data updated in the database.
     * @param {FacultyUpdateManyAndReturnArgs} args - Arguments to update many Faculties.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultyUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Faculty$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ikohzas<T extends Faculty$ikohzasArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$ikohzasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Faculty$usersArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faculty model
   */
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", 'String'>
    readonly code: FieldRef<"Faculty", 'String'>
    readonly name: FieldRef<"Faculty", 'String'>
    readonly isActive: FieldRef<"Faculty", 'Boolean'>
    readonly createdAt: FieldRef<"Faculty", 'DateTime'>
    readonly updatedAt: FieldRef<"Faculty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty createManyAndReturn
   */
  export type FacultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
  }

  /**
   * Faculty updateManyAndReturn
   */
  export type FacultyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
  }

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to delete.
     */
    limit?: number
  }

  /**
   * Faculty.departments
   */
  export type Faculty$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Faculty.ikohzas
   */
  export type Faculty$ikohzasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    where?: IkohzaWhereInput
    orderBy?: IkohzaOrderByWithRelationInput | IkohzaOrderByWithRelationInput[]
    cursor?: IkohzaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IkohzaScalarFieldEnum | IkohzaScalarFieldEnum[]
  }

  /**
   * Faculty.users
   */
  export type Faculty$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    facultyId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    facultyId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    facultyId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    facultyId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    facultyId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    facultyId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    facultyId: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facultyId" | "code" | "name" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      facultyId: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly facultyId: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Ikohza
   */

  export type AggregateIkohza = {
    _count: IkohzaCountAggregateOutputType | null
    _min: IkohzaMinAggregateOutputType | null
    _max: IkohzaMaxAggregateOutputType | null
  }

  export type IkohzaMinAggregateOutputType = {
    id: string | null
    facultyId: string | null
    code: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    leaderName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IkohzaMaxAggregateOutputType = {
    id: string | null
    facultyId: string | null
    code: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    leaderName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IkohzaCountAggregateOutputType = {
    id: number
    facultyId: number
    code: number
    name: number
    description: number
    isActive: number
    leaderName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IkohzaMinAggregateInputType = {
    id?: true
    facultyId?: true
    code?: true
    name?: true
    description?: true
    isActive?: true
    leaderName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IkohzaMaxAggregateInputType = {
    id?: true
    facultyId?: true
    code?: true
    name?: true
    description?: true
    isActive?: true
    leaderName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IkohzaCountAggregateInputType = {
    id?: true
    facultyId?: true
    code?: true
    name?: true
    description?: true
    isActive?: true
    leaderName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IkohzaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ikohza to aggregate.
     */
    where?: IkohzaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ikohzas to fetch.
     */
    orderBy?: IkohzaOrderByWithRelationInput | IkohzaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IkohzaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ikohzas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ikohzas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ikohzas
    **/
    _count?: true | IkohzaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IkohzaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IkohzaMaxAggregateInputType
  }

  export type GetIkohzaAggregateType<T extends IkohzaAggregateArgs> = {
        [P in keyof T & keyof AggregateIkohza]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIkohza[P]>
      : GetScalarType<T[P], AggregateIkohza[P]>
  }




  export type IkohzaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IkohzaWhereInput
    orderBy?: IkohzaOrderByWithAggregationInput | IkohzaOrderByWithAggregationInput[]
    by: IkohzaScalarFieldEnum[] | IkohzaScalarFieldEnum
    having?: IkohzaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IkohzaCountAggregateInputType | true
    _min?: IkohzaMinAggregateInputType
    _max?: IkohzaMaxAggregateInputType
  }

  export type IkohzaGroupByOutputType = {
    id: string
    facultyId: string
    code: string
    name: string
    description: string | null
    isActive: boolean
    leaderName: string | null
    createdAt: Date
    updatedAt: Date
    _count: IkohzaCountAggregateOutputType | null
    _min: IkohzaMinAggregateOutputType | null
    _max: IkohzaMaxAggregateOutputType | null
  }

  type GetIkohzaGroupByPayload<T extends IkohzaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IkohzaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IkohzaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IkohzaGroupByOutputType[P]>
            : GetScalarType<T[P], IkohzaGroupByOutputType[P]>
        }
      >
    >


  export type IkohzaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    leaderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    users?: boolean | Ikohza$usersArgs<ExtArgs>
    _count?: boolean | IkohzaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ikohza"]>

  export type IkohzaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    leaderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ikohza"]>

  export type IkohzaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    leaderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ikohza"]>

  export type IkohzaSelectScalar = {
    id?: boolean
    facultyId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    leaderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IkohzaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facultyId" | "code" | "name" | "description" | "isActive" | "leaderName" | "createdAt" | "updatedAt", ExtArgs["result"]["ikohza"]>
  export type IkohzaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
    users?: boolean | Ikohza$usersArgs<ExtArgs>
    _count?: boolean | IkohzaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IkohzaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }
  export type IkohzaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }

  export type $IkohzaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ikohza"
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      facultyId: string
      code: string
      name: string
      description: string | null
      isActive: boolean
      leaderName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ikohza"]>
    composites: {}
  }

  type IkohzaGetPayload<S extends boolean | null | undefined | IkohzaDefaultArgs> = $Result.GetResult<Prisma.$IkohzaPayload, S>

  type IkohzaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IkohzaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IkohzaCountAggregateInputType | true
    }

  export interface IkohzaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ikohza'], meta: { name: 'Ikohza' } }
    /**
     * Find zero or one Ikohza that matches the filter.
     * @param {IkohzaFindUniqueArgs} args - Arguments to find a Ikohza
     * @example
     * // Get one Ikohza
     * const ikohza = await prisma.ikohza.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IkohzaFindUniqueArgs>(args: SelectSubset<T, IkohzaFindUniqueArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ikohza that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IkohzaFindUniqueOrThrowArgs} args - Arguments to find a Ikohza
     * @example
     * // Get one Ikohza
     * const ikohza = await prisma.ikohza.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IkohzaFindUniqueOrThrowArgs>(args: SelectSubset<T, IkohzaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ikohza that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaFindFirstArgs} args - Arguments to find a Ikohza
     * @example
     * // Get one Ikohza
     * const ikohza = await prisma.ikohza.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IkohzaFindFirstArgs>(args?: SelectSubset<T, IkohzaFindFirstArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ikohza that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaFindFirstOrThrowArgs} args - Arguments to find a Ikohza
     * @example
     * // Get one Ikohza
     * const ikohza = await prisma.ikohza.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IkohzaFindFirstOrThrowArgs>(args?: SelectSubset<T, IkohzaFindFirstOrThrowArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ikohzas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ikohzas
     * const ikohzas = await prisma.ikohza.findMany()
     * 
     * // Get first 10 Ikohzas
     * const ikohzas = await prisma.ikohza.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ikohzaWithIdOnly = await prisma.ikohza.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IkohzaFindManyArgs>(args?: SelectSubset<T, IkohzaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ikohza.
     * @param {IkohzaCreateArgs} args - Arguments to create a Ikohza.
     * @example
     * // Create one Ikohza
     * const Ikohza = await prisma.ikohza.create({
     *   data: {
     *     // ... data to create a Ikohza
     *   }
     * })
     * 
     */
    create<T extends IkohzaCreateArgs>(args: SelectSubset<T, IkohzaCreateArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ikohzas.
     * @param {IkohzaCreateManyArgs} args - Arguments to create many Ikohzas.
     * @example
     * // Create many Ikohzas
     * const ikohza = await prisma.ikohza.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IkohzaCreateManyArgs>(args?: SelectSubset<T, IkohzaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ikohzas and returns the data saved in the database.
     * @param {IkohzaCreateManyAndReturnArgs} args - Arguments to create many Ikohzas.
     * @example
     * // Create many Ikohzas
     * const ikohza = await prisma.ikohza.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ikohzas and only return the `id`
     * const ikohzaWithIdOnly = await prisma.ikohza.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IkohzaCreateManyAndReturnArgs>(args?: SelectSubset<T, IkohzaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ikohza.
     * @param {IkohzaDeleteArgs} args - Arguments to delete one Ikohza.
     * @example
     * // Delete one Ikohza
     * const Ikohza = await prisma.ikohza.delete({
     *   where: {
     *     // ... filter to delete one Ikohza
     *   }
     * })
     * 
     */
    delete<T extends IkohzaDeleteArgs>(args: SelectSubset<T, IkohzaDeleteArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ikohza.
     * @param {IkohzaUpdateArgs} args - Arguments to update one Ikohza.
     * @example
     * // Update one Ikohza
     * const ikohza = await prisma.ikohza.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IkohzaUpdateArgs>(args: SelectSubset<T, IkohzaUpdateArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ikohzas.
     * @param {IkohzaDeleteManyArgs} args - Arguments to filter Ikohzas to delete.
     * @example
     * // Delete a few Ikohzas
     * const { count } = await prisma.ikohza.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IkohzaDeleteManyArgs>(args?: SelectSubset<T, IkohzaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ikohzas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ikohzas
     * const ikohza = await prisma.ikohza.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IkohzaUpdateManyArgs>(args: SelectSubset<T, IkohzaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ikohzas and returns the data updated in the database.
     * @param {IkohzaUpdateManyAndReturnArgs} args - Arguments to update many Ikohzas.
     * @example
     * // Update many Ikohzas
     * const ikohza = await prisma.ikohza.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ikohzas and only return the `id`
     * const ikohzaWithIdOnly = await prisma.ikohza.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IkohzaUpdateManyAndReturnArgs>(args: SelectSubset<T, IkohzaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ikohza.
     * @param {IkohzaUpsertArgs} args - Arguments to update or create a Ikohza.
     * @example
     * // Update or create a Ikohza
     * const ikohza = await prisma.ikohza.upsert({
     *   create: {
     *     // ... data to create a Ikohza
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ikohza we want to update
     *   }
     * })
     */
    upsert<T extends IkohzaUpsertArgs>(args: SelectSubset<T, IkohzaUpsertArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ikohzas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaCountArgs} args - Arguments to filter Ikohzas to count.
     * @example
     * // Count the number of Ikohzas
     * const count = await prisma.ikohza.count({
     *   where: {
     *     // ... the filter for the Ikohzas we want to count
     *   }
     * })
    **/
    count<T extends IkohzaCountArgs>(
      args?: Subset<T, IkohzaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IkohzaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ikohza.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IkohzaAggregateArgs>(args: Subset<T, IkohzaAggregateArgs>): Prisma.PrismaPromise<GetIkohzaAggregateType<T>>

    /**
     * Group by Ikohza.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IkohzaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IkohzaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IkohzaGroupByArgs['orderBy'] }
        : { orderBy?: IkohzaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IkohzaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIkohzaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ikohza model
   */
  readonly fields: IkohzaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ikohza.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IkohzaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends Ikohza$usersArgs<ExtArgs> = {}>(args?: Subset<T, Ikohza$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ikohza model
   */
  interface IkohzaFieldRefs {
    readonly id: FieldRef<"Ikohza", 'String'>
    readonly facultyId: FieldRef<"Ikohza", 'String'>
    readonly code: FieldRef<"Ikohza", 'String'>
    readonly name: FieldRef<"Ikohza", 'String'>
    readonly description: FieldRef<"Ikohza", 'String'>
    readonly isActive: FieldRef<"Ikohza", 'Boolean'>
    readonly leaderName: FieldRef<"Ikohza", 'String'>
    readonly createdAt: FieldRef<"Ikohza", 'DateTime'>
    readonly updatedAt: FieldRef<"Ikohza", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ikohza findUnique
   */
  export type IkohzaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * Filter, which Ikohza to fetch.
     */
    where: IkohzaWhereUniqueInput
  }

  /**
   * Ikohza findUniqueOrThrow
   */
  export type IkohzaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * Filter, which Ikohza to fetch.
     */
    where: IkohzaWhereUniqueInput
  }

  /**
   * Ikohza findFirst
   */
  export type IkohzaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * Filter, which Ikohza to fetch.
     */
    where?: IkohzaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ikohzas to fetch.
     */
    orderBy?: IkohzaOrderByWithRelationInput | IkohzaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ikohzas.
     */
    cursor?: IkohzaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ikohzas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ikohzas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ikohzas.
     */
    distinct?: IkohzaScalarFieldEnum | IkohzaScalarFieldEnum[]
  }

  /**
   * Ikohza findFirstOrThrow
   */
  export type IkohzaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * Filter, which Ikohza to fetch.
     */
    where?: IkohzaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ikohzas to fetch.
     */
    orderBy?: IkohzaOrderByWithRelationInput | IkohzaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ikohzas.
     */
    cursor?: IkohzaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ikohzas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ikohzas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ikohzas.
     */
    distinct?: IkohzaScalarFieldEnum | IkohzaScalarFieldEnum[]
  }

  /**
   * Ikohza findMany
   */
  export type IkohzaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * Filter, which Ikohzas to fetch.
     */
    where?: IkohzaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ikohzas to fetch.
     */
    orderBy?: IkohzaOrderByWithRelationInput | IkohzaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ikohzas.
     */
    cursor?: IkohzaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ikohzas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ikohzas.
     */
    skip?: number
    distinct?: IkohzaScalarFieldEnum | IkohzaScalarFieldEnum[]
  }

  /**
   * Ikohza create
   */
  export type IkohzaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * The data needed to create a Ikohza.
     */
    data: XOR<IkohzaCreateInput, IkohzaUncheckedCreateInput>
  }

  /**
   * Ikohza createMany
   */
  export type IkohzaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ikohzas.
     */
    data: IkohzaCreateManyInput | IkohzaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ikohza createManyAndReturn
   */
  export type IkohzaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * The data used to create many Ikohzas.
     */
    data: IkohzaCreateManyInput | IkohzaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ikohza update
   */
  export type IkohzaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * The data needed to update a Ikohza.
     */
    data: XOR<IkohzaUpdateInput, IkohzaUncheckedUpdateInput>
    /**
     * Choose, which Ikohza to update.
     */
    where: IkohzaWhereUniqueInput
  }

  /**
   * Ikohza updateMany
   */
  export type IkohzaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ikohzas.
     */
    data: XOR<IkohzaUpdateManyMutationInput, IkohzaUncheckedUpdateManyInput>
    /**
     * Filter which Ikohzas to update
     */
    where?: IkohzaWhereInput
    /**
     * Limit how many Ikohzas to update.
     */
    limit?: number
  }

  /**
   * Ikohza updateManyAndReturn
   */
  export type IkohzaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * The data used to update Ikohzas.
     */
    data: XOR<IkohzaUpdateManyMutationInput, IkohzaUncheckedUpdateManyInput>
    /**
     * Filter which Ikohzas to update
     */
    where?: IkohzaWhereInput
    /**
     * Limit how many Ikohzas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ikohza upsert
   */
  export type IkohzaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * The filter to search for the Ikohza to update in case it exists.
     */
    where: IkohzaWhereUniqueInput
    /**
     * In case the Ikohza found by the `where` argument doesn't exist, create a new Ikohza with this data.
     */
    create: XOR<IkohzaCreateInput, IkohzaUncheckedCreateInput>
    /**
     * In case the Ikohza was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IkohzaUpdateInput, IkohzaUncheckedUpdateInput>
  }

  /**
   * Ikohza delete
   */
  export type IkohzaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    /**
     * Filter which Ikohza to delete.
     */
    where: IkohzaWhereUniqueInput
  }

  /**
   * Ikohza deleteMany
   */
  export type IkohzaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ikohzas to delete
     */
    where?: IkohzaWhereInput
    /**
     * Limit how many Ikohzas to delete.
     */
    limit?: number
  }

  /**
   * Ikohza.users
   */
  export type Ikohza$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Ikohza without action
   */
  export type IkohzaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    regNo: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    legalName: string | null
    regNo: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    legalName: number
    regNo: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    regNo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    regNo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    legalName?: true
    regNo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    legalName: string | null
    regNo: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    regNo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branches?: boolean | Company$branchesArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    bookings?: boolean | Company$bookingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    regNo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    legalName?: boolean
    regNo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    legalName?: boolean
    regNo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "legalName" | "regNo" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | Company$branchesArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    bookings?: boolean | Company$bookingsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      branches: Prisma.$CompanyBranchPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      bookings: Prisma.$BookingRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      legalName: string | null
      regNo: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branches<T extends Company$branchesArgs<ExtArgs> = {}>(args?: Subset<T, Company$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Company$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly legalName: FieldRef<"Company", 'String'>
    readonly regNo: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.branches
   */
  export type Company$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    where?: CompanyBranchWhereInput
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    cursor?: CompanyBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.bookings
   */
  export type Company$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    cursor?: BookingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyBranch
   */

  export type AggregateCompanyBranch = {
    _count: CompanyBranchCountAggregateOutputType | null
    _min: CompanyBranchMinAggregateOutputType | null
    _max: CompanyBranchMaxAggregateOutputType | null
  }

  export type CompanyBranchMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyBranchMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyBranchCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    address: number
    city: number
    state: number
    postcode: number
    country: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyBranchMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyBranchMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyBranchCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    postcode?: true
    country?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBranch to aggregate.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyBranches
    **/
    _count?: true | CompanyBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyBranchMaxAggregateInputType
  }

  export type GetCompanyBranchAggregateType<T extends CompanyBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyBranch[P]>
      : GetScalarType<T[P], AggregateCompanyBranch[P]>
  }




  export type CompanyBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBranchWhereInput
    orderBy?: CompanyBranchOrderByWithAggregationInput | CompanyBranchOrderByWithAggregationInput[]
    by: CompanyBranchScalarFieldEnum[] | CompanyBranchScalarFieldEnum
    having?: CompanyBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyBranchCountAggregateInputType | true
    _min?: CompanyBranchMinAggregateInputType
    _max?: CompanyBranchMaxAggregateInputType
  }

  export type CompanyBranchGroupByOutputType = {
    id: string
    companyId: string
    name: string
    address: string | null
    city: string | null
    state: string | null
    postcode: string | null
    country: string | null
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyBranchCountAggregateOutputType | null
    _min: CompanyBranchMinAggregateOutputType | null
    _max: CompanyBranchMaxAggregateOutputType | null
  }

  type GetCompanyBranchGroupByPayload<T extends CompanyBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyBranchGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyBranchGroupByOutputType[P]>
        }
      >
    >


  export type CompanyBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    users?: boolean | CompanyBranch$usersArgs<ExtArgs>
    bookings?: boolean | CompanyBranch$bookingsArgs<ExtArgs>
    _count?: boolean | CompanyBranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyBranch"]>

  export type CompanyBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyBranch"]>

  export type CompanyBranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyBranch"]>

  export type CompanyBranchSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyBranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "address" | "city" | "state" | "postcode" | "country" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["companyBranch"]>
  export type CompanyBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    users?: boolean | CompanyBranch$usersArgs<ExtArgs>
    bookings?: boolean | CompanyBranch$bookingsArgs<ExtArgs>
    _count?: boolean | CompanyBranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyBranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyBranch"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      bookings: Prisma.$BookingRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      address: string | null
      city: string | null
      state: string | null
      postcode: string | null
      country: string | null
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyBranch"]>
    composites: {}
  }

  type CompanyBranchGetPayload<S extends boolean | null | undefined | CompanyBranchDefaultArgs> = $Result.GetResult<Prisma.$CompanyBranchPayload, S>

  type CompanyBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyBranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyBranchCountAggregateInputType | true
    }

  export interface CompanyBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyBranch'], meta: { name: 'CompanyBranch' } }
    /**
     * Find zero or one CompanyBranch that matches the filter.
     * @param {CompanyBranchFindUniqueArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyBranchFindUniqueArgs>(args: SelectSubset<T, CompanyBranchFindUniqueArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyBranch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyBranchFindUniqueOrThrowArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchFindFirstArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyBranchFindFirstArgs>(args?: SelectSubset<T, CompanyBranchFindFirstArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchFindFirstOrThrowArgs} args - Arguments to find a CompanyBranch
     * @example
     * // Get one CompanyBranch
     * const companyBranch = await prisma.companyBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyBranches
     * const companyBranches = await prisma.companyBranch.findMany()
     * 
     * // Get first 10 CompanyBranches
     * const companyBranches = await prisma.companyBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyBranchWithIdOnly = await prisma.companyBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyBranchFindManyArgs>(args?: SelectSubset<T, CompanyBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyBranch.
     * @param {CompanyBranchCreateArgs} args - Arguments to create a CompanyBranch.
     * @example
     * // Create one CompanyBranch
     * const CompanyBranch = await prisma.companyBranch.create({
     *   data: {
     *     // ... data to create a CompanyBranch
     *   }
     * })
     * 
     */
    create<T extends CompanyBranchCreateArgs>(args: SelectSubset<T, CompanyBranchCreateArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyBranches.
     * @param {CompanyBranchCreateManyArgs} args - Arguments to create many CompanyBranches.
     * @example
     * // Create many CompanyBranches
     * const companyBranch = await prisma.companyBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyBranchCreateManyArgs>(args?: SelectSubset<T, CompanyBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyBranches and returns the data saved in the database.
     * @param {CompanyBranchCreateManyAndReturnArgs} args - Arguments to create many CompanyBranches.
     * @example
     * // Create many CompanyBranches
     * const companyBranch = await prisma.companyBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyBranches and only return the `id`
     * const companyBranchWithIdOnly = await prisma.companyBranch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyBranch.
     * @param {CompanyBranchDeleteArgs} args - Arguments to delete one CompanyBranch.
     * @example
     * // Delete one CompanyBranch
     * const CompanyBranch = await prisma.companyBranch.delete({
     *   where: {
     *     // ... filter to delete one CompanyBranch
     *   }
     * })
     * 
     */
    delete<T extends CompanyBranchDeleteArgs>(args: SelectSubset<T, CompanyBranchDeleteArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyBranch.
     * @param {CompanyBranchUpdateArgs} args - Arguments to update one CompanyBranch.
     * @example
     * // Update one CompanyBranch
     * const companyBranch = await prisma.companyBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyBranchUpdateArgs>(args: SelectSubset<T, CompanyBranchUpdateArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyBranches.
     * @param {CompanyBranchDeleteManyArgs} args - Arguments to filter CompanyBranches to delete.
     * @example
     * // Delete a few CompanyBranches
     * const { count } = await prisma.companyBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyBranchDeleteManyArgs>(args?: SelectSubset<T, CompanyBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyBranches
     * const companyBranch = await prisma.companyBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyBranchUpdateManyArgs>(args: SelectSubset<T, CompanyBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyBranches and returns the data updated in the database.
     * @param {CompanyBranchUpdateManyAndReturnArgs} args - Arguments to update many CompanyBranches.
     * @example
     * // Update many CompanyBranches
     * const companyBranch = await prisma.companyBranch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyBranches and only return the `id`
     * const companyBranchWithIdOnly = await prisma.companyBranch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyBranchUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyBranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyBranch.
     * @param {CompanyBranchUpsertArgs} args - Arguments to update or create a CompanyBranch.
     * @example
     * // Update or create a CompanyBranch
     * const companyBranch = await prisma.companyBranch.upsert({
     *   create: {
     *     // ... data to create a CompanyBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyBranch we want to update
     *   }
     * })
     */
    upsert<T extends CompanyBranchUpsertArgs>(args: SelectSubset<T, CompanyBranchUpsertArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchCountArgs} args - Arguments to filter CompanyBranches to count.
     * @example
     * // Count the number of CompanyBranches
     * const count = await prisma.companyBranch.count({
     *   where: {
     *     // ... the filter for the CompanyBranches we want to count
     *   }
     * })
    **/
    count<T extends CompanyBranchCountArgs>(
      args?: Subset<T, CompanyBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyBranchAggregateArgs>(args: Subset<T, CompanyBranchAggregateArgs>): Prisma.PrismaPromise<GetCompanyBranchAggregateType<T>>

    /**
     * Group by CompanyBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyBranchGroupByArgs['orderBy'] }
        : { orderBy?: CompanyBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyBranch model
   */
  readonly fields: CompanyBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends CompanyBranch$usersArgs<ExtArgs> = {}>(args?: Subset<T, CompanyBranch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends CompanyBranch$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, CompanyBranch$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyBranch model
   */
  interface CompanyBranchFieldRefs {
    readonly id: FieldRef<"CompanyBranch", 'String'>
    readonly companyId: FieldRef<"CompanyBranch", 'String'>
    readonly name: FieldRef<"CompanyBranch", 'String'>
    readonly address: FieldRef<"CompanyBranch", 'String'>
    readonly city: FieldRef<"CompanyBranch", 'String'>
    readonly state: FieldRef<"CompanyBranch", 'String'>
    readonly postcode: FieldRef<"CompanyBranch", 'String'>
    readonly country: FieldRef<"CompanyBranch", 'String'>
    readonly phone: FieldRef<"CompanyBranch", 'String'>
    readonly isActive: FieldRef<"CompanyBranch", 'Boolean'>
    readonly createdAt: FieldRef<"CompanyBranch", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyBranch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyBranch findUnique
   */
  export type CompanyBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch findUniqueOrThrow
   */
  export type CompanyBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch findFirst
   */
  export type CompanyBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBranches.
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBranches.
     */
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * CompanyBranch findFirstOrThrow
   */
  export type CompanyBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranch to fetch.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBranches.
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBranches.
     */
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * CompanyBranch findMany
   */
  export type CompanyBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBranches to fetch.
     */
    where?: CompanyBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBranches to fetch.
     */
    orderBy?: CompanyBranchOrderByWithRelationInput | CompanyBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyBranches.
     */
    cursor?: CompanyBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBranches.
     */
    skip?: number
    distinct?: CompanyBranchScalarFieldEnum | CompanyBranchScalarFieldEnum[]
  }

  /**
   * CompanyBranch create
   */
  export type CompanyBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyBranch.
     */
    data: XOR<CompanyBranchCreateInput, CompanyBranchUncheckedCreateInput>
  }

  /**
   * CompanyBranch createMany
   */
  export type CompanyBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyBranches.
     */
    data: CompanyBranchCreateManyInput | CompanyBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyBranch createManyAndReturn
   */
  export type CompanyBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyBranches.
     */
    data: CompanyBranchCreateManyInput | CompanyBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyBranch update
   */
  export type CompanyBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyBranch.
     */
    data: XOR<CompanyBranchUpdateInput, CompanyBranchUncheckedUpdateInput>
    /**
     * Choose, which CompanyBranch to update.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch updateMany
   */
  export type CompanyBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyBranches.
     */
    data: XOR<CompanyBranchUpdateManyMutationInput, CompanyBranchUncheckedUpdateManyInput>
    /**
     * Filter which CompanyBranches to update
     */
    where?: CompanyBranchWhereInput
    /**
     * Limit how many CompanyBranches to update.
     */
    limit?: number
  }

  /**
   * CompanyBranch updateManyAndReturn
   */
  export type CompanyBranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * The data used to update CompanyBranches.
     */
    data: XOR<CompanyBranchUpdateManyMutationInput, CompanyBranchUncheckedUpdateManyInput>
    /**
     * Filter which CompanyBranches to update
     */
    where?: CompanyBranchWhereInput
    /**
     * Limit how many CompanyBranches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyBranch upsert
   */
  export type CompanyBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyBranch to update in case it exists.
     */
    where: CompanyBranchWhereUniqueInput
    /**
     * In case the CompanyBranch found by the `where` argument doesn't exist, create a new CompanyBranch with this data.
     */
    create: XOR<CompanyBranchCreateInput, CompanyBranchUncheckedCreateInput>
    /**
     * In case the CompanyBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyBranchUpdateInput, CompanyBranchUncheckedUpdateInput>
  }

  /**
   * CompanyBranch delete
   */
  export type CompanyBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    /**
     * Filter which CompanyBranch to delete.
     */
    where: CompanyBranchWhereUniqueInput
  }

  /**
   * CompanyBranch deleteMany
   */
  export type CompanyBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBranches to delete
     */
    where?: CompanyBranchWhereInput
    /**
     * Limit how many CompanyBranches to delete.
     */
    limit?: number
  }

  /**
   * CompanyBranch.users
   */
  export type CompanyBranch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * CompanyBranch.bookings
   */
  export type CompanyBranch$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    cursor?: BookingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * CompanyBranch without action
   */
  export type CompanyBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    phone: string | null
    userType: $Enums.user_type_enum | null
    status: $Enums.user_status_enum | null
    academicType: $Enums.academic_type_enum | null
    userIdentifier: string | null
    supervisorName: string | null
    facultyId: string | null
    departmentId: string | null
    ikohzaId: string | null
    companyId: string | null
    companyBranchId: string | null
    UTM: $Enums.UTM | null
    address: string | null
    email: string | null
    emailVerifiedAt: Date | null
    lastLoginAt: Date | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedBy: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    phone: string | null
    userType: $Enums.user_type_enum | null
    status: $Enums.user_status_enum | null
    academicType: $Enums.academic_type_enum | null
    userIdentifier: string | null
    supervisorName: string | null
    facultyId: string | null
    departmentId: string | null
    ikohzaId: string | null
    companyId: string | null
    companyBranchId: string | null
    UTM: $Enums.UTM | null
    address: string | null
    email: string | null
    emailVerifiedAt: Date | null
    lastLoginAt: Date | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    approvedBy: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    profileImageUrl: number
    phone: number
    userType: number
    status: number
    academicType: number
    userIdentifier: number
    supervisorName: number
    facultyId: number
    departmentId: number
    ikohzaId: number
    companyId: number
    companyBranchId: number
    UTM: number
    address: number
    email: number
    emailVerifiedAt: number
    lastLoginAt: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    approvedBy: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    phone?: true
    userType?: true
    status?: true
    academicType?: true
    userIdentifier?: true
    supervisorName?: true
    facultyId?: true
    departmentId?: true
    ikohzaId?: true
    companyId?: true
    companyBranchId?: true
    UTM?: true
    address?: true
    email?: true
    emailVerifiedAt?: true
    lastLoginAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    approvedBy?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    phone?: true
    userType?: true
    status?: true
    academicType?: true
    userIdentifier?: true
    supervisorName?: true
    facultyId?: true
    departmentId?: true
    ikohzaId?: true
    companyId?: true
    companyBranchId?: true
    UTM?: true
    address?: true
    email?: true
    emailVerifiedAt?: true
    lastLoginAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    approvedBy?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    phone?: true
    userType?: true
    status?: true
    academicType?: true
    userIdentifier?: true
    supervisorName?: true
    facultyId?: true
    departmentId?: true
    ikohzaId?: true
    companyId?: true
    companyBranchId?: true
    UTM?: true
    address?: true
    email?: true
    emailVerifiedAt?: true
    lastLoginAt?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    approvedBy?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    profileImageUrl: string | null
    phone: string | null
    userType: $Enums.user_type_enum
    status: $Enums.user_status_enum
    academicType: $Enums.academic_type_enum
    userIdentifier: string | null
    supervisorName: string | null
    facultyId: string | null
    departmentId: string | null
    ikohzaId: string | null
    companyId: string | null
    companyBranchId: string | null
    UTM: $Enums.UTM | null
    address: string | null
    email: string
    emailVerifiedAt: Date | null
    lastLoginAt: Date | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    approvedBy: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    phone?: boolean
    userType?: boolean
    status?: boolean
    academicType?: boolean
    userIdentifier?: boolean
    supervisorName?: boolean
    facultyId?: boolean
    departmentId?: boolean
    ikohzaId?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    UTM?: boolean
    address?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean
    facultyRelation?: boolean | User$facultyRelationArgs<ExtArgs>
    departmentRelation?: boolean | User$departmentRelationArgs<ExtArgs>
    ikohza?: boolean | User$ikohzaArgs<ExtArgs>
    companyRelation?: boolean | User$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | User$companyBranchArgs<ExtArgs>
    approvedByUser?: boolean | User$approvedByUserArgs<ExtArgs>
    approvedUsers?: boolean | User$approvedUsersArgs<ExtArgs>
    authProviders?: boolean | User$authProvidersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    bookingRequests?: boolean | User$bookingRequestsArgs<ExtArgs>
    approvedBookings?: boolean | User$approvedBookingsArgs<ExtArgs>
    serviceForms?: boolean | User$serviceFormsArgs<ExtArgs>
    uploadedInvoices?: boolean | User$uploadedInvoicesArgs<ExtArgs>
    verifiedPayments?: boolean | User$verifiedPaymentsArgs<ExtArgs>
    uploadedResults?: boolean | User$uploadedResultsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sampleTracking?: boolean | User$sampleTrackingArgs<ExtArgs>
    createdModifications?: boolean | User$createdModificationsArgs<ExtArgs>
    approvedModifications?: boolean | User$approvedModificationsArgs<ExtArgs>
    uploadedPayments?: boolean | User$uploadedPaymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    phone?: boolean
    userType?: boolean
    status?: boolean
    academicType?: boolean
    userIdentifier?: boolean
    supervisorName?: boolean
    facultyId?: boolean
    departmentId?: boolean
    ikohzaId?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    UTM?: boolean
    address?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean
    facultyRelation?: boolean | User$facultyRelationArgs<ExtArgs>
    departmentRelation?: boolean | User$departmentRelationArgs<ExtArgs>
    ikohza?: boolean | User$ikohzaArgs<ExtArgs>
    companyRelation?: boolean | User$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | User$companyBranchArgs<ExtArgs>
    approvedByUser?: boolean | User$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    phone?: boolean
    userType?: boolean
    status?: boolean
    academicType?: boolean
    userIdentifier?: boolean
    supervisorName?: boolean
    facultyId?: boolean
    departmentId?: boolean
    ikohzaId?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    UTM?: boolean
    address?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean
    facultyRelation?: boolean | User$facultyRelationArgs<ExtArgs>
    departmentRelation?: boolean | User$departmentRelationArgs<ExtArgs>
    ikohza?: boolean | User$ikohzaArgs<ExtArgs>
    companyRelation?: boolean | User$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | User$companyBranchArgs<ExtArgs>
    approvedByUser?: boolean | User$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    phone?: boolean
    userType?: boolean
    status?: boolean
    academicType?: boolean
    userIdentifier?: boolean
    supervisorName?: boolean
    facultyId?: boolean
    departmentId?: boolean
    ikohzaId?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    UTM?: boolean
    address?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approvedBy?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "profileImageUrl" | "phone" | "userType" | "status" | "academicType" | "userIdentifier" | "supervisorName" | "facultyId" | "departmentId" | "ikohzaId" | "companyId" | "companyBranchId" | "UTM" | "address" | "email" | "emailVerifiedAt" | "lastLoginAt" | "approvedAt" | "createdAt" | "updatedAt" | "approvedBy", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facultyRelation?: boolean | User$facultyRelationArgs<ExtArgs>
    departmentRelation?: boolean | User$departmentRelationArgs<ExtArgs>
    ikohza?: boolean | User$ikohzaArgs<ExtArgs>
    companyRelation?: boolean | User$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | User$companyBranchArgs<ExtArgs>
    approvedByUser?: boolean | User$approvedByUserArgs<ExtArgs>
    approvedUsers?: boolean | User$approvedUsersArgs<ExtArgs>
    authProviders?: boolean | User$authProvidersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    bookingRequests?: boolean | User$bookingRequestsArgs<ExtArgs>
    approvedBookings?: boolean | User$approvedBookingsArgs<ExtArgs>
    serviceForms?: boolean | User$serviceFormsArgs<ExtArgs>
    uploadedInvoices?: boolean | User$uploadedInvoicesArgs<ExtArgs>
    verifiedPayments?: boolean | User$verifiedPaymentsArgs<ExtArgs>
    uploadedResults?: boolean | User$uploadedResultsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sampleTracking?: boolean | User$sampleTrackingArgs<ExtArgs>
    createdModifications?: boolean | User$createdModificationsArgs<ExtArgs>
    approvedModifications?: boolean | User$approvedModificationsArgs<ExtArgs>
    uploadedPayments?: boolean | User$uploadedPaymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facultyRelation?: boolean | User$facultyRelationArgs<ExtArgs>
    departmentRelation?: boolean | User$departmentRelationArgs<ExtArgs>
    ikohza?: boolean | User$ikohzaArgs<ExtArgs>
    companyRelation?: boolean | User$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | User$companyBranchArgs<ExtArgs>
    approvedByUser?: boolean | User$approvedByUserArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facultyRelation?: boolean | User$facultyRelationArgs<ExtArgs>
    departmentRelation?: boolean | User$departmentRelationArgs<ExtArgs>
    ikohza?: boolean | User$ikohzaArgs<ExtArgs>
    companyRelation?: boolean | User$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | User$companyBranchArgs<ExtArgs>
    approvedByUser?: boolean | User$approvedByUserArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      facultyRelation: Prisma.$FacultyPayload<ExtArgs> | null
      departmentRelation: Prisma.$DepartmentPayload<ExtArgs> | null
      ikohza: Prisma.$IkohzaPayload<ExtArgs> | null
      companyRelation: Prisma.$CompanyPayload<ExtArgs> | null
      companyBranch: Prisma.$CompanyBranchPayload<ExtArgs> | null
      approvedByUser: Prisma.$UserPayload<ExtArgs> | null
      approvedUsers: Prisma.$UserPayload<ExtArgs>[]
      authProviders: Prisma.$AuthProviderPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      bookingRequests: Prisma.$BookingRequestPayload<ExtArgs>[]
      approvedBookings: Prisma.$BookingRequestPayload<ExtArgs>[]
      serviceForms: Prisma.$ServiceFormPayload<ExtArgs>[]
      uploadedInvoices: Prisma.$InvoicePayload<ExtArgs>[]
      verifiedPayments: Prisma.$PaymentPayload<ExtArgs>[]
      uploadedResults: Prisma.$AnalysisResultPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sampleTracking: Prisma.$SampleTrackingPayload<ExtArgs>[]
      createdModifications: Prisma.$SampleModificationPayload<ExtArgs>[]
      approvedModifications: Prisma.$SampleModificationPayload<ExtArgs>[]
      uploadedPayments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      profileImageUrl: string | null
      phone: string | null
      userType: $Enums.user_type_enum
      status: $Enums.user_status_enum
      academicType: $Enums.academic_type_enum
      userIdentifier: string | null
      supervisorName: string | null
      facultyId: string | null
      departmentId: string | null
      ikohzaId: string | null
      companyId: string | null
      companyBranchId: string | null
      UTM: $Enums.UTM | null
      address: string | null
      email: string
      emailVerifiedAt: Date | null
      lastLoginAt: Date | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
      approvedBy: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facultyRelation<T extends User$facultyRelationArgs<ExtArgs> = {}>(args?: Subset<T, User$facultyRelationArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    departmentRelation<T extends User$departmentRelationArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentRelationArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ikohza<T extends User$ikohzaArgs<ExtArgs> = {}>(args?: Subset<T, User$ikohzaArgs<ExtArgs>>): Prisma__IkohzaClient<$Result.GetResult<Prisma.$IkohzaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companyRelation<T extends User$companyRelationArgs<ExtArgs> = {}>(args?: Subset<T, User$companyRelationArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companyBranch<T extends User$companyBranchArgs<ExtArgs> = {}>(args?: Subset<T, User$companyBranchArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedByUser<T extends User$approvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedUsers<T extends User$approvedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authProviders<T extends User$authProvidersArgs<ExtArgs> = {}>(args?: Subset<T, User$authProvidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingRequests<T extends User$bookingRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedBookings<T extends User$approvedBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceForms<T extends User$serviceFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedInvoices<T extends User$uploadedInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedPayments<T extends User$verifiedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$verifiedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedResults<T extends User$uploadedResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sampleTracking<T extends User$sampleTrackingArgs<ExtArgs> = {}>(args?: Subset<T, User$sampleTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdModifications<T extends User$createdModificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdModificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedModifications<T extends User$approvedModificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedModificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedPayments<T extends User$uploadedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly profileImageUrl: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'user_type_enum'>
    readonly status: FieldRef<"User", 'user_status_enum'>
    readonly academicType: FieldRef<"User", 'academic_type_enum'>
    readonly userIdentifier: FieldRef<"User", 'String'>
    readonly supervisorName: FieldRef<"User", 'String'>
    readonly facultyId: FieldRef<"User", 'String'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly ikohzaId: FieldRef<"User", 'String'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly companyBranchId: FieldRef<"User", 'String'>
    readonly UTM: FieldRef<"User", 'UTM'>
    readonly address: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly approvedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly approvedBy: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.facultyRelation
   */
  export type User$facultyRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * User.departmentRelation
   */
  export type User$departmentRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.ikohza
   */
  export type User$ikohzaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ikohza
     */
    select?: IkohzaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ikohza
     */
    omit?: IkohzaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IkohzaInclude<ExtArgs> | null
    where?: IkohzaWhereInput
  }

  /**
   * User.companyRelation
   */
  export type User$companyRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * User.companyBranch
   */
  export type User$companyBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    where?: CompanyBranchWhereInput
  }

  /**
   * User.approvedByUser
   */
  export type User$approvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.approvedUsers
   */
  export type User$approvedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.authProviders
   */
  export type User$authProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    where?: AuthProviderWhereInput
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    cursor?: AuthProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.bookingRequests
   */
  export type User$bookingRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    cursor?: BookingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * User.approvedBookings
   */
  export type User$approvedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    cursor?: BookingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * User.serviceForms
   */
  export type User$serviceFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    where?: ServiceFormWhereInput
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    cursor?: ServiceFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * User.uploadedInvoices
   */
  export type User$uploadedInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.verifiedPayments
   */
  export type User$verifiedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.uploadedResults
   */
  export type User$uploadedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    where?: AnalysisResultWhereInput
    orderBy?: AnalysisResultOrderByWithRelationInput | AnalysisResultOrderByWithRelationInput[]
    cursor?: AnalysisResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisResultScalarFieldEnum | AnalysisResultScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sampleTracking
   */
  export type User$sampleTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    where?: SampleTrackingWhereInput
    orderBy?: SampleTrackingOrderByWithRelationInput | SampleTrackingOrderByWithRelationInput[]
    cursor?: SampleTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleTrackingScalarFieldEnum | SampleTrackingScalarFieldEnum[]
  }

  /**
   * User.createdModifications
   */
  export type User$createdModificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    where?: SampleModificationWhereInput
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    cursor?: SampleModificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleModificationScalarFieldEnum | SampleModificationScalarFieldEnum[]
  }

  /**
   * User.approvedModifications
   */
  export type User$approvedModificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    where?: SampleModificationWhereInput
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    cursor?: SampleModificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleModificationScalarFieldEnum | SampleModificationScalarFieldEnum[]
  }

  /**
   * User.uploadedPayments
   */
  export type User$uploadedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AuthProvider
   */

  export type AggregateAuthProvider = {
    _count: AuthProviderCountAggregateOutputType | null
    _min: AuthProviderMinAggregateOutputType | null
    _max: AuthProviderMaxAggregateOutputType | null
  }

  export type AuthProviderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerAccountId: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthProviderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerAccountId: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthProviderCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerAccountId: number
    passwordHash: number
    oauthData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthProviderMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthProviderMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthProviderCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    passwordHash?: true
    oauthData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthProvider to aggregate.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthProviders
    **/
    _count?: true | AuthProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthProviderMaxAggregateInputType
  }

  export type GetAuthProviderAggregateType<T extends AuthProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthProvider[P]>
      : GetScalarType<T[P], AggregateAuthProvider[P]>
  }




  export type AuthProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthProviderWhereInput
    orderBy?: AuthProviderOrderByWithAggregationInput | AuthProviderOrderByWithAggregationInput[]
    by: AuthProviderScalarFieldEnum[] | AuthProviderScalarFieldEnum
    having?: AuthProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthProviderCountAggregateInputType | true
    _min?: AuthProviderMinAggregateInputType
    _max?: AuthProviderMaxAggregateInputType
  }

  export type AuthProviderGroupByOutputType = {
    id: string
    userId: string
    provider: string
    providerAccountId: string
    passwordHash: string | null
    oauthData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AuthProviderCountAggregateOutputType | null
    _min: AuthProviderMinAggregateOutputType | null
    _max: AuthProviderMaxAggregateOutputType | null
  }

  type GetAuthProviderGroupByPayload<T extends AuthProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthProviderGroupByOutputType[P]>
            : GetScalarType<T[P], AuthProviderGroupByOutputType[P]>
        }
      >
    >


  export type AuthProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    passwordHash?: boolean
    oauthData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authProvider"]>

  export type AuthProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    passwordHash?: boolean
    oauthData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authProvider"]>

  export type AuthProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    passwordHash?: boolean
    oauthData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authProvider"]>

  export type AuthProviderSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    passwordHash?: boolean
    oauthData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerAccountId" | "passwordHash" | "oauthData" | "createdAt" | "updatedAt", ExtArgs["result"]["authProvider"]>
  export type AuthProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthProvider"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      providerAccountId: string
      passwordHash: string | null
      oauthData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authProvider"]>
    composites: {}
  }

  type AuthProviderGetPayload<S extends boolean | null | undefined | AuthProviderDefaultArgs> = $Result.GetResult<Prisma.$AuthProviderPayload, S>

  type AuthProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthProviderCountAggregateInputType | true
    }

  export interface AuthProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthProvider'], meta: { name: 'AuthProvider' } }
    /**
     * Find zero or one AuthProvider that matches the filter.
     * @param {AuthProviderFindUniqueArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthProviderFindUniqueArgs>(args: SelectSubset<T, AuthProviderFindUniqueArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthProviderFindUniqueOrThrowArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderFindFirstArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthProviderFindFirstArgs>(args?: SelectSubset<T, AuthProviderFindFirstArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderFindFirstOrThrowArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthProviders
     * const authProviders = await prisma.authProvider.findMany()
     * 
     * // Get first 10 AuthProviders
     * const authProviders = await prisma.authProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authProviderWithIdOnly = await prisma.authProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthProviderFindManyArgs>(args?: SelectSubset<T, AuthProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthProvider.
     * @param {AuthProviderCreateArgs} args - Arguments to create a AuthProvider.
     * @example
     * // Create one AuthProvider
     * const AuthProvider = await prisma.authProvider.create({
     *   data: {
     *     // ... data to create a AuthProvider
     *   }
     * })
     * 
     */
    create<T extends AuthProviderCreateArgs>(args: SelectSubset<T, AuthProviderCreateArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthProviders.
     * @param {AuthProviderCreateManyArgs} args - Arguments to create many AuthProviders.
     * @example
     * // Create many AuthProviders
     * const authProvider = await prisma.authProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthProviderCreateManyArgs>(args?: SelectSubset<T, AuthProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthProviders and returns the data saved in the database.
     * @param {AuthProviderCreateManyAndReturnArgs} args - Arguments to create many AuthProviders.
     * @example
     * // Create many AuthProviders
     * const authProvider = await prisma.authProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthProviders and only return the `id`
     * const authProviderWithIdOnly = await prisma.authProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthProvider.
     * @param {AuthProviderDeleteArgs} args - Arguments to delete one AuthProvider.
     * @example
     * // Delete one AuthProvider
     * const AuthProvider = await prisma.authProvider.delete({
     *   where: {
     *     // ... filter to delete one AuthProvider
     *   }
     * })
     * 
     */
    delete<T extends AuthProviderDeleteArgs>(args: SelectSubset<T, AuthProviderDeleteArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthProvider.
     * @param {AuthProviderUpdateArgs} args - Arguments to update one AuthProvider.
     * @example
     * // Update one AuthProvider
     * const authProvider = await prisma.authProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthProviderUpdateArgs>(args: SelectSubset<T, AuthProviderUpdateArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthProviders.
     * @param {AuthProviderDeleteManyArgs} args - Arguments to filter AuthProviders to delete.
     * @example
     * // Delete a few AuthProviders
     * const { count } = await prisma.authProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthProviderDeleteManyArgs>(args?: SelectSubset<T, AuthProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthProviders
     * const authProvider = await prisma.authProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthProviderUpdateManyArgs>(args: SelectSubset<T, AuthProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthProviders and returns the data updated in the database.
     * @param {AuthProviderUpdateManyAndReturnArgs} args - Arguments to update many AuthProviders.
     * @example
     * // Update many AuthProviders
     * const authProvider = await prisma.authProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthProviders and only return the `id`
     * const authProviderWithIdOnly = await prisma.authProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthProvider.
     * @param {AuthProviderUpsertArgs} args - Arguments to update or create a AuthProvider.
     * @example
     * // Update or create a AuthProvider
     * const authProvider = await prisma.authProvider.upsert({
     *   create: {
     *     // ... data to create a AuthProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthProvider we want to update
     *   }
     * })
     */
    upsert<T extends AuthProviderUpsertArgs>(args: SelectSubset<T, AuthProviderUpsertArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderCountArgs} args - Arguments to filter AuthProviders to count.
     * @example
     * // Count the number of AuthProviders
     * const count = await prisma.authProvider.count({
     *   where: {
     *     // ... the filter for the AuthProviders we want to count
     *   }
     * })
    **/
    count<T extends AuthProviderCountArgs>(
      args?: Subset<T, AuthProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthProviderAggregateArgs>(args: Subset<T, AuthProviderAggregateArgs>): Prisma.PrismaPromise<GetAuthProviderAggregateType<T>>

    /**
     * Group by AuthProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthProviderGroupByArgs['orderBy'] }
        : { orderBy?: AuthProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthProvider model
   */
  readonly fields: AuthProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthProvider model
   */
  interface AuthProviderFieldRefs {
    readonly id: FieldRef<"AuthProvider", 'String'>
    readonly userId: FieldRef<"AuthProvider", 'String'>
    readonly provider: FieldRef<"AuthProvider", 'String'>
    readonly providerAccountId: FieldRef<"AuthProvider", 'String'>
    readonly passwordHash: FieldRef<"AuthProvider", 'String'>
    readonly oauthData: FieldRef<"AuthProvider", 'Json'>
    readonly createdAt: FieldRef<"AuthProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthProvider findUnique
   */
  export type AuthProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider findUniqueOrThrow
   */
  export type AuthProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider findFirst
   */
  export type AuthProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthProviders.
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthProviders.
     */
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * AuthProvider findFirstOrThrow
   */
  export type AuthProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthProviders.
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthProviders.
     */
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * AuthProvider findMany
   */
  export type AuthProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProviders to fetch.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthProviders.
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * AuthProvider create
   */
  export type AuthProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthProvider.
     */
    data: XOR<AuthProviderCreateInput, AuthProviderUncheckedCreateInput>
  }

  /**
   * AuthProvider createMany
   */
  export type AuthProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthProviders.
     */
    data: AuthProviderCreateManyInput | AuthProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthProvider createManyAndReturn
   */
  export type AuthProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * The data used to create many AuthProviders.
     */
    data: AuthProviderCreateManyInput | AuthProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthProvider update
   */
  export type AuthProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthProvider.
     */
    data: XOR<AuthProviderUpdateInput, AuthProviderUncheckedUpdateInput>
    /**
     * Choose, which AuthProvider to update.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider updateMany
   */
  export type AuthProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthProviders.
     */
    data: XOR<AuthProviderUpdateManyMutationInput, AuthProviderUncheckedUpdateManyInput>
    /**
     * Filter which AuthProviders to update
     */
    where?: AuthProviderWhereInput
    /**
     * Limit how many AuthProviders to update.
     */
    limit?: number
  }

  /**
   * AuthProvider updateManyAndReturn
   */
  export type AuthProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * The data used to update AuthProviders.
     */
    data: XOR<AuthProviderUpdateManyMutationInput, AuthProviderUncheckedUpdateManyInput>
    /**
     * Filter which AuthProviders to update
     */
    where?: AuthProviderWhereInput
    /**
     * Limit how many AuthProviders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthProvider upsert
   */
  export type AuthProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthProvider to update in case it exists.
     */
    where: AuthProviderWhereUniqueInput
    /**
     * In case the AuthProvider found by the `where` argument doesn't exist, create a new AuthProvider with this data.
     */
    create: XOR<AuthProviderCreateInput, AuthProviderUncheckedCreateInput>
    /**
     * In case the AuthProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthProviderUpdateInput, AuthProviderUncheckedUpdateInput>
  }

  /**
   * AuthProvider delete
   */
  export type AuthProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter which AuthProvider to delete.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider deleteMany
   */
  export type AuthProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthProviders to delete
     */
    where?: AuthProviderWhereInput
    /**
     * Limit how many AuthProviders to delete.
     */
    limit?: number
  }

  /**
   * AuthProvider without action
   */
  export type AuthProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthProvider
     */
    omit?: AuthProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    minSampleMass: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    minSampleMass: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    category: $Enums.service_category_enum | null
    isActive: boolean | null
    requiresSample: boolean | null
    minSampleMass: Decimal | null
    operatingHours: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    category: $Enums.service_category_enum | null
    isActive: boolean | null
    requiresSample: boolean | null
    minSampleMass: Decimal | null
    operatingHours: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    category: number
    isActive: number
    requiresSample: number
    minSampleMass: number
    operatingHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    minSampleMass?: true
  }

  export type ServiceSumAggregateInputType = {
    minSampleMass?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    requiresSample?: true
    minSampleMass?: true
    operatingHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    requiresSample?: true
    minSampleMass?: true
    operatingHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    isActive?: true
    requiresSample?: true
    minSampleMass?: true
    operatingHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    category: $Enums.service_category_enum
    isActive: boolean
    requiresSample: boolean
    minSampleMass: Decimal | null
    operatingHours: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pricing?: boolean | Service$pricingArgs<ExtArgs>
    bookingItems?: boolean | Service$bookingItemsArgs<ExtArgs>
    addOnMappings?: boolean | Service$addOnMappingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: boolean
    operatingHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "category" | "isActive" | "requiresSample" | "minSampleMass" | "operatingHours" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricing?: boolean | Service$pricingArgs<ExtArgs>
    bookingItems?: boolean | Service$bookingItemsArgs<ExtArgs>
    addOnMappings?: boolean | Service$addOnMappingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      pricing: Prisma.$ServicePricingPayload<ExtArgs>[]
      bookingItems: Prisma.$BookingServiceItemPayload<ExtArgs>[]
      addOnMappings: Prisma.$ServiceAddOnMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      category: $Enums.service_category_enum
      isActive: boolean
      requiresSample: boolean
      minSampleMass: Prisma.Decimal | null
      operatingHours: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pricing<T extends Service$pricingArgs<ExtArgs> = {}>(args?: Subset<T, Service$pricingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingItems<T extends Service$bookingItemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addOnMappings<T extends Service$addOnMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$addOnMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly code: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'service_category_enum'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly requiresSample: FieldRef<"Service", 'Boolean'>
    readonly minSampleMass: FieldRef<"Service", 'Decimal'>
    readonly operatingHours: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.pricing
   */
  export type Service$pricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    where?: ServicePricingWhereInput
    orderBy?: ServicePricingOrderByWithRelationInput | ServicePricingOrderByWithRelationInput[]
    cursor?: ServicePricingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePricingScalarFieldEnum | ServicePricingScalarFieldEnum[]
  }

  /**
   * Service.bookingItems
   */
  export type Service$bookingItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    where?: BookingServiceItemWhereInput
    orderBy?: BookingServiceItemOrderByWithRelationInput | BookingServiceItemOrderByWithRelationInput[]
    cursor?: BookingServiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceItemScalarFieldEnum | BookingServiceItemScalarFieldEnum[]
  }

  /**
   * Service.addOnMappings
   */
  export type Service$addOnMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    where?: ServiceAddOnMappingWhereInput
    orderBy?: ServiceAddOnMappingOrderByWithRelationInput | ServiceAddOnMappingOrderByWithRelationInput[]
    cursor?: ServiceAddOnMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAddOnMappingScalarFieldEnum | ServiceAddOnMappingScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServicePricing
   */

  export type AggregateServicePricing = {
    _count: ServicePricingCountAggregateOutputType | null
    _avg: ServicePricingAvgAggregateOutputType | null
    _sum: ServicePricingSumAggregateOutputType | null
    _min: ServicePricingMinAggregateOutputType | null
    _max: ServicePricingMaxAggregateOutputType | null
  }

  export type ServicePricingAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ServicePricingSumAggregateOutputType = {
    price: Decimal | null
  }

  export type ServicePricingMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    userType: $Enums.user_type_enum | null
    price: Decimal | null
    unit: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicePricingMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    userType: $Enums.user_type_enum | null
    price: Decimal | null
    unit: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicePricingCountAggregateOutputType = {
    id: number
    serviceId: number
    userType: number
    price: number
    unit: number
    effectiveFrom: number
    effectiveTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicePricingAvgAggregateInputType = {
    price?: true
  }

  export type ServicePricingSumAggregateInputType = {
    price?: true
  }

  export type ServicePricingMinAggregateInputType = {
    id?: true
    serviceId?: true
    userType?: true
    price?: true
    unit?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicePricingMaxAggregateInputType = {
    id?: true
    serviceId?: true
    userType?: true
    price?: true
    unit?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicePricingCountAggregateInputType = {
    id?: true
    serviceId?: true
    userType?: true
    price?: true
    unit?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicePricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePricing to aggregate.
     */
    where?: ServicePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricings to fetch.
     */
    orderBy?: ServicePricingOrderByWithRelationInput | ServicePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePricings
    **/
    _count?: true | ServicePricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePricingMaxAggregateInputType
  }

  export type GetServicePricingAggregateType<T extends ServicePricingAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePricing[P]>
      : GetScalarType<T[P], AggregateServicePricing[P]>
  }




  export type ServicePricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePricingWhereInput
    orderBy?: ServicePricingOrderByWithAggregationInput | ServicePricingOrderByWithAggregationInput[]
    by: ServicePricingScalarFieldEnum[] | ServicePricingScalarFieldEnum
    having?: ServicePricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePricingCountAggregateInputType | true
    _avg?: ServicePricingAvgAggregateInputType
    _sum?: ServicePricingSumAggregateInputType
    _min?: ServicePricingMinAggregateInputType
    _max?: ServicePricingMaxAggregateInputType
  }

  export type ServicePricingGroupByOutputType = {
    id: string
    serviceId: string
    userType: $Enums.user_type_enum
    price: Decimal
    unit: string
    effectiveFrom: Date
    effectiveTo: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ServicePricingCountAggregateOutputType | null
    _avg: ServicePricingAvgAggregateOutputType | null
    _sum: ServicePricingSumAggregateOutputType | null
    _min: ServicePricingMinAggregateOutputType | null
    _max: ServicePricingMaxAggregateOutputType | null
  }

  type GetServicePricingGroupByPayload<T extends ServicePricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePricingGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePricingGroupByOutputType[P]>
        }
      >
    >


  export type ServicePricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userType?: boolean
    price?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePricing"]>

  export type ServicePricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userType?: boolean
    price?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePricing"]>

  export type ServicePricingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userType?: boolean
    price?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePricing"]>

  export type ServicePricingSelectScalar = {
    id?: boolean
    serviceId?: boolean
    userType?: boolean
    price?: boolean
    unit?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicePricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "userType" | "price" | "unit" | "effectiveFrom" | "effectiveTo" | "createdAt" | "updatedAt", ExtArgs["result"]["servicePricing"]>
  export type ServicePricingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServicePricingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServicePricingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServicePricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePricing"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      userType: $Enums.user_type_enum
      price: Prisma.Decimal
      unit: string
      effectiveFrom: Date
      effectiveTo: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicePricing"]>
    composites: {}
  }

  type ServicePricingGetPayload<S extends boolean | null | undefined | ServicePricingDefaultArgs> = $Result.GetResult<Prisma.$ServicePricingPayload, S>

  type ServicePricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicePricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicePricingCountAggregateInputType | true
    }

  export interface ServicePricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePricing'], meta: { name: 'ServicePricing' } }
    /**
     * Find zero or one ServicePricing that matches the filter.
     * @param {ServicePricingFindUniqueArgs} args - Arguments to find a ServicePricing
     * @example
     * // Get one ServicePricing
     * const servicePricing = await prisma.servicePricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePricingFindUniqueArgs>(args: SelectSubset<T, ServicePricingFindUniqueArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicePricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicePricingFindUniqueOrThrowArgs} args - Arguments to find a ServicePricing
     * @example
     * // Get one ServicePricing
     * const servicePricing = await prisma.servicePricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePricingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingFindFirstArgs} args - Arguments to find a ServicePricing
     * @example
     * // Get one ServicePricing
     * const servicePricing = await prisma.servicePricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePricingFindFirstArgs>(args?: SelectSubset<T, ServicePricingFindFirstArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingFindFirstOrThrowArgs} args - Arguments to find a ServicePricing
     * @example
     * // Get one ServicePricing
     * const servicePricing = await prisma.servicePricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePricingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicePricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePricings
     * const servicePricings = await prisma.servicePricing.findMany()
     * 
     * // Get first 10 ServicePricings
     * const servicePricings = await prisma.servicePricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePricingWithIdOnly = await prisma.servicePricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePricingFindManyArgs>(args?: SelectSubset<T, ServicePricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicePricing.
     * @param {ServicePricingCreateArgs} args - Arguments to create a ServicePricing.
     * @example
     * // Create one ServicePricing
     * const ServicePricing = await prisma.servicePricing.create({
     *   data: {
     *     // ... data to create a ServicePricing
     *   }
     * })
     * 
     */
    create<T extends ServicePricingCreateArgs>(args: SelectSubset<T, ServicePricingCreateArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicePricings.
     * @param {ServicePricingCreateManyArgs} args - Arguments to create many ServicePricings.
     * @example
     * // Create many ServicePricings
     * const servicePricing = await prisma.servicePricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePricingCreateManyArgs>(args?: SelectSubset<T, ServicePricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePricings and returns the data saved in the database.
     * @param {ServicePricingCreateManyAndReturnArgs} args - Arguments to create many ServicePricings.
     * @example
     * // Create many ServicePricings
     * const servicePricing = await prisma.servicePricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePricings and only return the `id`
     * const servicePricingWithIdOnly = await prisma.servicePricing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePricingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicePricing.
     * @param {ServicePricingDeleteArgs} args - Arguments to delete one ServicePricing.
     * @example
     * // Delete one ServicePricing
     * const ServicePricing = await prisma.servicePricing.delete({
     *   where: {
     *     // ... filter to delete one ServicePricing
     *   }
     * })
     * 
     */
    delete<T extends ServicePricingDeleteArgs>(args: SelectSubset<T, ServicePricingDeleteArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicePricing.
     * @param {ServicePricingUpdateArgs} args - Arguments to update one ServicePricing.
     * @example
     * // Update one ServicePricing
     * const servicePricing = await prisma.servicePricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePricingUpdateArgs>(args: SelectSubset<T, ServicePricingUpdateArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicePricings.
     * @param {ServicePricingDeleteManyArgs} args - Arguments to filter ServicePricings to delete.
     * @example
     * // Delete a few ServicePricings
     * const { count } = await prisma.servicePricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePricingDeleteManyArgs>(args?: SelectSubset<T, ServicePricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePricings
     * const servicePricing = await prisma.servicePricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePricingUpdateManyArgs>(args: SelectSubset<T, ServicePricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePricings and returns the data updated in the database.
     * @param {ServicePricingUpdateManyAndReturnArgs} args - Arguments to update many ServicePricings.
     * @example
     * // Update many ServicePricings
     * const servicePricing = await prisma.servicePricing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicePricings and only return the `id`
     * const servicePricingWithIdOnly = await prisma.servicePricing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicePricingUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicePricingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicePricing.
     * @param {ServicePricingUpsertArgs} args - Arguments to update or create a ServicePricing.
     * @example
     * // Update or create a ServicePricing
     * const servicePricing = await prisma.servicePricing.upsert({
     *   create: {
     *     // ... data to create a ServicePricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePricing we want to update
     *   }
     * })
     */
    upsert<T extends ServicePricingUpsertArgs>(args: SelectSubset<T, ServicePricingUpsertArgs<ExtArgs>>): Prisma__ServicePricingClient<$Result.GetResult<Prisma.$ServicePricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicePricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingCountArgs} args - Arguments to filter ServicePricings to count.
     * @example
     * // Count the number of ServicePricings
     * const count = await prisma.servicePricing.count({
     *   where: {
     *     // ... the filter for the ServicePricings we want to count
     *   }
     * })
    **/
    count<T extends ServicePricingCountArgs>(
      args?: Subset<T, ServicePricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePricingAggregateArgs>(args: Subset<T, ServicePricingAggregateArgs>): Prisma.PrismaPromise<GetServicePricingAggregateType<T>>

    /**
     * Group by ServicePricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePricingGroupByArgs['orderBy'] }
        : { orderBy?: ServicePricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePricing model
   */
  readonly fields: ServicePricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePricing model
   */
  interface ServicePricingFieldRefs {
    readonly id: FieldRef<"ServicePricing", 'String'>
    readonly serviceId: FieldRef<"ServicePricing", 'String'>
    readonly userType: FieldRef<"ServicePricing", 'user_type_enum'>
    readonly price: FieldRef<"ServicePricing", 'Decimal'>
    readonly unit: FieldRef<"ServicePricing", 'String'>
    readonly effectiveFrom: FieldRef<"ServicePricing", 'DateTime'>
    readonly effectiveTo: FieldRef<"ServicePricing", 'DateTime'>
    readonly createdAt: FieldRef<"ServicePricing", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicePricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePricing findUnique
   */
  export type ServicePricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricing to fetch.
     */
    where: ServicePricingWhereUniqueInput
  }

  /**
   * ServicePricing findUniqueOrThrow
   */
  export type ServicePricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricing to fetch.
     */
    where: ServicePricingWhereUniqueInput
  }

  /**
   * ServicePricing findFirst
   */
  export type ServicePricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricing to fetch.
     */
    where?: ServicePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricings to fetch.
     */
    orderBy?: ServicePricingOrderByWithRelationInput | ServicePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePricings.
     */
    cursor?: ServicePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePricings.
     */
    distinct?: ServicePricingScalarFieldEnum | ServicePricingScalarFieldEnum[]
  }

  /**
   * ServicePricing findFirstOrThrow
   */
  export type ServicePricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricing to fetch.
     */
    where?: ServicePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricings to fetch.
     */
    orderBy?: ServicePricingOrderByWithRelationInput | ServicePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePricings.
     */
    cursor?: ServicePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePricings.
     */
    distinct?: ServicePricingScalarFieldEnum | ServicePricingScalarFieldEnum[]
  }

  /**
   * ServicePricing findMany
   */
  export type ServicePricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricings to fetch.
     */
    where?: ServicePricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricings to fetch.
     */
    orderBy?: ServicePricingOrderByWithRelationInput | ServicePricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePricings.
     */
    cursor?: ServicePricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricings.
     */
    skip?: number
    distinct?: ServicePricingScalarFieldEnum | ServicePricingScalarFieldEnum[]
  }

  /**
   * ServicePricing create
   */
  export type ServicePricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePricing.
     */
    data: XOR<ServicePricingCreateInput, ServicePricingUncheckedCreateInput>
  }

  /**
   * ServicePricing createMany
   */
  export type ServicePricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePricings.
     */
    data: ServicePricingCreateManyInput | ServicePricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePricing createManyAndReturn
   */
  export type ServicePricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * The data used to create many ServicePricings.
     */
    data: ServicePricingCreateManyInput | ServicePricingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePricing update
   */
  export type ServicePricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePricing.
     */
    data: XOR<ServicePricingUpdateInput, ServicePricingUncheckedUpdateInput>
    /**
     * Choose, which ServicePricing to update.
     */
    where: ServicePricingWhereUniqueInput
  }

  /**
   * ServicePricing updateMany
   */
  export type ServicePricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePricings.
     */
    data: XOR<ServicePricingUpdateManyMutationInput, ServicePricingUncheckedUpdateManyInput>
    /**
     * Filter which ServicePricings to update
     */
    where?: ServicePricingWhereInput
    /**
     * Limit how many ServicePricings to update.
     */
    limit?: number
  }

  /**
   * ServicePricing updateManyAndReturn
   */
  export type ServicePricingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * The data used to update ServicePricings.
     */
    data: XOR<ServicePricingUpdateManyMutationInput, ServicePricingUncheckedUpdateManyInput>
    /**
     * Filter which ServicePricings to update
     */
    where?: ServicePricingWhereInput
    /**
     * Limit how many ServicePricings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePricing upsert
   */
  export type ServicePricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePricing to update in case it exists.
     */
    where: ServicePricingWhereUniqueInput
    /**
     * In case the ServicePricing found by the `where` argument doesn't exist, create a new ServicePricing with this data.
     */
    create: XOR<ServicePricingCreateInput, ServicePricingUncheckedCreateInput>
    /**
     * In case the ServicePricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePricingUpdateInput, ServicePricingUncheckedUpdateInput>
  }

  /**
   * ServicePricing delete
   */
  export type ServicePricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
    /**
     * Filter which ServicePricing to delete.
     */
    where: ServicePricingWhereUniqueInput
  }

  /**
   * ServicePricing deleteMany
   */
  export type ServicePricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePricings to delete
     */
    where?: ServicePricingWhereInput
    /**
     * Limit how many ServicePricings to delete.
     */
    limit?: number
  }

  /**
   * ServicePricing without action
   */
  export type ServicePricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricing
     */
    select?: ServicePricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricing
     */
    omit?: ServicePricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingInclude<ExtArgs> | null
  }


  /**
   * Model BookingRequest
   */

  export type AggregateBookingRequest = {
    _count: BookingRequestCountAggregateOutputType | null
    _avg: BookingRequestAvgAggregateOutputType | null
    _sum: BookingRequestSumAggregateOutputType | null
    _min: BookingRequestMinAggregateOutputType | null
    _max: BookingRequestMaxAggregateOutputType | null
  }

  export type BookingRequestAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type BookingRequestSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type BookingRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    referenceNumber: string | null
    projectDescription: string | null
    preferredStartDate: Date | null
    preferredEndDate: Date | null
    totalAmount: Decimal | null
    status: $Enums.booking_status_enum | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    companyId: string | null
    companyBranchId: string | null
  }

  export type BookingRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    referenceNumber: string | null
    projectDescription: string | null
    preferredStartDate: Date | null
    preferredEndDate: Date | null
    totalAmount: Decimal | null
    status: $Enums.booking_status_enum | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    companyId: string | null
    companyBranchId: string | null
  }

  export type BookingRequestCountAggregateOutputType = {
    id: number
    userId: number
    referenceNumber: number
    projectDescription: number
    preferredStartDate: number
    preferredEndDate: number
    totalAmount: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    reviewedAt: number
    reviewedBy: number
    reviewNotes: number
    companyId: number
    companyBranchId: number
    _all: number
  }


  export type BookingRequestAvgAggregateInputType = {
    totalAmount?: true
  }

  export type BookingRequestSumAggregateInputType = {
    totalAmount?: true
  }

  export type BookingRequestMinAggregateInputType = {
    id?: true
    userId?: true
    referenceNumber?: true
    projectDescription?: true
    preferredStartDate?: true
    preferredEndDate?: true
    totalAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    companyId?: true
    companyBranchId?: true
  }

  export type BookingRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    referenceNumber?: true
    projectDescription?: true
    preferredStartDate?: true
    preferredEndDate?: true
    totalAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    companyId?: true
    companyBranchId?: true
  }

  export type BookingRequestCountAggregateInputType = {
    id?: true
    userId?: true
    referenceNumber?: true
    projectDescription?: true
    preferredStartDate?: true
    preferredEndDate?: true
    totalAmount?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    reviewNotes?: true
    companyId?: true
    companyBranchId?: true
    _all?: true
  }

  export type BookingRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRequest to aggregate.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingRequests
    **/
    _count?: true | BookingRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingRequestMaxAggregateInputType
  }

  export type GetBookingRequestAggregateType<T extends BookingRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingRequest[P]>
      : GetScalarType<T[P], AggregateBookingRequest[P]>
  }




  export type BookingRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithAggregationInput | BookingRequestOrderByWithAggregationInput[]
    by: BookingRequestScalarFieldEnum[] | BookingRequestScalarFieldEnum
    having?: BookingRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingRequestCountAggregateInputType | true
    _avg?: BookingRequestAvgAggregateInputType
    _sum?: BookingRequestSumAggregateInputType
    _min?: BookingRequestMinAggregateInputType
    _max?: BookingRequestMaxAggregateInputType
  }

  export type BookingRequestGroupByOutputType = {
    id: string
    userId: string
    referenceNumber: string
    projectDescription: string | null
    preferredStartDate: Date | null
    preferredEndDate: Date | null
    totalAmount: Decimal
    status: $Enums.booking_status_enum
    notes: string | null
    createdAt: Date
    updatedAt: Date
    reviewedAt: Date | null
    reviewedBy: string | null
    reviewNotes: string | null
    companyId: string | null
    companyBranchId: string | null
    _count: BookingRequestCountAggregateOutputType | null
    _avg: BookingRequestAvgAggregateOutputType | null
    _sum: BookingRequestSumAggregateOutputType | null
    _min: BookingRequestMinAggregateOutputType | null
    _max: BookingRequestMaxAggregateOutputType | null
  }

  type GetBookingRequestGroupByPayload<T extends BookingRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingRequestGroupByOutputType[P]>
            : GetScalarType<T[P], BookingRequestGroupByOutputType[P]>
        }
      >
    >


  export type BookingRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referenceNumber?: boolean
    projectDescription?: boolean
    preferredStartDate?: boolean
    preferredEndDate?: boolean
    totalAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedByUser?: boolean | BookingRequest$reviewedByUserArgs<ExtArgs>
    companyRelation?: boolean | BookingRequest$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | BookingRequest$companyBranchArgs<ExtArgs>
    serviceItems?: boolean | BookingRequest$serviceItemsArgs<ExtArgs>
    workspaceBookings?: boolean | BookingRequest$workspaceBookingsArgs<ExtArgs>
    serviceForms?: boolean | BookingRequest$serviceFormsArgs<ExtArgs>
    _count?: boolean | BookingRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequest"]>

  export type BookingRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referenceNumber?: boolean
    projectDescription?: boolean
    preferredStartDate?: boolean
    preferredEndDate?: boolean
    totalAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedByUser?: boolean | BookingRequest$reviewedByUserArgs<ExtArgs>
    companyRelation?: boolean | BookingRequest$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | BookingRequest$companyBranchArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequest"]>

  export type BookingRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    referenceNumber?: boolean
    projectDescription?: boolean
    preferredStartDate?: boolean
    preferredEndDate?: boolean
    totalAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    companyId?: boolean
    companyBranchId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedByUser?: boolean | BookingRequest$reviewedByUserArgs<ExtArgs>
    companyRelation?: boolean | BookingRequest$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | BookingRequest$companyBranchArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequest"]>

  export type BookingRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    referenceNumber?: boolean
    projectDescription?: boolean
    preferredStartDate?: boolean
    preferredEndDate?: boolean
    totalAmount?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    reviewNotes?: boolean
    companyId?: boolean
    companyBranchId?: boolean
  }

  export type BookingRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "referenceNumber" | "projectDescription" | "preferredStartDate" | "preferredEndDate" | "totalAmount" | "status" | "notes" | "createdAt" | "updatedAt" | "reviewedAt" | "reviewedBy" | "reviewNotes" | "companyId" | "companyBranchId", ExtArgs["result"]["bookingRequest"]>
  export type BookingRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedByUser?: boolean | BookingRequest$reviewedByUserArgs<ExtArgs>
    companyRelation?: boolean | BookingRequest$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | BookingRequest$companyBranchArgs<ExtArgs>
    serviceItems?: boolean | BookingRequest$serviceItemsArgs<ExtArgs>
    workspaceBookings?: boolean | BookingRequest$workspaceBookingsArgs<ExtArgs>
    serviceForms?: boolean | BookingRequest$serviceFormsArgs<ExtArgs>
    _count?: boolean | BookingRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedByUser?: boolean | BookingRequest$reviewedByUserArgs<ExtArgs>
    companyRelation?: boolean | BookingRequest$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | BookingRequest$companyBranchArgs<ExtArgs>
  }
  export type BookingRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    reviewedByUser?: boolean | BookingRequest$reviewedByUserArgs<ExtArgs>
    companyRelation?: boolean | BookingRequest$companyRelationArgs<ExtArgs>
    companyBranch?: boolean | BookingRequest$companyBranchArgs<ExtArgs>
  }

  export type $BookingRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      reviewedByUser: Prisma.$UserPayload<ExtArgs> | null
      companyRelation: Prisma.$CompanyPayload<ExtArgs> | null
      companyBranch: Prisma.$CompanyBranchPayload<ExtArgs> | null
      serviceItems: Prisma.$BookingServiceItemPayload<ExtArgs>[]
      workspaceBookings: Prisma.$WorkspaceBookingPayload<ExtArgs>[]
      serviceForms: Prisma.$ServiceFormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      referenceNumber: string
      projectDescription: string | null
      preferredStartDate: Date | null
      preferredEndDate: Date | null
      totalAmount: Prisma.Decimal
      status: $Enums.booking_status_enum
      notes: string | null
      createdAt: Date
      updatedAt: Date
      reviewedAt: Date | null
      reviewedBy: string | null
      reviewNotes: string | null
      companyId: string | null
      companyBranchId: string | null
    }, ExtArgs["result"]["bookingRequest"]>
    composites: {}
  }

  type BookingRequestGetPayload<S extends boolean | null | undefined | BookingRequestDefaultArgs> = $Result.GetResult<Prisma.$BookingRequestPayload, S>

  type BookingRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingRequestCountAggregateInputType | true
    }

  export interface BookingRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingRequest'], meta: { name: 'BookingRequest' } }
    /**
     * Find zero or one BookingRequest that matches the filter.
     * @param {BookingRequestFindUniqueArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingRequestFindUniqueArgs>(args: SelectSubset<T, BookingRequestFindUniqueArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingRequestFindUniqueOrThrowArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestFindFirstArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingRequestFindFirstArgs>(args?: SelectSubset<T, BookingRequestFindFirstArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestFindFirstOrThrowArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingRequests
     * const bookingRequests = await prisma.bookingRequest.findMany()
     * 
     * // Get first 10 BookingRequests
     * const bookingRequests = await prisma.bookingRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingRequestWithIdOnly = await prisma.bookingRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingRequestFindManyArgs>(args?: SelectSubset<T, BookingRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingRequest.
     * @param {BookingRequestCreateArgs} args - Arguments to create a BookingRequest.
     * @example
     * // Create one BookingRequest
     * const BookingRequest = await prisma.bookingRequest.create({
     *   data: {
     *     // ... data to create a BookingRequest
     *   }
     * })
     * 
     */
    create<T extends BookingRequestCreateArgs>(args: SelectSubset<T, BookingRequestCreateArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingRequests.
     * @param {BookingRequestCreateManyArgs} args - Arguments to create many BookingRequests.
     * @example
     * // Create many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingRequestCreateManyArgs>(args?: SelectSubset<T, BookingRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingRequests and returns the data saved in the database.
     * @param {BookingRequestCreateManyAndReturnArgs} args - Arguments to create many BookingRequests.
     * @example
     * // Create many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingRequests and only return the `id`
     * const bookingRequestWithIdOnly = await prisma.bookingRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingRequest.
     * @param {BookingRequestDeleteArgs} args - Arguments to delete one BookingRequest.
     * @example
     * // Delete one BookingRequest
     * const BookingRequest = await prisma.bookingRequest.delete({
     *   where: {
     *     // ... filter to delete one BookingRequest
     *   }
     * })
     * 
     */
    delete<T extends BookingRequestDeleteArgs>(args: SelectSubset<T, BookingRequestDeleteArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingRequest.
     * @param {BookingRequestUpdateArgs} args - Arguments to update one BookingRequest.
     * @example
     * // Update one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingRequestUpdateArgs>(args: SelectSubset<T, BookingRequestUpdateArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingRequests.
     * @param {BookingRequestDeleteManyArgs} args - Arguments to filter BookingRequests to delete.
     * @example
     * // Delete a few BookingRequests
     * const { count } = await prisma.bookingRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingRequestDeleteManyArgs>(args?: SelectSubset<T, BookingRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingRequestUpdateManyArgs>(args: SelectSubset<T, BookingRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRequests and returns the data updated in the database.
     * @param {BookingRequestUpdateManyAndReturnArgs} args - Arguments to update many BookingRequests.
     * @example
     * // Update many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingRequests and only return the `id`
     * const bookingRequestWithIdOnly = await prisma.bookingRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingRequest.
     * @param {BookingRequestUpsertArgs} args - Arguments to update or create a BookingRequest.
     * @example
     * // Update or create a BookingRequest
     * const bookingRequest = await prisma.bookingRequest.upsert({
     *   create: {
     *     // ... data to create a BookingRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingRequest we want to update
     *   }
     * })
     */
    upsert<T extends BookingRequestUpsertArgs>(args: SelectSubset<T, BookingRequestUpsertArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestCountArgs} args - Arguments to filter BookingRequests to count.
     * @example
     * // Count the number of BookingRequests
     * const count = await prisma.bookingRequest.count({
     *   where: {
     *     // ... the filter for the BookingRequests we want to count
     *   }
     * })
    **/
    count<T extends BookingRequestCountArgs>(
      args?: Subset<T, BookingRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingRequestAggregateArgs>(args: Subset<T, BookingRequestAggregateArgs>): Prisma.PrismaPromise<GetBookingRequestAggregateType<T>>

    /**
     * Group by BookingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingRequestGroupByArgs['orderBy'] }
        : { orderBy?: BookingRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingRequest model
   */
  readonly fields: BookingRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewedByUser<T extends BookingRequest$reviewedByUserArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequest$reviewedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companyRelation<T extends BookingRequest$companyRelationArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequest$companyRelationArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companyBranch<T extends BookingRequest$companyBranchArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequest$companyBranchArgs<ExtArgs>>): Prisma__CompanyBranchClient<$Result.GetResult<Prisma.$CompanyBranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    serviceItems<T extends BookingRequest$serviceItemsArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequest$serviceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspaceBookings<T extends BookingRequest$workspaceBookingsArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequest$workspaceBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceForms<T extends BookingRequest$serviceFormsArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequest$serviceFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingRequest model
   */
  interface BookingRequestFieldRefs {
    readonly id: FieldRef<"BookingRequest", 'String'>
    readonly userId: FieldRef<"BookingRequest", 'String'>
    readonly referenceNumber: FieldRef<"BookingRequest", 'String'>
    readonly projectDescription: FieldRef<"BookingRequest", 'String'>
    readonly preferredStartDate: FieldRef<"BookingRequest", 'DateTime'>
    readonly preferredEndDate: FieldRef<"BookingRequest", 'DateTime'>
    readonly totalAmount: FieldRef<"BookingRequest", 'Decimal'>
    readonly status: FieldRef<"BookingRequest", 'booking_status_enum'>
    readonly notes: FieldRef<"BookingRequest", 'String'>
    readonly createdAt: FieldRef<"BookingRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingRequest", 'DateTime'>
    readonly reviewedAt: FieldRef<"BookingRequest", 'DateTime'>
    readonly reviewedBy: FieldRef<"BookingRequest", 'String'>
    readonly reviewNotes: FieldRef<"BookingRequest", 'String'>
    readonly companyId: FieldRef<"BookingRequest", 'String'>
    readonly companyBranchId: FieldRef<"BookingRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookingRequest findUnique
   */
  export type BookingRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest findUniqueOrThrow
   */
  export type BookingRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest findFirst
   */
  export type BookingRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRequests.
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRequests.
     */
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * BookingRequest findFirstOrThrow
   */
  export type BookingRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRequests.
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRequests.
     */
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * BookingRequest findMany
   */
  export type BookingRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequests to fetch.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingRequests.
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * BookingRequest create
   */
  export type BookingRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingRequest.
     */
    data: XOR<BookingRequestCreateInput, BookingRequestUncheckedCreateInput>
  }

  /**
   * BookingRequest createMany
   */
  export type BookingRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingRequests.
     */
    data: BookingRequestCreateManyInput | BookingRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingRequest createManyAndReturn
   */
  export type BookingRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * The data used to create many BookingRequests.
     */
    data: BookingRequestCreateManyInput | BookingRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRequest update
   */
  export type BookingRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingRequest.
     */
    data: XOR<BookingRequestUpdateInput, BookingRequestUncheckedUpdateInput>
    /**
     * Choose, which BookingRequest to update.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest updateMany
   */
  export type BookingRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingRequests.
     */
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyInput>
    /**
     * Filter which BookingRequests to update
     */
    where?: BookingRequestWhereInput
    /**
     * Limit how many BookingRequests to update.
     */
    limit?: number
  }

  /**
   * BookingRequest updateManyAndReturn
   */
  export type BookingRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * The data used to update BookingRequests.
     */
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyInput>
    /**
     * Filter which BookingRequests to update
     */
    where?: BookingRequestWhereInput
    /**
     * Limit how many BookingRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRequest upsert
   */
  export type BookingRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingRequest to update in case it exists.
     */
    where: BookingRequestWhereUniqueInput
    /**
     * In case the BookingRequest found by the `where` argument doesn't exist, create a new BookingRequest with this data.
     */
    create: XOR<BookingRequestCreateInput, BookingRequestUncheckedCreateInput>
    /**
     * In case the BookingRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingRequestUpdateInput, BookingRequestUncheckedUpdateInput>
  }

  /**
   * BookingRequest delete
   */
  export type BookingRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter which BookingRequest to delete.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest deleteMany
   */
  export type BookingRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRequests to delete
     */
    where?: BookingRequestWhereInput
    /**
     * Limit how many BookingRequests to delete.
     */
    limit?: number
  }

  /**
   * BookingRequest.reviewedByUser
   */
  export type BookingRequest$reviewedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BookingRequest.companyRelation
   */
  export type BookingRequest$companyRelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * BookingRequest.companyBranch
   */
  export type BookingRequest$companyBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBranch
     */
    select?: CompanyBranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBranch
     */
    omit?: CompanyBranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBranchInclude<ExtArgs> | null
    where?: CompanyBranchWhereInput
  }

  /**
   * BookingRequest.serviceItems
   */
  export type BookingRequest$serviceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    where?: BookingServiceItemWhereInput
    orderBy?: BookingServiceItemOrderByWithRelationInput | BookingServiceItemOrderByWithRelationInput[]
    cursor?: BookingServiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceItemScalarFieldEnum | BookingServiceItemScalarFieldEnum[]
  }

  /**
   * BookingRequest.workspaceBookings
   */
  export type BookingRequest$workspaceBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    where?: WorkspaceBookingWhereInput
    orderBy?: WorkspaceBookingOrderByWithRelationInput | WorkspaceBookingOrderByWithRelationInput[]
    cursor?: WorkspaceBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceBookingScalarFieldEnum | WorkspaceBookingScalarFieldEnum[]
  }

  /**
   * BookingRequest.serviceForms
   */
  export type BookingRequest$serviceFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    where?: ServiceFormWhereInput
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    cursor?: ServiceFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * BookingRequest without action
   */
  export type BookingRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequest
     */
    omit?: BookingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
  }


  /**
   * Model BookingServiceItem
   */

  export type AggregateBookingServiceItem = {
    _count: BookingServiceItemCountAggregateOutputType | null
    _avg: BookingServiceItemAvgAggregateOutputType | null
    _sum: BookingServiceItemSumAggregateOutputType | null
    _min: BookingServiceItemMinAggregateOutputType | null
    _max: BookingServiceItemMaxAggregateOutputType | null
  }

  export type BookingServiceItemAvgAggregateOutputType = {
    quantity: number | null
    durationMonths: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    flowRate: Decimal | null
    wavelength: number | null
    expectedRetentionTime: Decimal | null
  }

  export type BookingServiceItemSumAggregateOutputType = {
    quantity: number | null
    durationMonths: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    flowRate: Decimal | null
    wavelength: number | null
    expectedRetentionTime: Decimal | null
  }

  export type BookingServiceItemMinAggregateOutputType = {
    id: string | null
    bookingRequestId: string | null
    serviceId: string | null
    quantity: number | null
    durationMonths: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    sampleName: string | null
    sampleDetails: string | null
    sampleType: string | null
    sampleHazard: string | null
    testingMethod: string | null
    degasConditions: string | null
    solventSystem: string | null
    solvents: string | null
    solventComposition: string | null
    columnType: string | null
    flowRate: Decimal | null
    wavelength: number | null
    expectedRetentionTime: Decimal | null
    samplePreparation: string | null
    notes: string | null
    expectedCompletionDate: Date | null
    actualCompletionDate: Date | null
    turnaroundEstimate: string | null
    hplcPreparationRequired: boolean | null
    temperatureControlled: boolean | null
    lightSensitive: boolean | null
    hazardousMaterial: boolean | null
    inertAtmosphere: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingServiceItemMaxAggregateOutputType = {
    id: string | null
    bookingRequestId: string | null
    serviceId: string | null
    quantity: number | null
    durationMonths: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    sampleName: string | null
    sampleDetails: string | null
    sampleType: string | null
    sampleHazard: string | null
    testingMethod: string | null
    degasConditions: string | null
    solventSystem: string | null
    solvents: string | null
    solventComposition: string | null
    columnType: string | null
    flowRate: Decimal | null
    wavelength: number | null
    expectedRetentionTime: Decimal | null
    samplePreparation: string | null
    notes: string | null
    expectedCompletionDate: Date | null
    actualCompletionDate: Date | null
    turnaroundEstimate: string | null
    hplcPreparationRequired: boolean | null
    temperatureControlled: boolean | null
    lightSensitive: boolean | null
    hazardousMaterial: boolean | null
    inertAtmosphere: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingServiceItemCountAggregateOutputType = {
    id: number
    bookingRequestId: number
    serviceId: number
    quantity: number
    durationMonths: number
    unitPrice: number
    totalPrice: number
    sampleName: number
    sampleDetails: number
    sampleType: number
    sampleHazard: number
    testingMethod: number
    degasConditions: number
    solventSystem: number
    solvents: number
    solventComposition: number
    columnType: number
    flowRate: number
    wavelength: number
    expectedRetentionTime: number
    samplePreparation: number
    notes: number
    expectedCompletionDate: number
    actualCompletionDate: number
    turnaroundEstimate: number
    hplcPreparationRequired: number
    temperatureControlled: number
    lightSensitive: number
    hazardousMaterial: number
    inertAtmosphere: number
    otherEquipmentRequests: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingServiceItemAvgAggregateInputType = {
    quantity?: true
    durationMonths?: true
    unitPrice?: true
    totalPrice?: true
    flowRate?: true
    wavelength?: true
    expectedRetentionTime?: true
  }

  export type BookingServiceItemSumAggregateInputType = {
    quantity?: true
    durationMonths?: true
    unitPrice?: true
    totalPrice?: true
    flowRate?: true
    wavelength?: true
    expectedRetentionTime?: true
  }

  export type BookingServiceItemMinAggregateInputType = {
    id?: true
    bookingRequestId?: true
    serviceId?: true
    quantity?: true
    durationMonths?: true
    unitPrice?: true
    totalPrice?: true
    sampleName?: true
    sampleDetails?: true
    sampleType?: true
    sampleHazard?: true
    testingMethod?: true
    degasConditions?: true
    solventSystem?: true
    solvents?: true
    solventComposition?: true
    columnType?: true
    flowRate?: true
    wavelength?: true
    expectedRetentionTime?: true
    samplePreparation?: true
    notes?: true
    expectedCompletionDate?: true
    actualCompletionDate?: true
    turnaroundEstimate?: true
    hplcPreparationRequired?: true
    temperatureControlled?: true
    lightSensitive?: true
    hazardousMaterial?: true
    inertAtmosphere?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingServiceItemMaxAggregateInputType = {
    id?: true
    bookingRequestId?: true
    serviceId?: true
    quantity?: true
    durationMonths?: true
    unitPrice?: true
    totalPrice?: true
    sampleName?: true
    sampleDetails?: true
    sampleType?: true
    sampleHazard?: true
    testingMethod?: true
    degasConditions?: true
    solventSystem?: true
    solvents?: true
    solventComposition?: true
    columnType?: true
    flowRate?: true
    wavelength?: true
    expectedRetentionTime?: true
    samplePreparation?: true
    notes?: true
    expectedCompletionDate?: true
    actualCompletionDate?: true
    turnaroundEstimate?: true
    hplcPreparationRequired?: true
    temperatureControlled?: true
    lightSensitive?: true
    hazardousMaterial?: true
    inertAtmosphere?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingServiceItemCountAggregateInputType = {
    id?: true
    bookingRequestId?: true
    serviceId?: true
    quantity?: true
    durationMonths?: true
    unitPrice?: true
    totalPrice?: true
    sampleName?: true
    sampleDetails?: true
    sampleType?: true
    sampleHazard?: true
    testingMethod?: true
    degasConditions?: true
    solventSystem?: true
    solvents?: true
    solventComposition?: true
    columnType?: true
    flowRate?: true
    wavelength?: true
    expectedRetentionTime?: true
    samplePreparation?: true
    notes?: true
    expectedCompletionDate?: true
    actualCompletionDate?: true
    turnaroundEstimate?: true
    hplcPreparationRequired?: true
    temperatureControlled?: true
    lightSensitive?: true
    hazardousMaterial?: true
    inertAtmosphere?: true
    otherEquipmentRequests?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingServiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingServiceItem to aggregate.
     */
    where?: BookingServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServiceItems to fetch.
     */
    orderBy?: BookingServiceItemOrderByWithRelationInput | BookingServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingServiceItems
    **/
    _count?: true | BookingServiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingServiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingServiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingServiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingServiceItemMaxAggregateInputType
  }

  export type GetBookingServiceItemAggregateType<T extends BookingServiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingServiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingServiceItem[P]>
      : GetScalarType<T[P], AggregateBookingServiceItem[P]>
  }




  export type BookingServiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceItemWhereInput
    orderBy?: BookingServiceItemOrderByWithAggregationInput | BookingServiceItemOrderByWithAggregationInput[]
    by: BookingServiceItemScalarFieldEnum[] | BookingServiceItemScalarFieldEnum
    having?: BookingServiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingServiceItemCountAggregateInputType | true
    _avg?: BookingServiceItemAvgAggregateInputType
    _sum?: BookingServiceItemSumAggregateInputType
    _min?: BookingServiceItemMinAggregateInputType
    _max?: BookingServiceItemMaxAggregateInputType
  }

  export type BookingServiceItemGroupByOutputType = {
    id: string
    bookingRequestId: string
    serviceId: string
    quantity: number
    durationMonths: number
    unitPrice: Decimal
    totalPrice: Decimal
    sampleName: string | null
    sampleDetails: string | null
    sampleType: string | null
    sampleHazard: string | null
    testingMethod: string | null
    degasConditions: string | null
    solventSystem: string | null
    solvents: string | null
    solventComposition: string | null
    columnType: string | null
    flowRate: Decimal | null
    wavelength: number | null
    expectedRetentionTime: Decimal | null
    samplePreparation: string | null
    notes: string | null
    expectedCompletionDate: Date | null
    actualCompletionDate: Date | null
    turnaroundEstimate: string | null
    hplcPreparationRequired: boolean
    temperatureControlled: boolean
    lightSensitive: boolean
    hazardousMaterial: boolean
    inertAtmosphere: boolean
    otherEquipmentRequests: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BookingServiceItemCountAggregateOutputType | null
    _avg: BookingServiceItemAvgAggregateOutputType | null
    _sum: BookingServiceItemSumAggregateOutputType | null
    _min: BookingServiceItemMinAggregateOutputType | null
    _max: BookingServiceItemMaxAggregateOutputType | null
  }

  type GetBookingServiceItemGroupByPayload<T extends BookingServiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingServiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingServiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingServiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], BookingServiceItemGroupByOutputType[P]>
        }
      >
    >


  export type BookingServiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    serviceId?: boolean
    quantity?: boolean
    durationMonths?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    sampleName?: boolean
    sampleDetails?: boolean
    sampleType?: boolean
    sampleHazard?: boolean
    testingMethod?: boolean
    degasConditions?: boolean
    solventSystem?: boolean
    solvents?: boolean
    solventComposition?: boolean
    columnType?: boolean
    flowRate?: boolean
    wavelength?: boolean
    expectedRetentionTime?: boolean
    samplePreparation?: boolean
    notes?: boolean
    expectedCompletionDate?: boolean
    actualCompletionDate?: boolean
    turnaroundEstimate?: boolean
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    equipmentUsages?: boolean | BookingServiceItem$equipmentUsagesArgs<ExtArgs>
    modifications?: boolean | BookingServiceItem$modificationsArgs<ExtArgs>
    sampleTracking?: boolean | BookingServiceItem$sampleTrackingArgs<ExtArgs>
    serviceAddOns?: boolean | BookingServiceItem$serviceAddOnsArgs<ExtArgs>
    _count?: boolean | BookingServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingServiceItem"]>

  export type BookingServiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    serviceId?: boolean
    quantity?: boolean
    durationMonths?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    sampleName?: boolean
    sampleDetails?: boolean
    sampleType?: boolean
    sampleHazard?: boolean
    testingMethod?: boolean
    degasConditions?: boolean
    solventSystem?: boolean
    solvents?: boolean
    solventComposition?: boolean
    columnType?: boolean
    flowRate?: boolean
    wavelength?: boolean
    expectedRetentionTime?: boolean
    samplePreparation?: boolean
    notes?: boolean
    expectedCompletionDate?: boolean
    actualCompletionDate?: boolean
    turnaroundEstimate?: boolean
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingServiceItem"]>

  export type BookingServiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    serviceId?: boolean
    quantity?: boolean
    durationMonths?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    sampleName?: boolean
    sampleDetails?: boolean
    sampleType?: boolean
    sampleHazard?: boolean
    testingMethod?: boolean
    degasConditions?: boolean
    solventSystem?: boolean
    solvents?: boolean
    solventComposition?: boolean
    columnType?: boolean
    flowRate?: boolean
    wavelength?: boolean
    expectedRetentionTime?: boolean
    samplePreparation?: boolean
    notes?: boolean
    expectedCompletionDate?: boolean
    actualCompletionDate?: boolean
    turnaroundEstimate?: boolean
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingServiceItem"]>

  export type BookingServiceItemSelectScalar = {
    id?: boolean
    bookingRequestId?: boolean
    serviceId?: boolean
    quantity?: boolean
    durationMonths?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    sampleName?: boolean
    sampleDetails?: boolean
    sampleType?: boolean
    sampleHazard?: boolean
    testingMethod?: boolean
    degasConditions?: boolean
    solventSystem?: boolean
    solvents?: boolean
    solventComposition?: boolean
    columnType?: boolean
    flowRate?: boolean
    wavelength?: boolean
    expectedRetentionTime?: boolean
    samplePreparation?: boolean
    notes?: boolean
    expectedCompletionDate?: boolean
    actualCompletionDate?: boolean
    turnaroundEstimate?: boolean
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingServiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingRequestId" | "serviceId" | "quantity" | "durationMonths" | "unitPrice" | "totalPrice" | "sampleName" | "sampleDetails" | "sampleType" | "sampleHazard" | "testingMethod" | "degasConditions" | "solventSystem" | "solvents" | "solventComposition" | "columnType" | "flowRate" | "wavelength" | "expectedRetentionTime" | "samplePreparation" | "notes" | "expectedCompletionDate" | "actualCompletionDate" | "turnaroundEstimate" | "hplcPreparationRequired" | "temperatureControlled" | "lightSensitive" | "hazardousMaterial" | "inertAtmosphere" | "otherEquipmentRequests" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingServiceItem"]>
  export type BookingServiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    equipmentUsages?: boolean | BookingServiceItem$equipmentUsagesArgs<ExtArgs>
    modifications?: boolean | BookingServiceItem$modificationsArgs<ExtArgs>
    sampleTracking?: boolean | BookingServiceItem$sampleTrackingArgs<ExtArgs>
    serviceAddOns?: boolean | BookingServiceItem$serviceAddOnsArgs<ExtArgs>
    _count?: boolean | BookingServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingServiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BookingServiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BookingServiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingServiceItem"
    objects: {
      bookingRequest: Prisma.$BookingRequestPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      equipmentUsages: Prisma.$SampleEquipmentUsagePayload<ExtArgs>[]
      modifications: Prisma.$SampleModificationPayload<ExtArgs>[]
      sampleTracking: Prisma.$SampleTrackingPayload<ExtArgs>[]
      serviceAddOns: Prisma.$ServiceAddOnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingRequestId: string
      serviceId: string
      quantity: number
      durationMonths: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      sampleName: string | null
      sampleDetails: string | null
      sampleType: string | null
      sampleHazard: string | null
      testingMethod: string | null
      degasConditions: string | null
      solventSystem: string | null
      solvents: string | null
      solventComposition: string | null
      columnType: string | null
      flowRate: Prisma.Decimal | null
      wavelength: number | null
      expectedRetentionTime: Prisma.Decimal | null
      samplePreparation: string | null
      notes: string | null
      expectedCompletionDate: Date | null
      actualCompletionDate: Date | null
      turnaroundEstimate: string | null
      hplcPreparationRequired: boolean
      temperatureControlled: boolean
      lightSensitive: boolean
      hazardousMaterial: boolean
      inertAtmosphere: boolean
      otherEquipmentRequests: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingServiceItem"]>
    composites: {}
  }

  type BookingServiceItemGetPayload<S extends boolean | null | undefined | BookingServiceItemDefaultArgs> = $Result.GetResult<Prisma.$BookingServiceItemPayload, S>

  type BookingServiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingServiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingServiceItemCountAggregateInputType | true
    }

  export interface BookingServiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingServiceItem'], meta: { name: 'BookingServiceItem' } }
    /**
     * Find zero or one BookingServiceItem that matches the filter.
     * @param {BookingServiceItemFindUniqueArgs} args - Arguments to find a BookingServiceItem
     * @example
     * // Get one BookingServiceItem
     * const bookingServiceItem = await prisma.bookingServiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingServiceItemFindUniqueArgs>(args: SelectSubset<T, BookingServiceItemFindUniqueArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingServiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingServiceItemFindUniqueOrThrowArgs} args - Arguments to find a BookingServiceItem
     * @example
     * // Get one BookingServiceItem
     * const bookingServiceItem = await prisma.bookingServiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingServiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingServiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingServiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemFindFirstArgs} args - Arguments to find a BookingServiceItem
     * @example
     * // Get one BookingServiceItem
     * const bookingServiceItem = await prisma.bookingServiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingServiceItemFindFirstArgs>(args?: SelectSubset<T, BookingServiceItemFindFirstArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingServiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemFindFirstOrThrowArgs} args - Arguments to find a BookingServiceItem
     * @example
     * // Get one BookingServiceItem
     * const bookingServiceItem = await prisma.bookingServiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingServiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingServiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingServiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingServiceItems
     * const bookingServiceItems = await prisma.bookingServiceItem.findMany()
     * 
     * // Get first 10 BookingServiceItems
     * const bookingServiceItems = await prisma.bookingServiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingServiceItemWithIdOnly = await prisma.bookingServiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingServiceItemFindManyArgs>(args?: SelectSubset<T, BookingServiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingServiceItem.
     * @param {BookingServiceItemCreateArgs} args - Arguments to create a BookingServiceItem.
     * @example
     * // Create one BookingServiceItem
     * const BookingServiceItem = await prisma.bookingServiceItem.create({
     *   data: {
     *     // ... data to create a BookingServiceItem
     *   }
     * })
     * 
     */
    create<T extends BookingServiceItemCreateArgs>(args: SelectSubset<T, BookingServiceItemCreateArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingServiceItems.
     * @param {BookingServiceItemCreateManyArgs} args - Arguments to create many BookingServiceItems.
     * @example
     * // Create many BookingServiceItems
     * const bookingServiceItem = await prisma.bookingServiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingServiceItemCreateManyArgs>(args?: SelectSubset<T, BookingServiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingServiceItems and returns the data saved in the database.
     * @param {BookingServiceItemCreateManyAndReturnArgs} args - Arguments to create many BookingServiceItems.
     * @example
     * // Create many BookingServiceItems
     * const bookingServiceItem = await prisma.bookingServiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingServiceItems and only return the `id`
     * const bookingServiceItemWithIdOnly = await prisma.bookingServiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingServiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingServiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingServiceItem.
     * @param {BookingServiceItemDeleteArgs} args - Arguments to delete one BookingServiceItem.
     * @example
     * // Delete one BookingServiceItem
     * const BookingServiceItem = await prisma.bookingServiceItem.delete({
     *   where: {
     *     // ... filter to delete one BookingServiceItem
     *   }
     * })
     * 
     */
    delete<T extends BookingServiceItemDeleteArgs>(args: SelectSubset<T, BookingServiceItemDeleteArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingServiceItem.
     * @param {BookingServiceItemUpdateArgs} args - Arguments to update one BookingServiceItem.
     * @example
     * // Update one BookingServiceItem
     * const bookingServiceItem = await prisma.bookingServiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingServiceItemUpdateArgs>(args: SelectSubset<T, BookingServiceItemUpdateArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingServiceItems.
     * @param {BookingServiceItemDeleteManyArgs} args - Arguments to filter BookingServiceItems to delete.
     * @example
     * // Delete a few BookingServiceItems
     * const { count } = await prisma.bookingServiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingServiceItemDeleteManyArgs>(args?: SelectSubset<T, BookingServiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingServiceItems
     * const bookingServiceItem = await prisma.bookingServiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingServiceItemUpdateManyArgs>(args: SelectSubset<T, BookingServiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServiceItems and returns the data updated in the database.
     * @param {BookingServiceItemUpdateManyAndReturnArgs} args - Arguments to update many BookingServiceItems.
     * @example
     * // Update many BookingServiceItems
     * const bookingServiceItem = await prisma.bookingServiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingServiceItems and only return the `id`
     * const bookingServiceItemWithIdOnly = await prisma.bookingServiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingServiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingServiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingServiceItem.
     * @param {BookingServiceItemUpsertArgs} args - Arguments to update or create a BookingServiceItem.
     * @example
     * // Update or create a BookingServiceItem
     * const bookingServiceItem = await prisma.bookingServiceItem.upsert({
     *   create: {
     *     // ... data to create a BookingServiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingServiceItem we want to update
     *   }
     * })
     */
    upsert<T extends BookingServiceItemUpsertArgs>(args: SelectSubset<T, BookingServiceItemUpsertArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemCountArgs} args - Arguments to filter BookingServiceItems to count.
     * @example
     * // Count the number of BookingServiceItems
     * const count = await prisma.bookingServiceItem.count({
     *   where: {
     *     // ... the filter for the BookingServiceItems we want to count
     *   }
     * })
    **/
    count<T extends BookingServiceItemCountArgs>(
      args?: Subset<T, BookingServiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingServiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingServiceItemAggregateArgs>(args: Subset<T, BookingServiceItemAggregateArgs>): Prisma.PrismaPromise<GetBookingServiceItemAggregateType<T>>

    /**
     * Group by BookingServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingServiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingServiceItemGroupByArgs['orderBy'] }
        : { orderBy?: BookingServiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingServiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingServiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingServiceItem model
   */
  readonly fields: BookingServiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingServiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingServiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingRequest<T extends BookingRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequestDefaultArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipmentUsages<T extends BookingServiceItem$equipmentUsagesArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItem$equipmentUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modifications<T extends BookingServiceItem$modificationsArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItem$modificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sampleTracking<T extends BookingServiceItem$sampleTrackingArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItem$sampleTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceAddOns<T extends BookingServiceItem$serviceAddOnsArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItem$serviceAddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingServiceItem model
   */
  interface BookingServiceItemFieldRefs {
    readonly id: FieldRef<"BookingServiceItem", 'String'>
    readonly bookingRequestId: FieldRef<"BookingServiceItem", 'String'>
    readonly serviceId: FieldRef<"BookingServiceItem", 'String'>
    readonly quantity: FieldRef<"BookingServiceItem", 'Int'>
    readonly durationMonths: FieldRef<"BookingServiceItem", 'Int'>
    readonly unitPrice: FieldRef<"BookingServiceItem", 'Decimal'>
    readonly totalPrice: FieldRef<"BookingServiceItem", 'Decimal'>
    readonly sampleName: FieldRef<"BookingServiceItem", 'String'>
    readonly sampleDetails: FieldRef<"BookingServiceItem", 'String'>
    readonly sampleType: FieldRef<"BookingServiceItem", 'String'>
    readonly sampleHazard: FieldRef<"BookingServiceItem", 'String'>
    readonly testingMethod: FieldRef<"BookingServiceItem", 'String'>
    readonly degasConditions: FieldRef<"BookingServiceItem", 'String'>
    readonly solventSystem: FieldRef<"BookingServiceItem", 'String'>
    readonly solvents: FieldRef<"BookingServiceItem", 'String'>
    readonly solventComposition: FieldRef<"BookingServiceItem", 'String'>
    readonly columnType: FieldRef<"BookingServiceItem", 'String'>
    readonly flowRate: FieldRef<"BookingServiceItem", 'Decimal'>
    readonly wavelength: FieldRef<"BookingServiceItem", 'Int'>
    readonly expectedRetentionTime: FieldRef<"BookingServiceItem", 'Decimal'>
    readonly samplePreparation: FieldRef<"BookingServiceItem", 'String'>
    readonly notes: FieldRef<"BookingServiceItem", 'String'>
    readonly expectedCompletionDate: FieldRef<"BookingServiceItem", 'DateTime'>
    readonly actualCompletionDate: FieldRef<"BookingServiceItem", 'DateTime'>
    readonly turnaroundEstimate: FieldRef<"BookingServiceItem", 'String'>
    readonly hplcPreparationRequired: FieldRef<"BookingServiceItem", 'Boolean'>
    readonly temperatureControlled: FieldRef<"BookingServiceItem", 'Boolean'>
    readonly lightSensitive: FieldRef<"BookingServiceItem", 'Boolean'>
    readonly hazardousMaterial: FieldRef<"BookingServiceItem", 'Boolean'>
    readonly inertAtmosphere: FieldRef<"BookingServiceItem", 'Boolean'>
    readonly otherEquipmentRequests: FieldRef<"BookingServiceItem", 'Json'>
    readonly createdAt: FieldRef<"BookingServiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingServiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingServiceItem findUnique
   */
  export type BookingServiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which BookingServiceItem to fetch.
     */
    where: BookingServiceItemWhereUniqueInput
  }

  /**
   * BookingServiceItem findUniqueOrThrow
   */
  export type BookingServiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which BookingServiceItem to fetch.
     */
    where: BookingServiceItemWhereUniqueInput
  }

  /**
   * BookingServiceItem findFirst
   */
  export type BookingServiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which BookingServiceItem to fetch.
     */
    where?: BookingServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServiceItems to fetch.
     */
    orderBy?: BookingServiceItemOrderByWithRelationInput | BookingServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServiceItems.
     */
    cursor?: BookingServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServiceItems.
     */
    distinct?: BookingServiceItemScalarFieldEnum | BookingServiceItemScalarFieldEnum[]
  }

  /**
   * BookingServiceItem findFirstOrThrow
   */
  export type BookingServiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which BookingServiceItem to fetch.
     */
    where?: BookingServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServiceItems to fetch.
     */
    orderBy?: BookingServiceItemOrderByWithRelationInput | BookingServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServiceItems.
     */
    cursor?: BookingServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServiceItems.
     */
    distinct?: BookingServiceItemScalarFieldEnum | BookingServiceItemScalarFieldEnum[]
  }

  /**
   * BookingServiceItem findMany
   */
  export type BookingServiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which BookingServiceItems to fetch.
     */
    where?: BookingServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServiceItems to fetch.
     */
    orderBy?: BookingServiceItemOrderByWithRelationInput | BookingServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingServiceItems.
     */
    cursor?: BookingServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServiceItems.
     */
    skip?: number
    distinct?: BookingServiceItemScalarFieldEnum | BookingServiceItemScalarFieldEnum[]
  }

  /**
   * BookingServiceItem create
   */
  export type BookingServiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingServiceItem.
     */
    data: XOR<BookingServiceItemCreateInput, BookingServiceItemUncheckedCreateInput>
  }

  /**
   * BookingServiceItem createMany
   */
  export type BookingServiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingServiceItems.
     */
    data: BookingServiceItemCreateManyInput | BookingServiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingServiceItem createManyAndReturn
   */
  export type BookingServiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many BookingServiceItems.
     */
    data: BookingServiceItemCreateManyInput | BookingServiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingServiceItem update
   */
  export type BookingServiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingServiceItem.
     */
    data: XOR<BookingServiceItemUpdateInput, BookingServiceItemUncheckedUpdateInput>
    /**
     * Choose, which BookingServiceItem to update.
     */
    where: BookingServiceItemWhereUniqueInput
  }

  /**
   * BookingServiceItem updateMany
   */
  export type BookingServiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingServiceItems.
     */
    data: XOR<BookingServiceItemUpdateManyMutationInput, BookingServiceItemUncheckedUpdateManyInput>
    /**
     * Filter which BookingServiceItems to update
     */
    where?: BookingServiceItemWhereInput
    /**
     * Limit how many BookingServiceItems to update.
     */
    limit?: number
  }

  /**
   * BookingServiceItem updateManyAndReturn
   */
  export type BookingServiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * The data used to update BookingServiceItems.
     */
    data: XOR<BookingServiceItemUpdateManyMutationInput, BookingServiceItemUncheckedUpdateManyInput>
    /**
     * Filter which BookingServiceItems to update
     */
    where?: BookingServiceItemWhereInput
    /**
     * Limit how many BookingServiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingServiceItem upsert
   */
  export type BookingServiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingServiceItem to update in case it exists.
     */
    where: BookingServiceItemWhereUniqueInput
    /**
     * In case the BookingServiceItem found by the `where` argument doesn't exist, create a new BookingServiceItem with this data.
     */
    create: XOR<BookingServiceItemCreateInput, BookingServiceItemUncheckedCreateInput>
    /**
     * In case the BookingServiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingServiceItemUpdateInput, BookingServiceItemUncheckedUpdateInput>
  }

  /**
   * BookingServiceItem delete
   */
  export type BookingServiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    /**
     * Filter which BookingServiceItem to delete.
     */
    where: BookingServiceItemWhereUniqueInput
  }

  /**
   * BookingServiceItem deleteMany
   */
  export type BookingServiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingServiceItems to delete
     */
    where?: BookingServiceItemWhereInput
    /**
     * Limit how many BookingServiceItems to delete.
     */
    limit?: number
  }

  /**
   * BookingServiceItem.equipmentUsages
   */
  export type BookingServiceItem$equipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    where?: SampleEquipmentUsageWhereInput
    orderBy?: SampleEquipmentUsageOrderByWithRelationInput | SampleEquipmentUsageOrderByWithRelationInput[]
    cursor?: SampleEquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleEquipmentUsageScalarFieldEnum | SampleEquipmentUsageScalarFieldEnum[]
  }

  /**
   * BookingServiceItem.modifications
   */
  export type BookingServiceItem$modificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    where?: SampleModificationWhereInput
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    cursor?: SampleModificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleModificationScalarFieldEnum | SampleModificationScalarFieldEnum[]
  }

  /**
   * BookingServiceItem.sampleTracking
   */
  export type BookingServiceItem$sampleTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    where?: SampleTrackingWhereInput
    orderBy?: SampleTrackingOrderByWithRelationInput | SampleTrackingOrderByWithRelationInput[]
    cursor?: SampleTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleTrackingScalarFieldEnum | SampleTrackingScalarFieldEnum[]
  }

  /**
   * BookingServiceItem.serviceAddOns
   */
  export type BookingServiceItem$serviceAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    where?: ServiceAddOnWhereInput
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    cursor?: ServiceAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAddOnScalarFieldEnum | ServiceAddOnScalarFieldEnum[]
  }

  /**
   * BookingServiceItem without action
   */
  export type BookingServiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
  }


  /**
   * Model SampleModification
   */

  export type AggregateSampleModification = {
    _count: SampleModificationCountAggregateOutputType | null
    _avg: SampleModificationAvgAggregateOutputType | null
    _sum: SampleModificationSumAggregateOutputType | null
    _min: SampleModificationMinAggregateOutputType | null
    _max: SampleModificationMaxAggregateOutputType | null
  }

  export type SampleModificationAvgAggregateOutputType = {
    originalQuantity: number | null
    newQuantity: number | null
    originalDurationMonths: number | null
    newDurationMonths: number | null
    originalTotalPrice: Decimal | null
    newTotalPrice: Decimal | null
  }

  export type SampleModificationSumAggregateOutputType = {
    originalQuantity: number | null
    newQuantity: number | null
    originalDurationMonths: number | null
    newDurationMonths: number | null
    originalTotalPrice: Decimal | null
    newTotalPrice: Decimal | null
  }

  export type SampleModificationMinAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    originalQuantity: number | null
    newQuantity: number | null
    originalDurationMonths: number | null
    newDurationMonths: number | null
    originalTotalPrice: Decimal | null
    newTotalPrice: Decimal | null
    reason: string | null
    status: $Enums.modification_status_enum | null
    createdBy: string | null
    createdAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
  }

  export type SampleModificationMaxAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    originalQuantity: number | null
    newQuantity: number | null
    originalDurationMonths: number | null
    newDurationMonths: number | null
    originalTotalPrice: Decimal | null
    newTotalPrice: Decimal | null
    reason: string | null
    status: $Enums.modification_status_enum | null
    createdBy: string | null
    createdAt: Date | null
    approvedAt: Date | null
    approvedBy: string | null
  }

  export type SampleModificationCountAggregateOutputType = {
    id: number
    bookingServiceItemId: number
    originalQuantity: number
    newQuantity: number
    originalDurationMonths: number
    newDurationMonths: number
    originalTotalPrice: number
    newTotalPrice: number
    reason: number
    status: number
    createdBy: number
    createdAt: number
    approvedAt: number
    approvedBy: number
    _all: number
  }


  export type SampleModificationAvgAggregateInputType = {
    originalQuantity?: true
    newQuantity?: true
    originalDurationMonths?: true
    newDurationMonths?: true
    originalTotalPrice?: true
    newTotalPrice?: true
  }

  export type SampleModificationSumAggregateInputType = {
    originalQuantity?: true
    newQuantity?: true
    originalDurationMonths?: true
    newDurationMonths?: true
    originalTotalPrice?: true
    newTotalPrice?: true
  }

  export type SampleModificationMinAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    originalQuantity?: true
    newQuantity?: true
    originalDurationMonths?: true
    newDurationMonths?: true
    originalTotalPrice?: true
    newTotalPrice?: true
    reason?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedAt?: true
    approvedBy?: true
  }

  export type SampleModificationMaxAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    originalQuantity?: true
    newQuantity?: true
    originalDurationMonths?: true
    newDurationMonths?: true
    originalTotalPrice?: true
    newTotalPrice?: true
    reason?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedAt?: true
    approvedBy?: true
  }

  export type SampleModificationCountAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    originalQuantity?: true
    newQuantity?: true
    originalDurationMonths?: true
    newDurationMonths?: true
    originalTotalPrice?: true
    newTotalPrice?: true
    reason?: true
    status?: true
    createdBy?: true
    createdAt?: true
    approvedAt?: true
    approvedBy?: true
    _all?: true
  }

  export type SampleModificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SampleModification to aggregate.
     */
    where?: SampleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleModifications to fetch.
     */
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SampleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SampleModifications
    **/
    _count?: true | SampleModificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SampleModificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SampleModificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SampleModificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SampleModificationMaxAggregateInputType
  }

  export type GetSampleModificationAggregateType<T extends SampleModificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSampleModification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSampleModification[P]>
      : GetScalarType<T[P], AggregateSampleModification[P]>
  }




  export type SampleModificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleModificationWhereInput
    orderBy?: SampleModificationOrderByWithAggregationInput | SampleModificationOrderByWithAggregationInput[]
    by: SampleModificationScalarFieldEnum[] | SampleModificationScalarFieldEnum
    having?: SampleModificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SampleModificationCountAggregateInputType | true
    _avg?: SampleModificationAvgAggregateInputType
    _sum?: SampleModificationSumAggregateInputType
    _min?: SampleModificationMinAggregateInputType
    _max?: SampleModificationMaxAggregateInputType
  }

  export type SampleModificationGroupByOutputType = {
    id: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths: number
    newDurationMonths: number
    originalTotalPrice: Decimal
    newTotalPrice: Decimal
    reason: string
    status: $Enums.modification_status_enum
    createdBy: string
    createdAt: Date
    approvedAt: Date | null
    approvedBy: string | null
    _count: SampleModificationCountAggregateOutputType | null
    _avg: SampleModificationAvgAggregateOutputType | null
    _sum: SampleModificationSumAggregateOutputType | null
    _min: SampleModificationMinAggregateOutputType | null
    _max: SampleModificationMaxAggregateOutputType | null
  }

  type GetSampleModificationGroupByPayload<T extends SampleModificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SampleModificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SampleModificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SampleModificationGroupByOutputType[P]>
            : GetScalarType<T[P], SampleModificationGroupByOutputType[P]>
        }
      >
    >


  export type SampleModificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    originalQuantity?: boolean
    newQuantity?: boolean
    originalDurationMonths?: boolean
    newDurationMonths?: boolean
    originalTotalPrice?: boolean
    newTotalPrice?: boolean
    reason?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | SampleModification$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["sampleModification"]>

  export type SampleModificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    originalQuantity?: boolean
    newQuantity?: boolean
    originalDurationMonths?: boolean
    newDurationMonths?: boolean
    originalTotalPrice?: boolean
    newTotalPrice?: boolean
    reason?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | SampleModification$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["sampleModification"]>

  export type SampleModificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    originalQuantity?: boolean
    newQuantity?: boolean
    originalDurationMonths?: boolean
    newDurationMonths?: boolean
    originalTotalPrice?: boolean
    newTotalPrice?: boolean
    reason?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | SampleModification$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["sampleModification"]>

  export type SampleModificationSelectScalar = {
    id?: boolean
    bookingServiceItemId?: boolean
    originalQuantity?: boolean
    newQuantity?: boolean
    originalDurationMonths?: boolean
    newDurationMonths?: boolean
    originalTotalPrice?: boolean
    newTotalPrice?: boolean
    reason?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    approvedBy?: boolean
  }

  export type SampleModificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingServiceItemId" | "originalQuantity" | "newQuantity" | "originalDurationMonths" | "newDurationMonths" | "originalTotalPrice" | "newTotalPrice" | "reason" | "status" | "createdBy" | "createdAt" | "approvedAt" | "approvedBy", ExtArgs["result"]["sampleModification"]>
  export type SampleModificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | SampleModification$approvedByUserArgs<ExtArgs>
  }
  export type SampleModificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | SampleModification$approvedByUserArgs<ExtArgs>
  }
  export type SampleModificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    approvedByUser?: boolean | SampleModification$approvedByUserArgs<ExtArgs>
  }

  export type $SampleModificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SampleModification"
    objects: {
      bookingServiceItem: Prisma.$BookingServiceItemPayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs>
      approvedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingServiceItemId: string
      originalQuantity: number
      newQuantity: number
      originalDurationMonths: number
      newDurationMonths: number
      originalTotalPrice: Prisma.Decimal
      newTotalPrice: Prisma.Decimal
      reason: string
      status: $Enums.modification_status_enum
      createdBy: string
      createdAt: Date
      approvedAt: Date | null
      approvedBy: string | null
    }, ExtArgs["result"]["sampleModification"]>
    composites: {}
  }

  type SampleModificationGetPayload<S extends boolean | null | undefined | SampleModificationDefaultArgs> = $Result.GetResult<Prisma.$SampleModificationPayload, S>

  type SampleModificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SampleModificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SampleModificationCountAggregateInputType | true
    }

  export interface SampleModificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SampleModification'], meta: { name: 'SampleModification' } }
    /**
     * Find zero or one SampleModification that matches the filter.
     * @param {SampleModificationFindUniqueArgs} args - Arguments to find a SampleModification
     * @example
     * // Get one SampleModification
     * const sampleModification = await prisma.sampleModification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SampleModificationFindUniqueArgs>(args: SelectSubset<T, SampleModificationFindUniqueArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SampleModification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SampleModificationFindUniqueOrThrowArgs} args - Arguments to find a SampleModification
     * @example
     * // Get one SampleModification
     * const sampleModification = await prisma.sampleModification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SampleModificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SampleModificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SampleModification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationFindFirstArgs} args - Arguments to find a SampleModification
     * @example
     * // Get one SampleModification
     * const sampleModification = await prisma.sampleModification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SampleModificationFindFirstArgs>(args?: SelectSubset<T, SampleModificationFindFirstArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SampleModification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationFindFirstOrThrowArgs} args - Arguments to find a SampleModification
     * @example
     * // Get one SampleModification
     * const sampleModification = await prisma.sampleModification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SampleModificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SampleModificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SampleModifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SampleModifications
     * const sampleModifications = await prisma.sampleModification.findMany()
     * 
     * // Get first 10 SampleModifications
     * const sampleModifications = await prisma.sampleModification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sampleModificationWithIdOnly = await prisma.sampleModification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SampleModificationFindManyArgs>(args?: SelectSubset<T, SampleModificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SampleModification.
     * @param {SampleModificationCreateArgs} args - Arguments to create a SampleModification.
     * @example
     * // Create one SampleModification
     * const SampleModification = await prisma.sampleModification.create({
     *   data: {
     *     // ... data to create a SampleModification
     *   }
     * })
     * 
     */
    create<T extends SampleModificationCreateArgs>(args: SelectSubset<T, SampleModificationCreateArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SampleModifications.
     * @param {SampleModificationCreateManyArgs} args - Arguments to create many SampleModifications.
     * @example
     * // Create many SampleModifications
     * const sampleModification = await prisma.sampleModification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SampleModificationCreateManyArgs>(args?: SelectSubset<T, SampleModificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SampleModifications and returns the data saved in the database.
     * @param {SampleModificationCreateManyAndReturnArgs} args - Arguments to create many SampleModifications.
     * @example
     * // Create many SampleModifications
     * const sampleModification = await prisma.sampleModification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SampleModifications and only return the `id`
     * const sampleModificationWithIdOnly = await prisma.sampleModification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SampleModificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SampleModificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SampleModification.
     * @param {SampleModificationDeleteArgs} args - Arguments to delete one SampleModification.
     * @example
     * // Delete one SampleModification
     * const SampleModification = await prisma.sampleModification.delete({
     *   where: {
     *     // ... filter to delete one SampleModification
     *   }
     * })
     * 
     */
    delete<T extends SampleModificationDeleteArgs>(args: SelectSubset<T, SampleModificationDeleteArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SampleModification.
     * @param {SampleModificationUpdateArgs} args - Arguments to update one SampleModification.
     * @example
     * // Update one SampleModification
     * const sampleModification = await prisma.sampleModification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SampleModificationUpdateArgs>(args: SelectSubset<T, SampleModificationUpdateArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SampleModifications.
     * @param {SampleModificationDeleteManyArgs} args - Arguments to filter SampleModifications to delete.
     * @example
     * // Delete a few SampleModifications
     * const { count } = await prisma.sampleModification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SampleModificationDeleteManyArgs>(args?: SelectSubset<T, SampleModificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SampleModifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SampleModifications
     * const sampleModification = await prisma.sampleModification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SampleModificationUpdateManyArgs>(args: SelectSubset<T, SampleModificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SampleModifications and returns the data updated in the database.
     * @param {SampleModificationUpdateManyAndReturnArgs} args - Arguments to update many SampleModifications.
     * @example
     * // Update many SampleModifications
     * const sampleModification = await prisma.sampleModification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SampleModifications and only return the `id`
     * const sampleModificationWithIdOnly = await prisma.sampleModification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SampleModificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SampleModificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SampleModification.
     * @param {SampleModificationUpsertArgs} args - Arguments to update or create a SampleModification.
     * @example
     * // Update or create a SampleModification
     * const sampleModification = await prisma.sampleModification.upsert({
     *   create: {
     *     // ... data to create a SampleModification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SampleModification we want to update
     *   }
     * })
     */
    upsert<T extends SampleModificationUpsertArgs>(args: SelectSubset<T, SampleModificationUpsertArgs<ExtArgs>>): Prisma__SampleModificationClient<$Result.GetResult<Prisma.$SampleModificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SampleModifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationCountArgs} args - Arguments to filter SampleModifications to count.
     * @example
     * // Count the number of SampleModifications
     * const count = await prisma.sampleModification.count({
     *   where: {
     *     // ... the filter for the SampleModifications we want to count
     *   }
     * })
    **/
    count<T extends SampleModificationCountArgs>(
      args?: Subset<T, SampleModificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SampleModificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SampleModification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SampleModificationAggregateArgs>(args: Subset<T, SampleModificationAggregateArgs>): Prisma.PrismaPromise<GetSampleModificationAggregateType<T>>

    /**
     * Group by SampleModification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleModificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SampleModificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SampleModificationGroupByArgs['orderBy'] }
        : { orderBy?: SampleModificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SampleModificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSampleModificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SampleModification model
   */
  readonly fields: SampleModificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SampleModification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SampleModificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingServiceItem<T extends BookingServiceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItemDefaultArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedByUser<T extends SampleModification$approvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, SampleModification$approvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SampleModification model
   */
  interface SampleModificationFieldRefs {
    readonly id: FieldRef<"SampleModification", 'String'>
    readonly bookingServiceItemId: FieldRef<"SampleModification", 'String'>
    readonly originalQuantity: FieldRef<"SampleModification", 'Int'>
    readonly newQuantity: FieldRef<"SampleModification", 'Int'>
    readonly originalDurationMonths: FieldRef<"SampleModification", 'Int'>
    readonly newDurationMonths: FieldRef<"SampleModification", 'Int'>
    readonly originalTotalPrice: FieldRef<"SampleModification", 'Decimal'>
    readonly newTotalPrice: FieldRef<"SampleModification", 'Decimal'>
    readonly reason: FieldRef<"SampleModification", 'String'>
    readonly status: FieldRef<"SampleModification", 'modification_status_enum'>
    readonly createdBy: FieldRef<"SampleModification", 'String'>
    readonly createdAt: FieldRef<"SampleModification", 'DateTime'>
    readonly approvedAt: FieldRef<"SampleModification", 'DateTime'>
    readonly approvedBy: FieldRef<"SampleModification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SampleModification findUnique
   */
  export type SampleModificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * Filter, which SampleModification to fetch.
     */
    where: SampleModificationWhereUniqueInput
  }

  /**
   * SampleModification findUniqueOrThrow
   */
  export type SampleModificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * Filter, which SampleModification to fetch.
     */
    where: SampleModificationWhereUniqueInput
  }

  /**
   * SampleModification findFirst
   */
  export type SampleModificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * Filter, which SampleModification to fetch.
     */
    where?: SampleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleModifications to fetch.
     */
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SampleModifications.
     */
    cursor?: SampleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SampleModifications.
     */
    distinct?: SampleModificationScalarFieldEnum | SampleModificationScalarFieldEnum[]
  }

  /**
   * SampleModification findFirstOrThrow
   */
  export type SampleModificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * Filter, which SampleModification to fetch.
     */
    where?: SampleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleModifications to fetch.
     */
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SampleModifications.
     */
    cursor?: SampleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SampleModifications.
     */
    distinct?: SampleModificationScalarFieldEnum | SampleModificationScalarFieldEnum[]
  }

  /**
   * SampleModification findMany
   */
  export type SampleModificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * Filter, which SampleModifications to fetch.
     */
    where?: SampleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleModifications to fetch.
     */
    orderBy?: SampleModificationOrderByWithRelationInput | SampleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SampleModifications.
     */
    cursor?: SampleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleModifications.
     */
    skip?: number
    distinct?: SampleModificationScalarFieldEnum | SampleModificationScalarFieldEnum[]
  }

  /**
   * SampleModification create
   */
  export type SampleModificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SampleModification.
     */
    data: XOR<SampleModificationCreateInput, SampleModificationUncheckedCreateInput>
  }

  /**
   * SampleModification createMany
   */
  export type SampleModificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SampleModifications.
     */
    data: SampleModificationCreateManyInput | SampleModificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SampleModification createManyAndReturn
   */
  export type SampleModificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * The data used to create many SampleModifications.
     */
    data: SampleModificationCreateManyInput | SampleModificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SampleModification update
   */
  export type SampleModificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SampleModification.
     */
    data: XOR<SampleModificationUpdateInput, SampleModificationUncheckedUpdateInput>
    /**
     * Choose, which SampleModification to update.
     */
    where: SampleModificationWhereUniqueInput
  }

  /**
   * SampleModification updateMany
   */
  export type SampleModificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SampleModifications.
     */
    data: XOR<SampleModificationUpdateManyMutationInput, SampleModificationUncheckedUpdateManyInput>
    /**
     * Filter which SampleModifications to update
     */
    where?: SampleModificationWhereInput
    /**
     * Limit how many SampleModifications to update.
     */
    limit?: number
  }

  /**
   * SampleModification updateManyAndReturn
   */
  export type SampleModificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * The data used to update SampleModifications.
     */
    data: XOR<SampleModificationUpdateManyMutationInput, SampleModificationUncheckedUpdateManyInput>
    /**
     * Filter which SampleModifications to update
     */
    where?: SampleModificationWhereInput
    /**
     * Limit how many SampleModifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SampleModification upsert
   */
  export type SampleModificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SampleModification to update in case it exists.
     */
    where: SampleModificationWhereUniqueInput
    /**
     * In case the SampleModification found by the `where` argument doesn't exist, create a new SampleModification with this data.
     */
    create: XOR<SampleModificationCreateInput, SampleModificationUncheckedCreateInput>
    /**
     * In case the SampleModification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SampleModificationUpdateInput, SampleModificationUncheckedUpdateInput>
  }

  /**
   * SampleModification delete
   */
  export type SampleModificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
    /**
     * Filter which SampleModification to delete.
     */
    where: SampleModificationWhereUniqueInput
  }

  /**
   * SampleModification deleteMany
   */
  export type SampleModificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SampleModifications to delete
     */
    where?: SampleModificationWhereInput
    /**
     * Limit how many SampleModifications to delete.
     */
    limit?: number
  }

  /**
   * SampleModification.approvedByUser
   */
  export type SampleModification$approvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SampleModification without action
   */
  export type SampleModificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleModification
     */
    select?: SampleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleModification
     */
    omit?: SampleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleModificationInclude<ExtArgs> | null
  }


  /**
   * Model ServiceForm
   */

  export type AggregateServiceForm = {
    _count: ServiceFormCountAggregateOutputType | null
    _avg: ServiceFormAvgAggregateOutputType | null
    _sum: ServiceFormSumAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  export type ServiceFormAvgAggregateOutputType = {
    subtotal: Decimal | null
    totalAmount: Decimal | null
  }

  export type ServiceFormSumAggregateOutputType = {
    subtotal: Decimal | null
    totalAmount: Decimal | null
  }

  export type ServiceFormMinAggregateOutputType = {
    id: string | null
    bookingRequestId: string | null
    formNumber: string | null
    costCentre: string | null
    facilityLab: string | null
    staffPicName: string | null
    staffPicEmail: string | null
    staffPicPhone: string | null
    subtotal: Decimal | null
    totalAmount: Decimal | null
    validUntil: Date | null
    status: $Enums.form_status_enum | null
    serviceFormUnsignedPdfPath: string | null
    serviceFormSignedPdfPath: string | null
    requiresWorkingAreaAgreement: boolean | null
    workingAreaAgreementUnsignedPdfPath: string | null
    workingAreaAgreementSignedPdfPath: string | null
    generatedAt: Date | null
    generatedBy: string | null
    downloadedAt: Date | null
    signedFormsUploadedAt: Date | null
    signedFormsUploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceFormMaxAggregateOutputType = {
    id: string | null
    bookingRequestId: string | null
    formNumber: string | null
    costCentre: string | null
    facilityLab: string | null
    staffPicName: string | null
    staffPicEmail: string | null
    staffPicPhone: string | null
    subtotal: Decimal | null
    totalAmount: Decimal | null
    validUntil: Date | null
    status: $Enums.form_status_enum | null
    serviceFormUnsignedPdfPath: string | null
    serviceFormSignedPdfPath: string | null
    requiresWorkingAreaAgreement: boolean | null
    workingAreaAgreementUnsignedPdfPath: string | null
    workingAreaAgreementSignedPdfPath: string | null
    generatedAt: Date | null
    generatedBy: string | null
    downloadedAt: Date | null
    signedFormsUploadedAt: Date | null
    signedFormsUploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceFormCountAggregateOutputType = {
    id: number
    bookingRequestId: number
    formNumber: number
    costCentre: number
    facilityLab: number
    staffPicName: number
    staffPicEmail: number
    staffPicPhone: number
    subtotal: number
    totalAmount: number
    validUntil: number
    status: number
    serviceFormUnsignedPdfPath: number
    serviceFormSignedPdfPath: number
    requiresWorkingAreaAgreement: number
    workingAreaAgreementUnsignedPdfPath: number
    workingAreaAgreementSignedPdfPath: number
    generatedAt: number
    generatedBy: number
    downloadedAt: number
    signedFormsUploadedAt: number
    signedFormsUploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceFormAvgAggregateInputType = {
    subtotal?: true
    totalAmount?: true
  }

  export type ServiceFormSumAggregateInputType = {
    subtotal?: true
    totalAmount?: true
  }

  export type ServiceFormMinAggregateInputType = {
    id?: true
    bookingRequestId?: true
    formNumber?: true
    costCentre?: true
    facilityLab?: true
    staffPicName?: true
    staffPicEmail?: true
    staffPicPhone?: true
    subtotal?: true
    totalAmount?: true
    validUntil?: true
    status?: true
    serviceFormUnsignedPdfPath?: true
    serviceFormSignedPdfPath?: true
    requiresWorkingAreaAgreement?: true
    workingAreaAgreementUnsignedPdfPath?: true
    workingAreaAgreementSignedPdfPath?: true
    generatedAt?: true
    generatedBy?: true
    downloadedAt?: true
    signedFormsUploadedAt?: true
    signedFormsUploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceFormMaxAggregateInputType = {
    id?: true
    bookingRequestId?: true
    formNumber?: true
    costCentre?: true
    facilityLab?: true
    staffPicName?: true
    staffPicEmail?: true
    staffPicPhone?: true
    subtotal?: true
    totalAmount?: true
    validUntil?: true
    status?: true
    serviceFormUnsignedPdfPath?: true
    serviceFormSignedPdfPath?: true
    requiresWorkingAreaAgreement?: true
    workingAreaAgreementUnsignedPdfPath?: true
    workingAreaAgreementSignedPdfPath?: true
    generatedAt?: true
    generatedBy?: true
    downloadedAt?: true
    signedFormsUploadedAt?: true
    signedFormsUploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceFormCountAggregateInputType = {
    id?: true
    bookingRequestId?: true
    formNumber?: true
    costCentre?: true
    facilityLab?: true
    staffPicName?: true
    staffPicEmail?: true
    staffPicPhone?: true
    subtotal?: true
    totalAmount?: true
    validUntil?: true
    status?: true
    serviceFormUnsignedPdfPath?: true
    serviceFormSignedPdfPath?: true
    requiresWorkingAreaAgreement?: true
    workingAreaAgreementUnsignedPdfPath?: true
    workingAreaAgreementSignedPdfPath?: true
    generatedAt?: true
    generatedBy?: true
    downloadedAt?: true
    signedFormsUploadedAt?: true
    signedFormsUploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForm to aggregate.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceForms
    **/
    _count?: true | ServiceFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceFormMaxAggregateInputType
  }

  export type GetServiceFormAggregateType<T extends ServiceFormAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceForm[P]>
      : GetScalarType<T[P], AggregateServiceForm[P]>
  }




  export type ServiceFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceFormWhereInput
    orderBy?: ServiceFormOrderByWithAggregationInput | ServiceFormOrderByWithAggregationInput[]
    by: ServiceFormScalarFieldEnum[] | ServiceFormScalarFieldEnum
    having?: ServiceFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceFormCountAggregateInputType | true
    _avg?: ServiceFormAvgAggregateInputType
    _sum?: ServiceFormSumAggregateInputType
    _min?: ServiceFormMinAggregateInputType
    _max?: ServiceFormMaxAggregateInputType
  }

  export type ServiceFormGroupByOutputType = {
    id: string
    bookingRequestId: string
    formNumber: string
    costCentre: string | null
    facilityLab: string
    staffPicName: string | null
    staffPicEmail: string | null
    staffPicPhone: string | null
    subtotal: Decimal
    totalAmount: Decimal
    validUntil: Date
    status: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath: string | null
    requiresWorkingAreaAgreement: boolean
    workingAreaAgreementUnsignedPdfPath: string | null
    workingAreaAgreementSignedPdfPath: string | null
    generatedAt: Date
    generatedBy: string
    downloadedAt: Date | null
    signedFormsUploadedAt: Date | null
    signedFormsUploadedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceFormCountAggregateOutputType | null
    _avg: ServiceFormAvgAggregateOutputType | null
    _sum: ServiceFormSumAggregateOutputType | null
    _min: ServiceFormMinAggregateOutputType | null
    _max: ServiceFormMaxAggregateOutputType | null
  }

  type GetServiceFormGroupByPayload<T extends ServiceFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFormGroupByOutputType[P]>
        }
      >
    >


  export type ServiceFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    formNumber?: boolean
    costCentre?: boolean
    facilityLab?: boolean
    staffPicName?: boolean
    staffPicEmail?: boolean
    staffPicPhone?: boolean
    subtotal?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    status?: boolean
    serviceFormUnsignedPdfPath?: boolean
    serviceFormSignedPdfPath?: boolean
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: boolean
    workingAreaAgreementSignedPdfPath?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    downloadedAt?: boolean
    signedFormsUploadedAt?: boolean
    signedFormsUploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    generatedByUser?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | ServiceForm$invoicesArgs<ExtArgs>
    _count?: boolean | ServiceFormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceForm"]>

  export type ServiceFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    formNumber?: boolean
    costCentre?: boolean
    facilityLab?: boolean
    staffPicName?: boolean
    staffPicEmail?: boolean
    staffPicPhone?: boolean
    subtotal?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    status?: boolean
    serviceFormUnsignedPdfPath?: boolean
    serviceFormSignedPdfPath?: boolean
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: boolean
    workingAreaAgreementSignedPdfPath?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    downloadedAt?: boolean
    signedFormsUploadedAt?: boolean
    signedFormsUploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    generatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceForm"]>

  export type ServiceFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    formNumber?: boolean
    costCentre?: boolean
    facilityLab?: boolean
    staffPicName?: boolean
    staffPicEmail?: boolean
    staffPicPhone?: boolean
    subtotal?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    status?: boolean
    serviceFormUnsignedPdfPath?: boolean
    serviceFormSignedPdfPath?: boolean
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: boolean
    workingAreaAgreementSignedPdfPath?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    downloadedAt?: boolean
    signedFormsUploadedAt?: boolean
    signedFormsUploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    generatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceForm"]>

  export type ServiceFormSelectScalar = {
    id?: boolean
    bookingRequestId?: boolean
    formNumber?: boolean
    costCentre?: boolean
    facilityLab?: boolean
    staffPicName?: boolean
    staffPicEmail?: boolean
    staffPicPhone?: boolean
    subtotal?: boolean
    totalAmount?: boolean
    validUntil?: boolean
    status?: boolean
    serviceFormUnsignedPdfPath?: boolean
    serviceFormSignedPdfPath?: boolean
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: boolean
    workingAreaAgreementSignedPdfPath?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    downloadedAt?: boolean
    signedFormsUploadedAt?: boolean
    signedFormsUploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingRequestId" | "formNumber" | "costCentre" | "facilityLab" | "staffPicName" | "staffPicEmail" | "staffPicPhone" | "subtotal" | "totalAmount" | "validUntil" | "status" | "serviceFormUnsignedPdfPath" | "serviceFormSignedPdfPath" | "requiresWorkingAreaAgreement" | "workingAreaAgreementUnsignedPdfPath" | "workingAreaAgreementSignedPdfPath" | "generatedAt" | "generatedBy" | "downloadedAt" | "signedFormsUploadedAt" | "signedFormsUploadedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceForm"]>
  export type ServiceFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    generatedByUser?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | ServiceForm$invoicesArgs<ExtArgs>
    _count?: boolean | ServiceFormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    generatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ServiceFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    generatedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ServiceFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceForm"
    objects: {
      bookingRequest: Prisma.$BookingRequestPayload<ExtArgs>
      generatedByUser: Prisma.$UserPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingRequestId: string
      formNumber: string
      costCentre: string | null
      facilityLab: string
      staffPicName: string | null
      staffPicEmail: string | null
      staffPicPhone: string | null
      subtotal: Prisma.Decimal
      totalAmount: Prisma.Decimal
      validUntil: Date
      status: $Enums.form_status_enum
      serviceFormUnsignedPdfPath: string
      serviceFormSignedPdfPath: string | null
      requiresWorkingAreaAgreement: boolean
      workingAreaAgreementUnsignedPdfPath: string | null
      workingAreaAgreementSignedPdfPath: string | null
      generatedAt: Date
      generatedBy: string
      downloadedAt: Date | null
      signedFormsUploadedAt: Date | null
      signedFormsUploadedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceForm"]>
    composites: {}
  }

  type ServiceFormGetPayload<S extends boolean | null | undefined | ServiceFormDefaultArgs> = $Result.GetResult<Prisma.$ServiceFormPayload, S>

  type ServiceFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceFormCountAggregateInputType | true
    }

  export interface ServiceFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceForm'], meta: { name: 'ServiceForm' } }
    /**
     * Find zero or one ServiceForm that matches the filter.
     * @param {ServiceFormFindUniqueArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFormFindUniqueArgs>(args: SelectSubset<T, ServiceFormFindUniqueArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFormFindUniqueOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFormFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFormFindFirstArgs>(args?: SelectSubset<T, ServiceFormFindFirstArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindFirstOrThrowArgs} args - Arguments to find a ServiceForm
     * @example
     * // Get one ServiceForm
     * const serviceForm = await prisma.serviceForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFormFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany()
     * 
     * // Get first 10 ServiceForms
     * const serviceForms = await prisma.serviceForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceFormWithIdOnly = await prisma.serviceForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFormFindManyArgs>(args?: SelectSubset<T, ServiceFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceForm.
     * @param {ServiceFormCreateArgs} args - Arguments to create a ServiceForm.
     * @example
     * // Create one ServiceForm
     * const ServiceForm = await prisma.serviceForm.create({
     *   data: {
     *     // ... data to create a ServiceForm
     *   }
     * })
     * 
     */
    create<T extends ServiceFormCreateArgs>(args: SelectSubset<T, ServiceFormCreateArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceForms.
     * @param {ServiceFormCreateManyArgs} args - Arguments to create many ServiceForms.
     * @example
     * // Create many ServiceForms
     * const serviceForm = await prisma.serviceForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceFormCreateManyArgs>(args?: SelectSubset<T, ServiceFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceForms and returns the data saved in the database.
     * @param {ServiceFormCreateManyAndReturnArgs} args - Arguments to create many ServiceForms.
     * @example
     * // Create many ServiceForms
     * const serviceForm = await prisma.serviceForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceForms and only return the `id`
     * const serviceFormWithIdOnly = await prisma.serviceForm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceFormCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceForm.
     * @param {ServiceFormDeleteArgs} args - Arguments to delete one ServiceForm.
     * @example
     * // Delete one ServiceForm
     * const ServiceForm = await prisma.serviceForm.delete({
     *   where: {
     *     // ... filter to delete one ServiceForm
     *   }
     * })
     * 
     */
    delete<T extends ServiceFormDeleteArgs>(args: SelectSubset<T, ServiceFormDeleteArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceForm.
     * @param {ServiceFormUpdateArgs} args - Arguments to update one ServiceForm.
     * @example
     * // Update one ServiceForm
     * const serviceForm = await prisma.serviceForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceFormUpdateArgs>(args: SelectSubset<T, ServiceFormUpdateArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceForms.
     * @param {ServiceFormDeleteManyArgs} args - Arguments to filter ServiceForms to delete.
     * @example
     * // Delete a few ServiceForms
     * const { count } = await prisma.serviceForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceFormDeleteManyArgs>(args?: SelectSubset<T, ServiceFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceForms
     * const serviceForm = await prisma.serviceForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceFormUpdateManyArgs>(args: SelectSubset<T, ServiceFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceForms and returns the data updated in the database.
     * @param {ServiceFormUpdateManyAndReturnArgs} args - Arguments to update many ServiceForms.
     * @example
     * // Update many ServiceForms
     * const serviceForm = await prisma.serviceForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceForms and only return the `id`
     * const serviceFormWithIdOnly = await prisma.serviceForm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceFormUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceForm.
     * @param {ServiceFormUpsertArgs} args - Arguments to update or create a ServiceForm.
     * @example
     * // Update or create a ServiceForm
     * const serviceForm = await prisma.serviceForm.upsert({
     *   create: {
     *     // ... data to create a ServiceForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceForm we want to update
     *   }
     * })
     */
    upsert<T extends ServiceFormUpsertArgs>(args: SelectSubset<T, ServiceFormUpsertArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormCountArgs} args - Arguments to filter ServiceForms to count.
     * @example
     * // Count the number of ServiceForms
     * const count = await prisma.serviceForm.count({
     *   where: {
     *     // ... the filter for the ServiceForms we want to count
     *   }
     * })
    **/
    count<T extends ServiceFormCountArgs>(
      args?: Subset<T, ServiceFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceFormAggregateArgs>(args: Subset<T, ServiceFormAggregateArgs>): Prisma.PrismaPromise<GetServiceFormAggregateType<T>>

    /**
     * Group by ServiceForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFormGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceForm model
   */
  readonly fields: ServiceFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingRequest<T extends BookingRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequestDefaultArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generatedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends ServiceForm$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceForm$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceForm model
   */
  interface ServiceFormFieldRefs {
    readonly id: FieldRef<"ServiceForm", 'String'>
    readonly bookingRequestId: FieldRef<"ServiceForm", 'String'>
    readonly formNumber: FieldRef<"ServiceForm", 'String'>
    readonly costCentre: FieldRef<"ServiceForm", 'String'>
    readonly facilityLab: FieldRef<"ServiceForm", 'String'>
    readonly staffPicName: FieldRef<"ServiceForm", 'String'>
    readonly staffPicEmail: FieldRef<"ServiceForm", 'String'>
    readonly staffPicPhone: FieldRef<"ServiceForm", 'String'>
    readonly subtotal: FieldRef<"ServiceForm", 'Decimal'>
    readonly totalAmount: FieldRef<"ServiceForm", 'Decimal'>
    readonly validUntil: FieldRef<"ServiceForm", 'DateTime'>
    readonly status: FieldRef<"ServiceForm", 'form_status_enum'>
    readonly serviceFormUnsignedPdfPath: FieldRef<"ServiceForm", 'String'>
    readonly serviceFormSignedPdfPath: FieldRef<"ServiceForm", 'String'>
    readonly requiresWorkingAreaAgreement: FieldRef<"ServiceForm", 'Boolean'>
    readonly workingAreaAgreementUnsignedPdfPath: FieldRef<"ServiceForm", 'String'>
    readonly workingAreaAgreementSignedPdfPath: FieldRef<"ServiceForm", 'String'>
    readonly generatedAt: FieldRef<"ServiceForm", 'DateTime'>
    readonly generatedBy: FieldRef<"ServiceForm", 'String'>
    readonly downloadedAt: FieldRef<"ServiceForm", 'DateTime'>
    readonly signedFormsUploadedAt: FieldRef<"ServiceForm", 'DateTime'>
    readonly signedFormsUploadedBy: FieldRef<"ServiceForm", 'String'>
    readonly createdAt: FieldRef<"ServiceForm", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceForm findUnique
   */
  export type ServiceFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm findUniqueOrThrow
   */
  export type ServiceFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm findFirst
   */
  export type ServiceFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * ServiceForm findFirstOrThrow
   */
  export type ServiceFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForm to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceForms.
     */
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * ServiceForm findMany
   */
  export type ServiceFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter, which ServiceForms to fetch.
     */
    where?: ServiceFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceForms to fetch.
     */
    orderBy?: ServiceFormOrderByWithRelationInput | ServiceFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceForms.
     */
    cursor?: ServiceFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceForms.
     */
    skip?: number
    distinct?: ServiceFormScalarFieldEnum | ServiceFormScalarFieldEnum[]
  }

  /**
   * ServiceForm create
   */
  export type ServiceFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceForm.
     */
    data: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
  }

  /**
   * ServiceForm createMany
   */
  export type ServiceFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceForms.
     */
    data: ServiceFormCreateManyInput | ServiceFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceForm createManyAndReturn
   */
  export type ServiceFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceForms.
     */
    data: ServiceFormCreateManyInput | ServiceFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceForm update
   */
  export type ServiceFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceForm.
     */
    data: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
    /**
     * Choose, which ServiceForm to update.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm updateMany
   */
  export type ServiceFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceForms.
     */
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceForms to update
     */
    where?: ServiceFormWhereInput
    /**
     * Limit how many ServiceForms to update.
     */
    limit?: number
  }

  /**
   * ServiceForm updateManyAndReturn
   */
  export type ServiceFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * The data used to update ServiceForms.
     */
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyInput>
    /**
     * Filter which ServiceForms to update
     */
    where?: ServiceFormWhereInput
    /**
     * Limit how many ServiceForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceForm upsert
   */
  export type ServiceFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceForm to update in case it exists.
     */
    where: ServiceFormWhereUniqueInput
    /**
     * In case the ServiceForm found by the `where` argument doesn't exist, create a new ServiceForm with this data.
     */
    create: XOR<ServiceFormCreateInput, ServiceFormUncheckedCreateInput>
    /**
     * In case the ServiceForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFormUpdateInput, ServiceFormUncheckedUpdateInput>
  }

  /**
   * ServiceForm delete
   */
  export type ServiceFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
    /**
     * Filter which ServiceForm to delete.
     */
    where: ServiceFormWhereUniqueInput
  }

  /**
   * ServiceForm deleteMany
   */
  export type ServiceFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceForms to delete
     */
    where?: ServiceFormWhereInput
    /**
     * Limit how many ServiceForms to delete.
     */
    limit?: number
  }

  /**
   * ServiceForm.invoices
   */
  export type ServiceForm$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * ServiceForm without action
   */
  export type ServiceFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceForm
     */
    select?: ServiceFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceForm
     */
    omit?: ServiceFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFormInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    serviceFormId: string | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    amount: Decimal | null
    status: $Enums.invoice_status_enum | null
    filePath: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    serviceFormId: string | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    amount: Decimal | null
    status: $Enums.invoice_status_enum | null
    filePath: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    serviceFormId: number
    invoiceNumber: number
    invoiceDate: number
    dueDate: number
    amount: number
    status: number
    filePath: number
    uploadedBy: number
    uploadedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    serviceFormId?: true
    invoiceNumber?: true
    invoiceDate?: true
    dueDate?: true
    amount?: true
    status?: true
    filePath?: true
    uploadedBy?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    serviceFormId?: true
    invoiceNumber?: true
    invoiceDate?: true
    dueDate?: true
    amount?: true
    status?: true
    filePath?: true
    uploadedBy?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    serviceFormId?: true
    invoiceNumber?: true
    invoiceDate?: true
    dueDate?: true
    amount?: true
    status?: true
    filePath?: true
    uploadedBy?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    serviceFormId: string
    invoiceNumber: string
    invoiceDate: Date
    dueDate: Date
    amount: Decimal
    status: $Enums.invoice_status_enum
    filePath: string
    uploadedBy: string
    uploadedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceFormId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    filePath?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceForm?: boolean | ServiceFormDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceFormId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    filePath?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceForm?: boolean | ServiceFormDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceFormId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    filePath?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceForm?: boolean | ServiceFormDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    serviceFormId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    filePath?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceFormId" | "invoiceNumber" | "invoiceDate" | "dueDate" | "amount" | "status" | "filePath" | "uploadedBy" | "uploadedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceForm?: boolean | ServiceFormDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceForm?: boolean | ServiceFormDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceForm?: boolean | ServiceFormDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      serviceForm: Prisma.$ServiceFormPayload<ExtArgs>
      uploadedByUser: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceFormId: string
      invoiceNumber: string
      invoiceDate: Date
      dueDate: Date
      amount: Prisma.Decimal
      status: $Enums.invoice_status_enum
      filePath: string
      uploadedBy: string
      uploadedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceForm<T extends ServiceFormDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceFormDefaultArgs<ExtArgs>>): Prisma__ServiceFormClient<$Result.GetResult<Prisma.$ServiceFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly serviceFormId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'invoice_status_enum'>
    readonly filePath: FieldRef<"Invoice", 'String'>
    readonly uploadedBy: FieldRef<"Invoice", 'String'>
    readonly uploadedAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.payment_method_enum | null
    paymentDate: Date | null
    referenceNumber: string | null
    receiptFilePath: string | null
    status: $Enums.payment_status_enum | null
    uploadedBy: string | null
    uploadedAt: Date | null
    verifiedAt: Date | null
    verifiedBy: string | null
    verificationNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    amount: Decimal | null
    paymentMethod: $Enums.payment_method_enum | null
    paymentDate: Date | null
    referenceNumber: string | null
    receiptFilePath: string | null
    status: $Enums.payment_status_enum | null
    uploadedBy: string | null
    uploadedAt: Date | null
    verifiedAt: Date | null
    verifiedBy: string | null
    verificationNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    amount: number
    paymentMethod: number
    paymentDate: number
    referenceNumber: number
    receiptFilePath: number
    status: number
    uploadedBy: number
    uploadedAt: number
    verifiedAt: number
    verifiedBy: number
    verificationNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    referenceNumber?: true
    receiptFilePath?: true
    status?: true
    uploadedBy?: true
    uploadedAt?: true
    verifiedAt?: true
    verifiedBy?: true
    verificationNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    referenceNumber?: true
    receiptFilePath?: true
    status?: true
    uploadedBy?: true
    uploadedAt?: true
    verifiedAt?: true
    verifiedBy?: true
    verificationNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    referenceNumber?: true
    receiptFilePath?: true
    status?: true
    uploadedBy?: true
    uploadedAt?: true
    verifiedAt?: true
    verifiedBy?: true
    verificationNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    amount: Decimal
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date
    referenceNumber: string | null
    receiptFilePath: string
    status: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt: Date
    verifiedAt: Date | null
    verifiedBy: string | null
    verificationNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    receiptFilePath?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    verifiedByUser?: boolean | Payment$verifiedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    receiptFilePath?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    verifiedByUser?: boolean | Payment$verifiedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    receiptFilePath?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    verifiedByUser?: boolean | Payment$verifiedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    receiptFilePath?: boolean
    status?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "amount" | "paymentMethod" | "paymentDate" | "referenceNumber" | "receiptFilePath" | "status" | "uploadedBy" | "uploadedAt" | "verifiedAt" | "verifiedBy" | "verificationNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    verifiedByUser?: boolean | Payment$verifiedByUserArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    verifiedByUser?: boolean | Payment$verifiedByUserArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
    verifiedByUser?: boolean | Payment$verifiedByUserArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      uploadedByUser: Prisma.$UserPayload<ExtArgs>
      verifiedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      amount: Prisma.Decimal
      paymentMethod: $Enums.payment_method_enum
      paymentDate: Date
      referenceNumber: string | null
      receiptFilePath: string
      status: $Enums.payment_status_enum
      uploadedBy: string
      uploadedAt: Date
      verifiedAt: Date | null
      verifiedBy: string | null
      verificationNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verifiedByUser<T extends Payment$verifiedByUserArgs<ExtArgs> = {}>(args?: Subset<T, Payment$verifiedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentMethod: FieldRef<"Payment", 'payment_method_enum'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly referenceNumber: FieldRef<"Payment", 'String'>
    readonly receiptFilePath: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'payment_status_enum'>
    readonly uploadedBy: FieldRef<"Payment", 'String'>
    readonly uploadedAt: FieldRef<"Payment", 'DateTime'>
    readonly verifiedAt: FieldRef<"Payment", 'DateTime'>
    readonly verifiedBy: FieldRef<"Payment", 'String'>
    readonly verificationNotes: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.verifiedByUser
   */
  export type Payment$verifiedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model SampleTracking
   */

  export type AggregateSampleTracking = {
    _count: SampleTrackingCountAggregateOutputType | null
    _min: SampleTrackingMinAggregateOutputType | null
    _max: SampleTrackingMaxAggregateOutputType | null
  }

  export type SampleTrackingMinAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    sampleIdentifier: string | null
    status: $Enums.sample_status_enum | null
    receivedAt: Date | null
    analysisStartAt: Date | null
    analysisCompleteAt: Date | null
    returnRequestedAt: Date | null
    returnedAt: Date | null
    notes: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SampleTrackingMaxAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    sampleIdentifier: string | null
    status: $Enums.sample_status_enum | null
    receivedAt: Date | null
    analysisStartAt: Date | null
    analysisCompleteAt: Date | null
    returnRequestedAt: Date | null
    returnedAt: Date | null
    notes: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SampleTrackingCountAggregateOutputType = {
    id: number
    bookingServiceItemId: number
    sampleIdentifier: number
    status: number
    receivedAt: number
    analysisStartAt: number
    analysisCompleteAt: number
    returnRequestedAt: number
    returnedAt: number
    notes: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SampleTrackingMinAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    sampleIdentifier?: true
    status?: true
    receivedAt?: true
    analysisStartAt?: true
    analysisCompleteAt?: true
    returnRequestedAt?: true
    returnedAt?: true
    notes?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SampleTrackingMaxAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    sampleIdentifier?: true
    status?: true
    receivedAt?: true
    analysisStartAt?: true
    analysisCompleteAt?: true
    returnRequestedAt?: true
    returnedAt?: true
    notes?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SampleTrackingCountAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    sampleIdentifier?: true
    status?: true
    receivedAt?: true
    analysisStartAt?: true
    analysisCompleteAt?: true
    returnRequestedAt?: true
    returnedAt?: true
    notes?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SampleTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SampleTracking to aggregate.
     */
    where?: SampleTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleTrackings to fetch.
     */
    orderBy?: SampleTrackingOrderByWithRelationInput | SampleTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SampleTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SampleTrackings
    **/
    _count?: true | SampleTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SampleTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SampleTrackingMaxAggregateInputType
  }

  export type GetSampleTrackingAggregateType<T extends SampleTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateSampleTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSampleTracking[P]>
      : GetScalarType<T[P], AggregateSampleTracking[P]>
  }




  export type SampleTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleTrackingWhereInput
    orderBy?: SampleTrackingOrderByWithAggregationInput | SampleTrackingOrderByWithAggregationInput[]
    by: SampleTrackingScalarFieldEnum[] | SampleTrackingScalarFieldEnum
    having?: SampleTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SampleTrackingCountAggregateInputType | true
    _min?: SampleTrackingMinAggregateInputType
    _max?: SampleTrackingMaxAggregateInputType
  }

  export type SampleTrackingGroupByOutputType = {
    id: string
    bookingServiceItemId: string
    sampleIdentifier: string
    status: $Enums.sample_status_enum
    receivedAt: Date | null
    analysisStartAt: Date | null
    analysisCompleteAt: Date | null
    returnRequestedAt: Date | null
    returnedAt: Date | null
    notes: string | null
    updatedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SampleTrackingCountAggregateOutputType | null
    _min: SampleTrackingMinAggregateOutputType | null
    _max: SampleTrackingMaxAggregateOutputType | null
  }

  type GetSampleTrackingGroupByPayload<T extends SampleTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SampleTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SampleTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SampleTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], SampleTrackingGroupByOutputType[P]>
        }
      >
    >


  export type SampleTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    sampleIdentifier?: boolean
    status?: boolean
    receivedAt?: boolean
    analysisStartAt?: boolean
    analysisCompleteAt?: boolean
    returnRequestedAt?: boolean
    returnedAt?: boolean
    notes?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    updatedByUser?: boolean | SampleTracking$updatedByUserArgs<ExtArgs>
    analysisResults?: boolean | SampleTracking$analysisResultsArgs<ExtArgs>
    _count?: boolean | SampleTrackingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sampleTracking"]>

  export type SampleTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    sampleIdentifier?: boolean
    status?: boolean
    receivedAt?: boolean
    analysisStartAt?: boolean
    analysisCompleteAt?: boolean
    returnRequestedAt?: boolean
    returnedAt?: boolean
    notes?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    updatedByUser?: boolean | SampleTracking$updatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["sampleTracking"]>

  export type SampleTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    sampleIdentifier?: boolean
    status?: boolean
    receivedAt?: boolean
    analysisStartAt?: boolean
    analysisCompleteAt?: boolean
    returnRequestedAt?: boolean
    returnedAt?: boolean
    notes?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    updatedByUser?: boolean | SampleTracking$updatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["sampleTracking"]>

  export type SampleTrackingSelectScalar = {
    id?: boolean
    bookingServiceItemId?: boolean
    sampleIdentifier?: boolean
    status?: boolean
    receivedAt?: boolean
    analysisStartAt?: boolean
    analysisCompleteAt?: boolean
    returnRequestedAt?: boolean
    returnedAt?: boolean
    notes?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SampleTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingServiceItemId" | "sampleIdentifier" | "status" | "receivedAt" | "analysisStartAt" | "analysisCompleteAt" | "returnRequestedAt" | "returnedAt" | "notes" | "updatedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["sampleTracking"]>
  export type SampleTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    updatedByUser?: boolean | SampleTracking$updatedByUserArgs<ExtArgs>
    analysisResults?: boolean | SampleTracking$analysisResultsArgs<ExtArgs>
    _count?: boolean | SampleTrackingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SampleTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    updatedByUser?: boolean | SampleTracking$updatedByUserArgs<ExtArgs>
  }
  export type SampleTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    updatedByUser?: boolean | SampleTracking$updatedByUserArgs<ExtArgs>
  }

  export type $SampleTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SampleTracking"
    objects: {
      bookingServiceItem: Prisma.$BookingServiceItemPayload<ExtArgs>
      updatedByUser: Prisma.$UserPayload<ExtArgs> | null
      analysisResults: Prisma.$AnalysisResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingServiceItemId: string
      sampleIdentifier: string
      status: $Enums.sample_status_enum
      receivedAt: Date | null
      analysisStartAt: Date | null
      analysisCompleteAt: Date | null
      returnRequestedAt: Date | null
      returnedAt: Date | null
      notes: string | null
      updatedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sampleTracking"]>
    composites: {}
  }

  type SampleTrackingGetPayload<S extends boolean | null | undefined | SampleTrackingDefaultArgs> = $Result.GetResult<Prisma.$SampleTrackingPayload, S>

  type SampleTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SampleTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SampleTrackingCountAggregateInputType | true
    }

  export interface SampleTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SampleTracking'], meta: { name: 'SampleTracking' } }
    /**
     * Find zero or one SampleTracking that matches the filter.
     * @param {SampleTrackingFindUniqueArgs} args - Arguments to find a SampleTracking
     * @example
     * // Get one SampleTracking
     * const sampleTracking = await prisma.sampleTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SampleTrackingFindUniqueArgs>(args: SelectSubset<T, SampleTrackingFindUniqueArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SampleTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SampleTrackingFindUniqueOrThrowArgs} args - Arguments to find a SampleTracking
     * @example
     * // Get one SampleTracking
     * const sampleTracking = await prisma.sampleTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SampleTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, SampleTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SampleTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingFindFirstArgs} args - Arguments to find a SampleTracking
     * @example
     * // Get one SampleTracking
     * const sampleTracking = await prisma.sampleTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SampleTrackingFindFirstArgs>(args?: SelectSubset<T, SampleTrackingFindFirstArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SampleTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingFindFirstOrThrowArgs} args - Arguments to find a SampleTracking
     * @example
     * // Get one SampleTracking
     * const sampleTracking = await prisma.sampleTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SampleTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, SampleTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SampleTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SampleTrackings
     * const sampleTrackings = await prisma.sampleTracking.findMany()
     * 
     * // Get first 10 SampleTrackings
     * const sampleTrackings = await prisma.sampleTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sampleTrackingWithIdOnly = await prisma.sampleTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SampleTrackingFindManyArgs>(args?: SelectSubset<T, SampleTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SampleTracking.
     * @param {SampleTrackingCreateArgs} args - Arguments to create a SampleTracking.
     * @example
     * // Create one SampleTracking
     * const SampleTracking = await prisma.sampleTracking.create({
     *   data: {
     *     // ... data to create a SampleTracking
     *   }
     * })
     * 
     */
    create<T extends SampleTrackingCreateArgs>(args: SelectSubset<T, SampleTrackingCreateArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SampleTrackings.
     * @param {SampleTrackingCreateManyArgs} args - Arguments to create many SampleTrackings.
     * @example
     * // Create many SampleTrackings
     * const sampleTracking = await prisma.sampleTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SampleTrackingCreateManyArgs>(args?: SelectSubset<T, SampleTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SampleTrackings and returns the data saved in the database.
     * @param {SampleTrackingCreateManyAndReturnArgs} args - Arguments to create many SampleTrackings.
     * @example
     * // Create many SampleTrackings
     * const sampleTracking = await prisma.sampleTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SampleTrackings and only return the `id`
     * const sampleTrackingWithIdOnly = await prisma.sampleTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SampleTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, SampleTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SampleTracking.
     * @param {SampleTrackingDeleteArgs} args - Arguments to delete one SampleTracking.
     * @example
     * // Delete one SampleTracking
     * const SampleTracking = await prisma.sampleTracking.delete({
     *   where: {
     *     // ... filter to delete one SampleTracking
     *   }
     * })
     * 
     */
    delete<T extends SampleTrackingDeleteArgs>(args: SelectSubset<T, SampleTrackingDeleteArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SampleTracking.
     * @param {SampleTrackingUpdateArgs} args - Arguments to update one SampleTracking.
     * @example
     * // Update one SampleTracking
     * const sampleTracking = await prisma.sampleTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SampleTrackingUpdateArgs>(args: SelectSubset<T, SampleTrackingUpdateArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SampleTrackings.
     * @param {SampleTrackingDeleteManyArgs} args - Arguments to filter SampleTrackings to delete.
     * @example
     * // Delete a few SampleTrackings
     * const { count } = await prisma.sampleTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SampleTrackingDeleteManyArgs>(args?: SelectSubset<T, SampleTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SampleTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SampleTrackings
     * const sampleTracking = await prisma.sampleTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SampleTrackingUpdateManyArgs>(args: SelectSubset<T, SampleTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SampleTrackings and returns the data updated in the database.
     * @param {SampleTrackingUpdateManyAndReturnArgs} args - Arguments to update many SampleTrackings.
     * @example
     * // Update many SampleTrackings
     * const sampleTracking = await prisma.sampleTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SampleTrackings and only return the `id`
     * const sampleTrackingWithIdOnly = await prisma.sampleTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SampleTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, SampleTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SampleTracking.
     * @param {SampleTrackingUpsertArgs} args - Arguments to update or create a SampleTracking.
     * @example
     * // Update or create a SampleTracking
     * const sampleTracking = await prisma.sampleTracking.upsert({
     *   create: {
     *     // ... data to create a SampleTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SampleTracking we want to update
     *   }
     * })
     */
    upsert<T extends SampleTrackingUpsertArgs>(args: SelectSubset<T, SampleTrackingUpsertArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SampleTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingCountArgs} args - Arguments to filter SampleTrackings to count.
     * @example
     * // Count the number of SampleTrackings
     * const count = await prisma.sampleTracking.count({
     *   where: {
     *     // ... the filter for the SampleTrackings we want to count
     *   }
     * })
    **/
    count<T extends SampleTrackingCountArgs>(
      args?: Subset<T, SampleTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SampleTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SampleTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SampleTrackingAggregateArgs>(args: Subset<T, SampleTrackingAggregateArgs>): Prisma.PrismaPromise<GetSampleTrackingAggregateType<T>>

    /**
     * Group by SampleTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SampleTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SampleTrackingGroupByArgs['orderBy'] }
        : { orderBy?: SampleTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SampleTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSampleTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SampleTracking model
   */
  readonly fields: SampleTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SampleTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SampleTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingServiceItem<T extends BookingServiceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItemDefaultArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedByUser<T extends SampleTracking$updatedByUserArgs<ExtArgs> = {}>(args?: Subset<T, SampleTracking$updatedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    analysisResults<T extends SampleTracking$analysisResultsArgs<ExtArgs> = {}>(args?: Subset<T, SampleTracking$analysisResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SampleTracking model
   */
  interface SampleTrackingFieldRefs {
    readonly id: FieldRef<"SampleTracking", 'String'>
    readonly bookingServiceItemId: FieldRef<"SampleTracking", 'String'>
    readonly sampleIdentifier: FieldRef<"SampleTracking", 'String'>
    readonly status: FieldRef<"SampleTracking", 'sample_status_enum'>
    readonly receivedAt: FieldRef<"SampleTracking", 'DateTime'>
    readonly analysisStartAt: FieldRef<"SampleTracking", 'DateTime'>
    readonly analysisCompleteAt: FieldRef<"SampleTracking", 'DateTime'>
    readonly returnRequestedAt: FieldRef<"SampleTracking", 'DateTime'>
    readonly returnedAt: FieldRef<"SampleTracking", 'DateTime'>
    readonly notes: FieldRef<"SampleTracking", 'String'>
    readonly updatedBy: FieldRef<"SampleTracking", 'String'>
    readonly createdAt: FieldRef<"SampleTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"SampleTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SampleTracking findUnique
   */
  export type SampleTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * Filter, which SampleTracking to fetch.
     */
    where: SampleTrackingWhereUniqueInput
  }

  /**
   * SampleTracking findUniqueOrThrow
   */
  export type SampleTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * Filter, which SampleTracking to fetch.
     */
    where: SampleTrackingWhereUniqueInput
  }

  /**
   * SampleTracking findFirst
   */
  export type SampleTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * Filter, which SampleTracking to fetch.
     */
    where?: SampleTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleTrackings to fetch.
     */
    orderBy?: SampleTrackingOrderByWithRelationInput | SampleTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SampleTrackings.
     */
    cursor?: SampleTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SampleTrackings.
     */
    distinct?: SampleTrackingScalarFieldEnum | SampleTrackingScalarFieldEnum[]
  }

  /**
   * SampleTracking findFirstOrThrow
   */
  export type SampleTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * Filter, which SampleTracking to fetch.
     */
    where?: SampleTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleTrackings to fetch.
     */
    orderBy?: SampleTrackingOrderByWithRelationInput | SampleTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SampleTrackings.
     */
    cursor?: SampleTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SampleTrackings.
     */
    distinct?: SampleTrackingScalarFieldEnum | SampleTrackingScalarFieldEnum[]
  }

  /**
   * SampleTracking findMany
   */
  export type SampleTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * Filter, which SampleTrackings to fetch.
     */
    where?: SampleTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleTrackings to fetch.
     */
    orderBy?: SampleTrackingOrderByWithRelationInput | SampleTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SampleTrackings.
     */
    cursor?: SampleTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleTrackings.
     */
    skip?: number
    distinct?: SampleTrackingScalarFieldEnum | SampleTrackingScalarFieldEnum[]
  }

  /**
   * SampleTracking create
   */
  export type SampleTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a SampleTracking.
     */
    data: XOR<SampleTrackingCreateInput, SampleTrackingUncheckedCreateInput>
  }

  /**
   * SampleTracking createMany
   */
  export type SampleTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SampleTrackings.
     */
    data: SampleTrackingCreateManyInput | SampleTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SampleTracking createManyAndReturn
   */
  export type SampleTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many SampleTrackings.
     */
    data: SampleTrackingCreateManyInput | SampleTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SampleTracking update
   */
  export type SampleTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a SampleTracking.
     */
    data: XOR<SampleTrackingUpdateInput, SampleTrackingUncheckedUpdateInput>
    /**
     * Choose, which SampleTracking to update.
     */
    where: SampleTrackingWhereUniqueInput
  }

  /**
   * SampleTracking updateMany
   */
  export type SampleTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SampleTrackings.
     */
    data: XOR<SampleTrackingUpdateManyMutationInput, SampleTrackingUncheckedUpdateManyInput>
    /**
     * Filter which SampleTrackings to update
     */
    where?: SampleTrackingWhereInput
    /**
     * Limit how many SampleTrackings to update.
     */
    limit?: number
  }

  /**
   * SampleTracking updateManyAndReturn
   */
  export type SampleTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * The data used to update SampleTrackings.
     */
    data: XOR<SampleTrackingUpdateManyMutationInput, SampleTrackingUncheckedUpdateManyInput>
    /**
     * Filter which SampleTrackings to update
     */
    where?: SampleTrackingWhereInput
    /**
     * Limit how many SampleTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SampleTracking upsert
   */
  export type SampleTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the SampleTracking to update in case it exists.
     */
    where: SampleTrackingWhereUniqueInput
    /**
     * In case the SampleTracking found by the `where` argument doesn't exist, create a new SampleTracking with this data.
     */
    create: XOR<SampleTrackingCreateInput, SampleTrackingUncheckedCreateInput>
    /**
     * In case the SampleTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SampleTrackingUpdateInput, SampleTrackingUncheckedUpdateInput>
  }

  /**
   * SampleTracking delete
   */
  export type SampleTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
    /**
     * Filter which SampleTracking to delete.
     */
    where: SampleTrackingWhereUniqueInput
  }

  /**
   * SampleTracking deleteMany
   */
  export type SampleTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SampleTrackings to delete
     */
    where?: SampleTrackingWhereInput
    /**
     * Limit how many SampleTrackings to delete.
     */
    limit?: number
  }

  /**
   * SampleTracking.updatedByUser
   */
  export type SampleTracking$updatedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SampleTracking.analysisResults
   */
  export type SampleTracking$analysisResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    where?: AnalysisResultWhereInput
    orderBy?: AnalysisResultOrderByWithRelationInput | AnalysisResultOrderByWithRelationInput[]
    cursor?: AnalysisResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalysisResultScalarFieldEnum | AnalysisResultScalarFieldEnum[]
  }

  /**
   * SampleTracking without action
   */
  export type SampleTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleTracking
     */
    select?: SampleTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleTracking
     */
    omit?: SampleTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleTrackingInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceBooking
   */

  export type AggregateWorkspaceBooking = {
    _count: WorkspaceBookingCountAggregateOutputType | null
    _min: WorkspaceBookingMinAggregateOutputType | null
    _max: WorkspaceBookingMaxAggregateOutputType | null
  }

  export type WorkspaceBookingMinAggregateOutputType = {
    id: string | null
    bookingRequestId: string | null
    startDate: Date | null
    endDate: Date | null
    preferredTimeSlot: string | null
    purpose: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceBookingMaxAggregateOutputType = {
    id: string | null
    bookingRequestId: string | null
    startDate: Date | null
    endDate: Date | null
    preferredTimeSlot: string | null
    purpose: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceBookingCountAggregateOutputType = {
    id: number
    bookingRequestId: number
    startDate: number
    endDate: number
    preferredTimeSlot: number
    specialEquipment: number
    purpose: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceBookingMinAggregateInputType = {
    id?: true
    bookingRequestId?: true
    startDate?: true
    endDate?: true
    preferredTimeSlot?: true
    purpose?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceBookingMaxAggregateInputType = {
    id?: true
    bookingRequestId?: true
    startDate?: true
    endDate?: true
    preferredTimeSlot?: true
    purpose?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceBookingCountAggregateInputType = {
    id?: true
    bookingRequestId?: true
    startDate?: true
    endDate?: true
    preferredTimeSlot?: true
    specialEquipment?: true
    purpose?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceBooking to aggregate.
     */
    where?: WorkspaceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceBookings to fetch.
     */
    orderBy?: WorkspaceBookingOrderByWithRelationInput | WorkspaceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceBookings
    **/
    _count?: true | WorkspaceBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceBookingMaxAggregateInputType
  }

  export type GetWorkspaceBookingAggregateType<T extends WorkspaceBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceBooking[P]>
      : GetScalarType<T[P], AggregateWorkspaceBooking[P]>
  }




  export type WorkspaceBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceBookingWhereInput
    orderBy?: WorkspaceBookingOrderByWithAggregationInput | WorkspaceBookingOrderByWithAggregationInput[]
    by: WorkspaceBookingScalarFieldEnum[] | WorkspaceBookingScalarFieldEnum
    having?: WorkspaceBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceBookingCountAggregateInputType | true
    _min?: WorkspaceBookingMinAggregateInputType
    _max?: WorkspaceBookingMaxAggregateInputType
  }

  export type WorkspaceBookingGroupByOutputType = {
    id: string
    bookingRequestId: string
    startDate: Date
    endDate: Date
    preferredTimeSlot: string | null
    specialEquipment: JsonValue | null
    purpose: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceBookingCountAggregateOutputType | null
    _min: WorkspaceBookingMinAggregateOutputType | null
    _max: WorkspaceBookingMaxAggregateOutputType | null
  }

  type GetWorkspaceBookingGroupByPayload<T extends WorkspaceBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceBookingGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceBookingGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    startDate?: boolean
    endDate?: boolean
    preferredTimeSlot?: boolean
    specialEquipment?: boolean
    purpose?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    equipmentUsages?: boolean | WorkspaceBooking$equipmentUsagesArgs<ExtArgs>
    serviceAddOns?: boolean | WorkspaceBooking$serviceAddOnsArgs<ExtArgs>
    _count?: boolean | WorkspaceBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceBooking"]>

  export type WorkspaceBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    startDate?: boolean
    endDate?: boolean
    preferredTimeSlot?: boolean
    specialEquipment?: boolean
    purpose?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceBooking"]>

  export type WorkspaceBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingRequestId?: boolean
    startDate?: boolean
    endDate?: boolean
    preferredTimeSlot?: boolean
    specialEquipment?: boolean
    purpose?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceBooking"]>

  export type WorkspaceBookingSelectScalar = {
    id?: boolean
    bookingRequestId?: boolean
    startDate?: boolean
    endDate?: boolean
    preferredTimeSlot?: boolean
    specialEquipment?: boolean
    purpose?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingRequestId" | "startDate" | "endDate" | "preferredTimeSlot" | "specialEquipment" | "purpose" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["workspaceBooking"]>
  export type WorkspaceBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
    equipmentUsages?: boolean | WorkspaceBooking$equipmentUsagesArgs<ExtArgs>
    serviceAddOns?: boolean | WorkspaceBooking$serviceAddOnsArgs<ExtArgs>
    _count?: boolean | WorkspaceBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
  }
  export type WorkspaceBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingRequest?: boolean | BookingRequestDefaultArgs<ExtArgs>
  }

  export type $WorkspaceBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceBooking"
    objects: {
      bookingRequest: Prisma.$BookingRequestPayload<ExtArgs>
      equipmentUsages: Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>[]
      serviceAddOns: Prisma.$ServiceAddOnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingRequestId: string
      startDate: Date
      endDate: Date
      preferredTimeSlot: string | null
      specialEquipment: Prisma.JsonValue | null
      purpose: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspaceBooking"]>
    composites: {}
  }

  type WorkspaceBookingGetPayload<S extends boolean | null | undefined | WorkspaceBookingDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceBookingPayload, S>

  type WorkspaceBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceBookingCountAggregateInputType | true
    }

  export interface WorkspaceBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceBooking'], meta: { name: 'WorkspaceBooking' } }
    /**
     * Find zero or one WorkspaceBooking that matches the filter.
     * @param {WorkspaceBookingFindUniqueArgs} args - Arguments to find a WorkspaceBooking
     * @example
     * // Get one WorkspaceBooking
     * const workspaceBooking = await prisma.workspaceBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceBookingFindUniqueArgs>(args: SelectSubset<T, WorkspaceBookingFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceBookingFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceBooking
     * @example
     * // Get one WorkspaceBooking
     * const workspaceBooking = await prisma.workspaceBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingFindFirstArgs} args - Arguments to find a WorkspaceBooking
     * @example
     * // Get one WorkspaceBooking
     * const workspaceBooking = await prisma.workspaceBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceBookingFindFirstArgs>(args?: SelectSubset<T, WorkspaceBookingFindFirstArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingFindFirstOrThrowArgs} args - Arguments to find a WorkspaceBooking
     * @example
     * // Get one WorkspaceBooking
     * const workspaceBooking = await prisma.workspaceBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceBookings
     * const workspaceBookings = await prisma.workspaceBooking.findMany()
     * 
     * // Get first 10 WorkspaceBookings
     * const workspaceBookings = await prisma.workspaceBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceBookingWithIdOnly = await prisma.workspaceBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceBookingFindManyArgs>(args?: SelectSubset<T, WorkspaceBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceBooking.
     * @param {WorkspaceBookingCreateArgs} args - Arguments to create a WorkspaceBooking.
     * @example
     * // Create one WorkspaceBooking
     * const WorkspaceBooking = await prisma.workspaceBooking.create({
     *   data: {
     *     // ... data to create a WorkspaceBooking
     *   }
     * })
     * 
     */
    create<T extends WorkspaceBookingCreateArgs>(args: SelectSubset<T, WorkspaceBookingCreateArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceBookings.
     * @param {WorkspaceBookingCreateManyArgs} args - Arguments to create many WorkspaceBookings.
     * @example
     * // Create many WorkspaceBookings
     * const workspaceBooking = await prisma.workspaceBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceBookingCreateManyArgs>(args?: SelectSubset<T, WorkspaceBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceBookings and returns the data saved in the database.
     * @param {WorkspaceBookingCreateManyAndReturnArgs} args - Arguments to create many WorkspaceBookings.
     * @example
     * // Create many WorkspaceBookings
     * const workspaceBooking = await prisma.workspaceBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceBookings and only return the `id`
     * const workspaceBookingWithIdOnly = await prisma.workspaceBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceBooking.
     * @param {WorkspaceBookingDeleteArgs} args - Arguments to delete one WorkspaceBooking.
     * @example
     * // Delete one WorkspaceBooking
     * const WorkspaceBooking = await prisma.workspaceBooking.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceBooking
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceBookingDeleteArgs>(args: SelectSubset<T, WorkspaceBookingDeleteArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceBooking.
     * @param {WorkspaceBookingUpdateArgs} args - Arguments to update one WorkspaceBooking.
     * @example
     * // Update one WorkspaceBooking
     * const workspaceBooking = await prisma.workspaceBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceBookingUpdateArgs>(args: SelectSubset<T, WorkspaceBookingUpdateArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceBookings.
     * @param {WorkspaceBookingDeleteManyArgs} args - Arguments to filter WorkspaceBookings to delete.
     * @example
     * // Delete a few WorkspaceBookings
     * const { count } = await prisma.workspaceBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceBookingDeleteManyArgs>(args?: SelectSubset<T, WorkspaceBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceBookings
     * const workspaceBooking = await prisma.workspaceBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceBookingUpdateManyArgs>(args: SelectSubset<T, WorkspaceBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceBookings and returns the data updated in the database.
     * @param {WorkspaceBookingUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceBookings.
     * @example
     * // Update many WorkspaceBookings
     * const workspaceBooking = await prisma.workspaceBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceBookings and only return the `id`
     * const workspaceBookingWithIdOnly = await prisma.workspaceBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceBooking.
     * @param {WorkspaceBookingUpsertArgs} args - Arguments to update or create a WorkspaceBooking.
     * @example
     * // Update or create a WorkspaceBooking
     * const workspaceBooking = await prisma.workspaceBooking.upsert({
     *   create: {
     *     // ... data to create a WorkspaceBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceBooking we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceBookingUpsertArgs>(args: SelectSubset<T, WorkspaceBookingUpsertArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingCountArgs} args - Arguments to filter WorkspaceBookings to count.
     * @example
     * // Count the number of WorkspaceBookings
     * const count = await prisma.workspaceBooking.count({
     *   where: {
     *     // ... the filter for the WorkspaceBookings we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceBookingCountArgs>(
      args?: Subset<T, WorkspaceBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceBookingAggregateArgs>(args: Subset<T, WorkspaceBookingAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceBookingAggregateType<T>>

    /**
     * Group by WorkspaceBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceBookingGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceBooking model
   */
  readonly fields: WorkspaceBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingRequest<T extends BookingRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingRequestDefaultArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipmentUsages<T extends WorkspaceBooking$equipmentUsagesArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceBooking$equipmentUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceAddOns<T extends WorkspaceBooking$serviceAddOnsArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceBooking$serviceAddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceBooking model
   */
  interface WorkspaceBookingFieldRefs {
    readonly id: FieldRef<"WorkspaceBooking", 'String'>
    readonly bookingRequestId: FieldRef<"WorkspaceBooking", 'String'>
    readonly startDate: FieldRef<"WorkspaceBooking", 'DateTime'>
    readonly endDate: FieldRef<"WorkspaceBooking", 'DateTime'>
    readonly preferredTimeSlot: FieldRef<"WorkspaceBooking", 'String'>
    readonly specialEquipment: FieldRef<"WorkspaceBooking", 'Json'>
    readonly purpose: FieldRef<"WorkspaceBooking", 'String'>
    readonly notes: FieldRef<"WorkspaceBooking", 'String'>
    readonly createdAt: FieldRef<"WorkspaceBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceBooking findUnique
   */
  export type WorkspaceBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceBooking to fetch.
     */
    where: WorkspaceBookingWhereUniqueInput
  }

  /**
   * WorkspaceBooking findUniqueOrThrow
   */
  export type WorkspaceBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceBooking to fetch.
     */
    where: WorkspaceBookingWhereUniqueInput
  }

  /**
   * WorkspaceBooking findFirst
   */
  export type WorkspaceBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceBooking to fetch.
     */
    where?: WorkspaceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceBookings to fetch.
     */
    orderBy?: WorkspaceBookingOrderByWithRelationInput | WorkspaceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceBookings.
     */
    cursor?: WorkspaceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceBookings.
     */
    distinct?: WorkspaceBookingScalarFieldEnum | WorkspaceBookingScalarFieldEnum[]
  }

  /**
   * WorkspaceBooking findFirstOrThrow
   */
  export type WorkspaceBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceBooking to fetch.
     */
    where?: WorkspaceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceBookings to fetch.
     */
    orderBy?: WorkspaceBookingOrderByWithRelationInput | WorkspaceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceBookings.
     */
    cursor?: WorkspaceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceBookings.
     */
    distinct?: WorkspaceBookingScalarFieldEnum | WorkspaceBookingScalarFieldEnum[]
  }

  /**
   * WorkspaceBooking findMany
   */
  export type WorkspaceBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceBookings to fetch.
     */
    where?: WorkspaceBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceBookings to fetch.
     */
    orderBy?: WorkspaceBookingOrderByWithRelationInput | WorkspaceBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceBookings.
     */
    cursor?: WorkspaceBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceBookings.
     */
    skip?: number
    distinct?: WorkspaceBookingScalarFieldEnum | WorkspaceBookingScalarFieldEnum[]
  }

  /**
   * WorkspaceBooking create
   */
  export type WorkspaceBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceBooking.
     */
    data: XOR<WorkspaceBookingCreateInput, WorkspaceBookingUncheckedCreateInput>
  }

  /**
   * WorkspaceBooking createMany
   */
  export type WorkspaceBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceBookings.
     */
    data: WorkspaceBookingCreateManyInput | WorkspaceBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceBooking createManyAndReturn
   */
  export type WorkspaceBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceBookings.
     */
    data: WorkspaceBookingCreateManyInput | WorkspaceBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceBooking update
   */
  export type WorkspaceBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceBooking.
     */
    data: XOR<WorkspaceBookingUpdateInput, WorkspaceBookingUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceBooking to update.
     */
    where: WorkspaceBookingWhereUniqueInput
  }

  /**
   * WorkspaceBooking updateMany
   */
  export type WorkspaceBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceBookings.
     */
    data: XOR<WorkspaceBookingUpdateManyMutationInput, WorkspaceBookingUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceBookings to update
     */
    where?: WorkspaceBookingWhereInput
    /**
     * Limit how many WorkspaceBookings to update.
     */
    limit?: number
  }

  /**
   * WorkspaceBooking updateManyAndReturn
   */
  export type WorkspaceBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceBookings.
     */
    data: XOR<WorkspaceBookingUpdateManyMutationInput, WorkspaceBookingUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceBookings to update
     */
    where?: WorkspaceBookingWhereInput
    /**
     * Limit how many WorkspaceBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceBooking upsert
   */
  export type WorkspaceBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceBooking to update in case it exists.
     */
    where: WorkspaceBookingWhereUniqueInput
    /**
     * In case the WorkspaceBooking found by the `where` argument doesn't exist, create a new WorkspaceBooking with this data.
     */
    create: XOR<WorkspaceBookingCreateInput, WorkspaceBookingUncheckedCreateInput>
    /**
     * In case the WorkspaceBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceBookingUpdateInput, WorkspaceBookingUncheckedUpdateInput>
  }

  /**
   * WorkspaceBooking delete
   */
  export type WorkspaceBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceBooking to delete.
     */
    where: WorkspaceBookingWhereUniqueInput
  }

  /**
   * WorkspaceBooking deleteMany
   */
  export type WorkspaceBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceBookings to delete
     */
    where?: WorkspaceBookingWhereInput
    /**
     * Limit how many WorkspaceBookings to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceBooking.equipmentUsages
   */
  export type WorkspaceBooking$equipmentUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    where?: WorkspaceEquipmentUsageWhereInput
    orderBy?: WorkspaceEquipmentUsageOrderByWithRelationInput | WorkspaceEquipmentUsageOrderByWithRelationInput[]
    cursor?: WorkspaceEquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceEquipmentUsageScalarFieldEnum | WorkspaceEquipmentUsageScalarFieldEnum[]
  }

  /**
   * WorkspaceBooking.serviceAddOns
   */
  export type WorkspaceBooking$serviceAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    where?: ServiceAddOnWhereInput
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    cursor?: ServiceAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAddOnScalarFieldEnum | ServiceAddOnScalarFieldEnum[]
  }

  /**
   * WorkspaceBooking without action
   */
  export type WorkspaceBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
  }


  /**
   * Model LabEquipment
   */

  export type AggregateLabEquipment = {
    _count: LabEquipmentCountAggregateOutputType | null
    _min: LabEquipmentMinAggregateOutputType | null
    _max: LabEquipmentMaxAggregateOutputType | null
  }

  export type LabEquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isAvailable: boolean | null
    maintenanceNotes: string | null
    expectedMaintenanceEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabEquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isAvailable: boolean | null
    maintenanceNotes: string | null
    expectedMaintenanceEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabEquipmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isAvailable: number
    maintenanceNotes: number
    expectedMaintenanceEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabEquipmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isAvailable?: true
    maintenanceNotes?: true
    expectedMaintenanceEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabEquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isAvailable?: true
    maintenanceNotes?: true
    expectedMaintenanceEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabEquipmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isAvailable?: true
    maintenanceNotes?: true
    expectedMaintenanceEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabEquipment to aggregate.
     */
    where?: LabEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabEquipments to fetch.
     */
    orderBy?: LabEquipmentOrderByWithRelationInput | LabEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabEquipments
    **/
    _count?: true | LabEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabEquipmentMaxAggregateInputType
  }

  export type GetLabEquipmentAggregateType<T extends LabEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateLabEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabEquipment[P]>
      : GetScalarType<T[P], AggregateLabEquipment[P]>
  }




  export type LabEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabEquipmentWhereInput
    orderBy?: LabEquipmentOrderByWithAggregationInput | LabEquipmentOrderByWithAggregationInput[]
    by: LabEquipmentScalarFieldEnum[] | LabEquipmentScalarFieldEnum
    having?: LabEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabEquipmentCountAggregateInputType | true
    _min?: LabEquipmentMinAggregateInputType
    _max?: LabEquipmentMaxAggregateInputType
  }

  export type LabEquipmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isAvailable: boolean
    maintenanceNotes: string | null
    expectedMaintenanceEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LabEquipmentCountAggregateOutputType | null
    _min: LabEquipmentMinAggregateOutputType | null
    _max: LabEquipmentMaxAggregateOutputType | null
  }

  type GetLabEquipmentGroupByPayload<T extends LabEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], LabEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type LabEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isAvailable?: boolean
    maintenanceNotes?: boolean
    expectedMaintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceUsages?: boolean | LabEquipment$workspaceUsagesArgs<ExtArgs>
    sampleUsages?: boolean | LabEquipment$sampleUsagesArgs<ExtArgs>
    _count?: boolean | LabEquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labEquipment"]>

  export type LabEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isAvailable?: boolean
    maintenanceNotes?: boolean
    expectedMaintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["labEquipment"]>

  export type LabEquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isAvailable?: boolean
    maintenanceNotes?: boolean
    expectedMaintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["labEquipment"]>

  export type LabEquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isAvailable?: boolean
    maintenanceNotes?: boolean
    expectedMaintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabEquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isAvailable" | "maintenanceNotes" | "expectedMaintenanceEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["labEquipment"]>
  export type LabEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaceUsages?: boolean | LabEquipment$workspaceUsagesArgs<ExtArgs>
    sampleUsages?: boolean | LabEquipment$sampleUsagesArgs<ExtArgs>
    _count?: boolean | LabEquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LabEquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LabEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabEquipment"
    objects: {
      workspaceUsages: Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>[]
      sampleUsages: Prisma.$SampleEquipmentUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isAvailable: boolean
      maintenanceNotes: string | null
      expectedMaintenanceEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["labEquipment"]>
    composites: {}
  }

  type LabEquipmentGetPayload<S extends boolean | null | undefined | LabEquipmentDefaultArgs> = $Result.GetResult<Prisma.$LabEquipmentPayload, S>

  type LabEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabEquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabEquipmentCountAggregateInputType | true
    }

  export interface LabEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabEquipment'], meta: { name: 'LabEquipment' } }
    /**
     * Find zero or one LabEquipment that matches the filter.
     * @param {LabEquipmentFindUniqueArgs} args - Arguments to find a LabEquipment
     * @example
     * // Get one LabEquipment
     * const labEquipment = await prisma.labEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabEquipmentFindUniqueArgs>(args: SelectSubset<T, LabEquipmentFindUniqueArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabEquipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabEquipmentFindUniqueOrThrowArgs} args - Arguments to find a LabEquipment
     * @example
     * // Get one LabEquipment
     * const labEquipment = await prisma.labEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, LabEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentFindFirstArgs} args - Arguments to find a LabEquipment
     * @example
     * // Get one LabEquipment
     * const labEquipment = await prisma.labEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabEquipmentFindFirstArgs>(args?: SelectSubset<T, LabEquipmentFindFirstArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentFindFirstOrThrowArgs} args - Arguments to find a LabEquipment
     * @example
     * // Get one LabEquipment
     * const labEquipment = await prisma.labEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, LabEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabEquipments
     * const labEquipments = await prisma.labEquipment.findMany()
     * 
     * // Get first 10 LabEquipments
     * const labEquipments = await prisma.labEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labEquipmentWithIdOnly = await prisma.labEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabEquipmentFindManyArgs>(args?: SelectSubset<T, LabEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabEquipment.
     * @param {LabEquipmentCreateArgs} args - Arguments to create a LabEquipment.
     * @example
     * // Create one LabEquipment
     * const LabEquipment = await prisma.labEquipment.create({
     *   data: {
     *     // ... data to create a LabEquipment
     *   }
     * })
     * 
     */
    create<T extends LabEquipmentCreateArgs>(args: SelectSubset<T, LabEquipmentCreateArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabEquipments.
     * @param {LabEquipmentCreateManyArgs} args - Arguments to create many LabEquipments.
     * @example
     * // Create many LabEquipments
     * const labEquipment = await prisma.labEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabEquipmentCreateManyArgs>(args?: SelectSubset<T, LabEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabEquipments and returns the data saved in the database.
     * @param {LabEquipmentCreateManyAndReturnArgs} args - Arguments to create many LabEquipments.
     * @example
     * // Create many LabEquipments
     * const labEquipment = await prisma.labEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabEquipments and only return the `id`
     * const labEquipmentWithIdOnly = await prisma.labEquipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, LabEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabEquipment.
     * @param {LabEquipmentDeleteArgs} args - Arguments to delete one LabEquipment.
     * @example
     * // Delete one LabEquipment
     * const LabEquipment = await prisma.labEquipment.delete({
     *   where: {
     *     // ... filter to delete one LabEquipment
     *   }
     * })
     * 
     */
    delete<T extends LabEquipmentDeleteArgs>(args: SelectSubset<T, LabEquipmentDeleteArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabEquipment.
     * @param {LabEquipmentUpdateArgs} args - Arguments to update one LabEquipment.
     * @example
     * // Update one LabEquipment
     * const labEquipment = await prisma.labEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabEquipmentUpdateArgs>(args: SelectSubset<T, LabEquipmentUpdateArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabEquipments.
     * @param {LabEquipmentDeleteManyArgs} args - Arguments to filter LabEquipments to delete.
     * @example
     * // Delete a few LabEquipments
     * const { count } = await prisma.labEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabEquipmentDeleteManyArgs>(args?: SelectSubset<T, LabEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabEquipments
     * const labEquipment = await prisma.labEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabEquipmentUpdateManyArgs>(args: SelectSubset<T, LabEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabEquipments and returns the data updated in the database.
     * @param {LabEquipmentUpdateManyAndReturnArgs} args - Arguments to update many LabEquipments.
     * @example
     * // Update many LabEquipments
     * const labEquipment = await prisma.labEquipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabEquipments and only return the `id`
     * const labEquipmentWithIdOnly = await prisma.labEquipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabEquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, LabEquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabEquipment.
     * @param {LabEquipmentUpsertArgs} args - Arguments to update or create a LabEquipment.
     * @example
     * // Update or create a LabEquipment
     * const labEquipment = await prisma.labEquipment.upsert({
     *   create: {
     *     // ... data to create a LabEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabEquipment we want to update
     *   }
     * })
     */
    upsert<T extends LabEquipmentUpsertArgs>(args: SelectSubset<T, LabEquipmentUpsertArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentCountArgs} args - Arguments to filter LabEquipments to count.
     * @example
     * // Count the number of LabEquipments
     * const count = await prisma.labEquipment.count({
     *   where: {
     *     // ... the filter for the LabEquipments we want to count
     *   }
     * })
    **/
    count<T extends LabEquipmentCountArgs>(
      args?: Subset<T, LabEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabEquipmentAggregateArgs>(args: Subset<T, LabEquipmentAggregateArgs>): Prisma.PrismaPromise<GetLabEquipmentAggregateType<T>>

    /**
     * Group by LabEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: LabEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabEquipment model
   */
  readonly fields: LabEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaceUsages<T extends LabEquipment$workspaceUsagesArgs<ExtArgs> = {}>(args?: Subset<T, LabEquipment$workspaceUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sampleUsages<T extends LabEquipment$sampleUsagesArgs<ExtArgs> = {}>(args?: Subset<T, LabEquipment$sampleUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabEquipment model
   */
  interface LabEquipmentFieldRefs {
    readonly id: FieldRef<"LabEquipment", 'String'>
    readonly name: FieldRef<"LabEquipment", 'String'>
    readonly description: FieldRef<"LabEquipment", 'String'>
    readonly isAvailable: FieldRef<"LabEquipment", 'Boolean'>
    readonly maintenanceNotes: FieldRef<"LabEquipment", 'String'>
    readonly expectedMaintenanceEnd: FieldRef<"LabEquipment", 'DateTime'>
    readonly createdAt: FieldRef<"LabEquipment", 'DateTime'>
    readonly updatedAt: FieldRef<"LabEquipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabEquipment findUnique
   */
  export type LabEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which LabEquipment to fetch.
     */
    where: LabEquipmentWhereUniqueInput
  }

  /**
   * LabEquipment findUniqueOrThrow
   */
  export type LabEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which LabEquipment to fetch.
     */
    where: LabEquipmentWhereUniqueInput
  }

  /**
   * LabEquipment findFirst
   */
  export type LabEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which LabEquipment to fetch.
     */
    where?: LabEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabEquipments to fetch.
     */
    orderBy?: LabEquipmentOrderByWithRelationInput | LabEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabEquipments.
     */
    cursor?: LabEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabEquipments.
     */
    distinct?: LabEquipmentScalarFieldEnum | LabEquipmentScalarFieldEnum[]
  }

  /**
   * LabEquipment findFirstOrThrow
   */
  export type LabEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which LabEquipment to fetch.
     */
    where?: LabEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabEquipments to fetch.
     */
    orderBy?: LabEquipmentOrderByWithRelationInput | LabEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabEquipments.
     */
    cursor?: LabEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabEquipments.
     */
    distinct?: LabEquipmentScalarFieldEnum | LabEquipmentScalarFieldEnum[]
  }

  /**
   * LabEquipment findMany
   */
  export type LabEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which LabEquipments to fetch.
     */
    where?: LabEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabEquipments to fetch.
     */
    orderBy?: LabEquipmentOrderByWithRelationInput | LabEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabEquipments.
     */
    cursor?: LabEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabEquipments.
     */
    skip?: number
    distinct?: LabEquipmentScalarFieldEnum | LabEquipmentScalarFieldEnum[]
  }

  /**
   * LabEquipment create
   */
  export type LabEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a LabEquipment.
     */
    data: XOR<LabEquipmentCreateInput, LabEquipmentUncheckedCreateInput>
  }

  /**
   * LabEquipment createMany
   */
  export type LabEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabEquipments.
     */
    data: LabEquipmentCreateManyInput | LabEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabEquipment createManyAndReturn
   */
  export type LabEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many LabEquipments.
     */
    data: LabEquipmentCreateManyInput | LabEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabEquipment update
   */
  export type LabEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a LabEquipment.
     */
    data: XOR<LabEquipmentUpdateInput, LabEquipmentUncheckedUpdateInput>
    /**
     * Choose, which LabEquipment to update.
     */
    where: LabEquipmentWhereUniqueInput
  }

  /**
   * LabEquipment updateMany
   */
  export type LabEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabEquipments.
     */
    data: XOR<LabEquipmentUpdateManyMutationInput, LabEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which LabEquipments to update
     */
    where?: LabEquipmentWhereInput
    /**
     * Limit how many LabEquipments to update.
     */
    limit?: number
  }

  /**
   * LabEquipment updateManyAndReturn
   */
  export type LabEquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * The data used to update LabEquipments.
     */
    data: XOR<LabEquipmentUpdateManyMutationInput, LabEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which LabEquipments to update
     */
    where?: LabEquipmentWhereInput
    /**
     * Limit how many LabEquipments to update.
     */
    limit?: number
  }

  /**
   * LabEquipment upsert
   */
  export type LabEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the LabEquipment to update in case it exists.
     */
    where: LabEquipmentWhereUniqueInput
    /**
     * In case the LabEquipment found by the `where` argument doesn't exist, create a new LabEquipment with this data.
     */
    create: XOR<LabEquipmentCreateInput, LabEquipmentUncheckedCreateInput>
    /**
     * In case the LabEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabEquipmentUpdateInput, LabEquipmentUncheckedUpdateInput>
  }

  /**
   * LabEquipment delete
   */
  export type LabEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
    /**
     * Filter which LabEquipment to delete.
     */
    where: LabEquipmentWhereUniqueInput
  }

  /**
   * LabEquipment deleteMany
   */
  export type LabEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabEquipments to delete
     */
    where?: LabEquipmentWhereInput
    /**
     * Limit how many LabEquipments to delete.
     */
    limit?: number
  }

  /**
   * LabEquipment.workspaceUsages
   */
  export type LabEquipment$workspaceUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    where?: WorkspaceEquipmentUsageWhereInput
    orderBy?: WorkspaceEquipmentUsageOrderByWithRelationInput | WorkspaceEquipmentUsageOrderByWithRelationInput[]
    cursor?: WorkspaceEquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceEquipmentUsageScalarFieldEnum | WorkspaceEquipmentUsageScalarFieldEnum[]
  }

  /**
   * LabEquipment.sampleUsages
   */
  export type LabEquipment$sampleUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    where?: SampleEquipmentUsageWhereInput
    orderBy?: SampleEquipmentUsageOrderByWithRelationInput | SampleEquipmentUsageOrderByWithRelationInput[]
    cursor?: SampleEquipmentUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleEquipmentUsageScalarFieldEnum | SampleEquipmentUsageScalarFieldEnum[]
  }

  /**
   * LabEquipment without action
   */
  export type LabEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabEquipment
     */
    select?: LabEquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabEquipment
     */
    omit?: LabEquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceEquipmentUsage
   */

  export type AggregateWorkspaceEquipmentUsage = {
    _count: WorkspaceEquipmentUsageCountAggregateOutputType | null
    _min: WorkspaceEquipmentUsageMinAggregateOutputType | null
    _max: WorkspaceEquipmentUsageMaxAggregateOutputType | null
  }

  export type WorkspaceEquipmentUsageMinAggregateOutputType = {
    id: string | null
    workspaceBookingId: string | null
    equipmentId: string | null
    createdAt: Date | null
  }

  export type WorkspaceEquipmentUsageMaxAggregateOutputType = {
    id: string | null
    workspaceBookingId: string | null
    equipmentId: string | null
    createdAt: Date | null
  }

  export type WorkspaceEquipmentUsageCountAggregateOutputType = {
    id: number
    workspaceBookingId: number
    equipmentId: number
    createdAt: number
    _all: number
  }


  export type WorkspaceEquipmentUsageMinAggregateInputType = {
    id?: true
    workspaceBookingId?: true
    equipmentId?: true
    createdAt?: true
  }

  export type WorkspaceEquipmentUsageMaxAggregateInputType = {
    id?: true
    workspaceBookingId?: true
    equipmentId?: true
    createdAt?: true
  }

  export type WorkspaceEquipmentUsageCountAggregateInputType = {
    id?: true
    workspaceBookingId?: true
    equipmentId?: true
    createdAt?: true
    _all?: true
  }

  export type WorkspaceEquipmentUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceEquipmentUsage to aggregate.
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceEquipmentUsages to fetch.
     */
    orderBy?: WorkspaceEquipmentUsageOrderByWithRelationInput | WorkspaceEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceEquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceEquipmentUsages
    **/
    _count?: true | WorkspaceEquipmentUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceEquipmentUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceEquipmentUsageMaxAggregateInputType
  }

  export type GetWorkspaceEquipmentUsageAggregateType<T extends WorkspaceEquipmentUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceEquipmentUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceEquipmentUsage[P]>
      : GetScalarType<T[P], AggregateWorkspaceEquipmentUsage[P]>
  }




  export type WorkspaceEquipmentUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceEquipmentUsageWhereInput
    orderBy?: WorkspaceEquipmentUsageOrderByWithAggregationInput | WorkspaceEquipmentUsageOrderByWithAggregationInput[]
    by: WorkspaceEquipmentUsageScalarFieldEnum[] | WorkspaceEquipmentUsageScalarFieldEnum
    having?: WorkspaceEquipmentUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceEquipmentUsageCountAggregateInputType | true
    _min?: WorkspaceEquipmentUsageMinAggregateInputType
    _max?: WorkspaceEquipmentUsageMaxAggregateInputType
  }

  export type WorkspaceEquipmentUsageGroupByOutputType = {
    id: string
    workspaceBookingId: string
    equipmentId: string
    createdAt: Date
    _count: WorkspaceEquipmentUsageCountAggregateOutputType | null
    _min: WorkspaceEquipmentUsageMinAggregateOutputType | null
    _max: WorkspaceEquipmentUsageMaxAggregateOutputType | null
  }

  type GetWorkspaceEquipmentUsageGroupByPayload<T extends WorkspaceEquipmentUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceEquipmentUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceEquipmentUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceEquipmentUsageGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceEquipmentUsageGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceEquipmentUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceBookingId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    workspaceBooking?: boolean | WorkspaceBookingDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceEquipmentUsage"]>

  export type WorkspaceEquipmentUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceBookingId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    workspaceBooking?: boolean | WorkspaceBookingDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceEquipmentUsage"]>

  export type WorkspaceEquipmentUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceBookingId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    workspaceBooking?: boolean | WorkspaceBookingDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceEquipmentUsage"]>

  export type WorkspaceEquipmentUsageSelectScalar = {
    id?: boolean
    workspaceBookingId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
  }

  export type WorkspaceEquipmentUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceBookingId" | "equipmentId" | "createdAt", ExtArgs["result"]["workspaceEquipmentUsage"]>
  export type WorkspaceEquipmentUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaceBooking?: boolean | WorkspaceBookingDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }
  export type WorkspaceEquipmentUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaceBooking?: boolean | WorkspaceBookingDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }
  export type WorkspaceEquipmentUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaceBooking?: boolean | WorkspaceBookingDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }

  export type $WorkspaceEquipmentUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceEquipmentUsage"
    objects: {
      workspaceBooking: Prisma.$WorkspaceBookingPayload<ExtArgs>
      equipment: Prisma.$LabEquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceBookingId: string
      equipmentId: string
      createdAt: Date
    }, ExtArgs["result"]["workspaceEquipmentUsage"]>
    composites: {}
  }

  type WorkspaceEquipmentUsageGetPayload<S extends boolean | null | undefined | WorkspaceEquipmentUsageDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload, S>

  type WorkspaceEquipmentUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceEquipmentUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceEquipmentUsageCountAggregateInputType | true
    }

  export interface WorkspaceEquipmentUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceEquipmentUsage'], meta: { name: 'WorkspaceEquipmentUsage' } }
    /**
     * Find zero or one WorkspaceEquipmentUsage that matches the filter.
     * @param {WorkspaceEquipmentUsageFindUniqueArgs} args - Arguments to find a WorkspaceEquipmentUsage
     * @example
     * // Get one WorkspaceEquipmentUsage
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceEquipmentUsageFindUniqueArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceEquipmentUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceEquipmentUsageFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceEquipmentUsage
     * @example
     * // Get one WorkspaceEquipmentUsage
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceEquipmentUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceEquipmentUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageFindFirstArgs} args - Arguments to find a WorkspaceEquipmentUsage
     * @example
     * // Get one WorkspaceEquipmentUsage
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceEquipmentUsageFindFirstArgs>(args?: SelectSubset<T, WorkspaceEquipmentUsageFindFirstArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceEquipmentUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageFindFirstOrThrowArgs} args - Arguments to find a WorkspaceEquipmentUsage
     * @example
     * // Get one WorkspaceEquipmentUsage
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceEquipmentUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceEquipmentUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceEquipmentUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceEquipmentUsages
     * const workspaceEquipmentUsages = await prisma.workspaceEquipmentUsage.findMany()
     * 
     * // Get first 10 WorkspaceEquipmentUsages
     * const workspaceEquipmentUsages = await prisma.workspaceEquipmentUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceEquipmentUsageWithIdOnly = await prisma.workspaceEquipmentUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceEquipmentUsageFindManyArgs>(args?: SelectSubset<T, WorkspaceEquipmentUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceEquipmentUsage.
     * @param {WorkspaceEquipmentUsageCreateArgs} args - Arguments to create a WorkspaceEquipmentUsage.
     * @example
     * // Create one WorkspaceEquipmentUsage
     * const WorkspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.create({
     *   data: {
     *     // ... data to create a WorkspaceEquipmentUsage
     *   }
     * })
     * 
     */
    create<T extends WorkspaceEquipmentUsageCreateArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageCreateArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceEquipmentUsages.
     * @param {WorkspaceEquipmentUsageCreateManyArgs} args - Arguments to create many WorkspaceEquipmentUsages.
     * @example
     * // Create many WorkspaceEquipmentUsages
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceEquipmentUsageCreateManyArgs>(args?: SelectSubset<T, WorkspaceEquipmentUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceEquipmentUsages and returns the data saved in the database.
     * @param {WorkspaceEquipmentUsageCreateManyAndReturnArgs} args - Arguments to create many WorkspaceEquipmentUsages.
     * @example
     * // Create many WorkspaceEquipmentUsages
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceEquipmentUsages and only return the `id`
     * const workspaceEquipmentUsageWithIdOnly = await prisma.workspaceEquipmentUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceEquipmentUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceEquipmentUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceEquipmentUsage.
     * @param {WorkspaceEquipmentUsageDeleteArgs} args - Arguments to delete one WorkspaceEquipmentUsage.
     * @example
     * // Delete one WorkspaceEquipmentUsage
     * const WorkspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceEquipmentUsage
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceEquipmentUsageDeleteArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageDeleteArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceEquipmentUsage.
     * @param {WorkspaceEquipmentUsageUpdateArgs} args - Arguments to update one WorkspaceEquipmentUsage.
     * @example
     * // Update one WorkspaceEquipmentUsage
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceEquipmentUsageUpdateArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageUpdateArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceEquipmentUsages.
     * @param {WorkspaceEquipmentUsageDeleteManyArgs} args - Arguments to filter WorkspaceEquipmentUsages to delete.
     * @example
     * // Delete a few WorkspaceEquipmentUsages
     * const { count } = await prisma.workspaceEquipmentUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceEquipmentUsageDeleteManyArgs>(args?: SelectSubset<T, WorkspaceEquipmentUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceEquipmentUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceEquipmentUsages
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceEquipmentUsageUpdateManyArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceEquipmentUsages and returns the data updated in the database.
     * @param {WorkspaceEquipmentUsageUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceEquipmentUsages.
     * @example
     * // Update many WorkspaceEquipmentUsages
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceEquipmentUsages and only return the `id`
     * const workspaceEquipmentUsageWithIdOnly = await prisma.workspaceEquipmentUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceEquipmentUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceEquipmentUsage.
     * @param {WorkspaceEquipmentUsageUpsertArgs} args - Arguments to update or create a WorkspaceEquipmentUsage.
     * @example
     * // Update or create a WorkspaceEquipmentUsage
     * const workspaceEquipmentUsage = await prisma.workspaceEquipmentUsage.upsert({
     *   create: {
     *     // ... data to create a WorkspaceEquipmentUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceEquipmentUsage we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceEquipmentUsageUpsertArgs>(args: SelectSubset<T, WorkspaceEquipmentUsageUpsertArgs<ExtArgs>>): Prisma__WorkspaceEquipmentUsageClient<$Result.GetResult<Prisma.$WorkspaceEquipmentUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceEquipmentUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageCountArgs} args - Arguments to filter WorkspaceEquipmentUsages to count.
     * @example
     * // Count the number of WorkspaceEquipmentUsages
     * const count = await prisma.workspaceEquipmentUsage.count({
     *   where: {
     *     // ... the filter for the WorkspaceEquipmentUsages we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceEquipmentUsageCountArgs>(
      args?: Subset<T, WorkspaceEquipmentUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceEquipmentUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceEquipmentUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceEquipmentUsageAggregateArgs>(args: Subset<T, WorkspaceEquipmentUsageAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceEquipmentUsageAggregateType<T>>

    /**
     * Group by WorkspaceEquipmentUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceEquipmentUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceEquipmentUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceEquipmentUsageGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceEquipmentUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceEquipmentUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceEquipmentUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceEquipmentUsage model
   */
  readonly fields: WorkspaceEquipmentUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceEquipmentUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceEquipmentUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaceBooking<T extends WorkspaceBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceBookingDefaultArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends LabEquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabEquipmentDefaultArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceEquipmentUsage model
   */
  interface WorkspaceEquipmentUsageFieldRefs {
    readonly id: FieldRef<"WorkspaceEquipmentUsage", 'String'>
    readonly workspaceBookingId: FieldRef<"WorkspaceEquipmentUsage", 'String'>
    readonly equipmentId: FieldRef<"WorkspaceEquipmentUsage", 'String'>
    readonly createdAt: FieldRef<"WorkspaceEquipmentUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceEquipmentUsage findUnique
   */
  export type WorkspaceEquipmentUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceEquipmentUsage to fetch.
     */
    where: WorkspaceEquipmentUsageWhereUniqueInput
  }

  /**
   * WorkspaceEquipmentUsage findUniqueOrThrow
   */
  export type WorkspaceEquipmentUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceEquipmentUsage to fetch.
     */
    where: WorkspaceEquipmentUsageWhereUniqueInput
  }

  /**
   * WorkspaceEquipmentUsage findFirst
   */
  export type WorkspaceEquipmentUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceEquipmentUsage to fetch.
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceEquipmentUsages to fetch.
     */
    orderBy?: WorkspaceEquipmentUsageOrderByWithRelationInput | WorkspaceEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceEquipmentUsages.
     */
    cursor?: WorkspaceEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceEquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceEquipmentUsages.
     */
    distinct?: WorkspaceEquipmentUsageScalarFieldEnum | WorkspaceEquipmentUsageScalarFieldEnum[]
  }

  /**
   * WorkspaceEquipmentUsage findFirstOrThrow
   */
  export type WorkspaceEquipmentUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceEquipmentUsage to fetch.
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceEquipmentUsages to fetch.
     */
    orderBy?: WorkspaceEquipmentUsageOrderByWithRelationInput | WorkspaceEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceEquipmentUsages.
     */
    cursor?: WorkspaceEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceEquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceEquipmentUsages.
     */
    distinct?: WorkspaceEquipmentUsageScalarFieldEnum | WorkspaceEquipmentUsageScalarFieldEnum[]
  }

  /**
   * WorkspaceEquipmentUsage findMany
   */
  export type WorkspaceEquipmentUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceEquipmentUsages to fetch.
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceEquipmentUsages to fetch.
     */
    orderBy?: WorkspaceEquipmentUsageOrderByWithRelationInput | WorkspaceEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceEquipmentUsages.
     */
    cursor?: WorkspaceEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceEquipmentUsages.
     */
    skip?: number
    distinct?: WorkspaceEquipmentUsageScalarFieldEnum | WorkspaceEquipmentUsageScalarFieldEnum[]
  }

  /**
   * WorkspaceEquipmentUsage create
   */
  export type WorkspaceEquipmentUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceEquipmentUsage.
     */
    data: XOR<WorkspaceEquipmentUsageCreateInput, WorkspaceEquipmentUsageUncheckedCreateInput>
  }

  /**
   * WorkspaceEquipmentUsage createMany
   */
  export type WorkspaceEquipmentUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceEquipmentUsages.
     */
    data: WorkspaceEquipmentUsageCreateManyInput | WorkspaceEquipmentUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceEquipmentUsage createManyAndReturn
   */
  export type WorkspaceEquipmentUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceEquipmentUsages.
     */
    data: WorkspaceEquipmentUsageCreateManyInput | WorkspaceEquipmentUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceEquipmentUsage update
   */
  export type WorkspaceEquipmentUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceEquipmentUsage.
     */
    data: XOR<WorkspaceEquipmentUsageUpdateInput, WorkspaceEquipmentUsageUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceEquipmentUsage to update.
     */
    where: WorkspaceEquipmentUsageWhereUniqueInput
  }

  /**
   * WorkspaceEquipmentUsage updateMany
   */
  export type WorkspaceEquipmentUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceEquipmentUsages.
     */
    data: XOR<WorkspaceEquipmentUsageUpdateManyMutationInput, WorkspaceEquipmentUsageUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceEquipmentUsages to update
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * Limit how many WorkspaceEquipmentUsages to update.
     */
    limit?: number
  }

  /**
   * WorkspaceEquipmentUsage updateManyAndReturn
   */
  export type WorkspaceEquipmentUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceEquipmentUsages.
     */
    data: XOR<WorkspaceEquipmentUsageUpdateManyMutationInput, WorkspaceEquipmentUsageUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceEquipmentUsages to update
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * Limit how many WorkspaceEquipmentUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceEquipmentUsage upsert
   */
  export type WorkspaceEquipmentUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceEquipmentUsage to update in case it exists.
     */
    where: WorkspaceEquipmentUsageWhereUniqueInput
    /**
     * In case the WorkspaceEquipmentUsage found by the `where` argument doesn't exist, create a new WorkspaceEquipmentUsage with this data.
     */
    create: XOR<WorkspaceEquipmentUsageCreateInput, WorkspaceEquipmentUsageUncheckedCreateInput>
    /**
     * In case the WorkspaceEquipmentUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceEquipmentUsageUpdateInput, WorkspaceEquipmentUsageUncheckedUpdateInput>
  }

  /**
   * WorkspaceEquipmentUsage delete
   */
  export type WorkspaceEquipmentUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceEquipmentUsage to delete.
     */
    where: WorkspaceEquipmentUsageWhereUniqueInput
  }

  /**
   * WorkspaceEquipmentUsage deleteMany
   */
  export type WorkspaceEquipmentUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceEquipmentUsages to delete
     */
    where?: WorkspaceEquipmentUsageWhereInput
    /**
     * Limit how many WorkspaceEquipmentUsages to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceEquipmentUsage without action
   */
  export type WorkspaceEquipmentUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceEquipmentUsage
     */
    select?: WorkspaceEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceEquipmentUsage
     */
    omit?: WorkspaceEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceEquipmentUsageInclude<ExtArgs> | null
  }


  /**
   * Model SampleEquipmentUsage
   */

  export type AggregateSampleEquipmentUsage = {
    _count: SampleEquipmentUsageCountAggregateOutputType | null
    _min: SampleEquipmentUsageMinAggregateOutputType | null
    _max: SampleEquipmentUsageMaxAggregateOutputType | null
  }

  export type SampleEquipmentUsageMinAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    equipmentId: string | null
    createdAt: Date | null
  }

  export type SampleEquipmentUsageMaxAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    equipmentId: string | null
    createdAt: Date | null
  }

  export type SampleEquipmentUsageCountAggregateOutputType = {
    id: number
    bookingServiceItemId: number
    equipmentId: number
    createdAt: number
    _all: number
  }


  export type SampleEquipmentUsageMinAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    equipmentId?: true
    createdAt?: true
  }

  export type SampleEquipmentUsageMaxAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    equipmentId?: true
    createdAt?: true
  }

  export type SampleEquipmentUsageCountAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    equipmentId?: true
    createdAt?: true
    _all?: true
  }

  export type SampleEquipmentUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SampleEquipmentUsage to aggregate.
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleEquipmentUsages to fetch.
     */
    orderBy?: SampleEquipmentUsageOrderByWithRelationInput | SampleEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SampleEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleEquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SampleEquipmentUsages
    **/
    _count?: true | SampleEquipmentUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SampleEquipmentUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SampleEquipmentUsageMaxAggregateInputType
  }

  export type GetSampleEquipmentUsageAggregateType<T extends SampleEquipmentUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateSampleEquipmentUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSampleEquipmentUsage[P]>
      : GetScalarType<T[P], AggregateSampleEquipmentUsage[P]>
  }




  export type SampleEquipmentUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleEquipmentUsageWhereInput
    orderBy?: SampleEquipmentUsageOrderByWithAggregationInput | SampleEquipmentUsageOrderByWithAggregationInput[]
    by: SampleEquipmentUsageScalarFieldEnum[] | SampleEquipmentUsageScalarFieldEnum
    having?: SampleEquipmentUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SampleEquipmentUsageCountAggregateInputType | true
    _min?: SampleEquipmentUsageMinAggregateInputType
    _max?: SampleEquipmentUsageMaxAggregateInputType
  }

  export type SampleEquipmentUsageGroupByOutputType = {
    id: string
    bookingServiceItemId: string
    equipmentId: string
    createdAt: Date
    _count: SampleEquipmentUsageCountAggregateOutputType | null
    _min: SampleEquipmentUsageMinAggregateOutputType | null
    _max: SampleEquipmentUsageMaxAggregateOutputType | null
  }

  type GetSampleEquipmentUsageGroupByPayload<T extends SampleEquipmentUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SampleEquipmentUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SampleEquipmentUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SampleEquipmentUsageGroupByOutputType[P]>
            : GetScalarType<T[P], SampleEquipmentUsageGroupByOutputType[P]>
        }
      >
    >


  export type SampleEquipmentUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    bookedItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sampleEquipmentUsage"]>

  export type SampleEquipmentUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    bookedItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sampleEquipmentUsage"]>

  export type SampleEquipmentUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    bookedItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sampleEquipmentUsage"]>

  export type SampleEquipmentUsageSelectScalar = {
    id?: boolean
    bookingServiceItemId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
  }

  export type SampleEquipmentUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingServiceItemId" | "equipmentId" | "createdAt", ExtArgs["result"]["sampleEquipmentUsage"]>
  export type SampleEquipmentUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookedItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }
  export type SampleEquipmentUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookedItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }
  export type SampleEquipmentUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookedItem?: boolean | BookingServiceItemDefaultArgs<ExtArgs>
    equipment?: boolean | LabEquipmentDefaultArgs<ExtArgs>
  }

  export type $SampleEquipmentUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SampleEquipmentUsage"
    objects: {
      bookedItem: Prisma.$BookingServiceItemPayload<ExtArgs>
      equipment: Prisma.$LabEquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingServiceItemId: string
      equipmentId: string
      createdAt: Date
    }, ExtArgs["result"]["sampleEquipmentUsage"]>
    composites: {}
  }

  type SampleEquipmentUsageGetPayload<S extends boolean | null | undefined | SampleEquipmentUsageDefaultArgs> = $Result.GetResult<Prisma.$SampleEquipmentUsagePayload, S>

  type SampleEquipmentUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SampleEquipmentUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SampleEquipmentUsageCountAggregateInputType | true
    }

  export interface SampleEquipmentUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SampleEquipmentUsage'], meta: { name: 'SampleEquipmentUsage' } }
    /**
     * Find zero or one SampleEquipmentUsage that matches the filter.
     * @param {SampleEquipmentUsageFindUniqueArgs} args - Arguments to find a SampleEquipmentUsage
     * @example
     * // Get one SampleEquipmentUsage
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SampleEquipmentUsageFindUniqueArgs>(args: SelectSubset<T, SampleEquipmentUsageFindUniqueArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SampleEquipmentUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SampleEquipmentUsageFindUniqueOrThrowArgs} args - Arguments to find a SampleEquipmentUsage
     * @example
     * // Get one SampleEquipmentUsage
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SampleEquipmentUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, SampleEquipmentUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SampleEquipmentUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageFindFirstArgs} args - Arguments to find a SampleEquipmentUsage
     * @example
     * // Get one SampleEquipmentUsage
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SampleEquipmentUsageFindFirstArgs>(args?: SelectSubset<T, SampleEquipmentUsageFindFirstArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SampleEquipmentUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageFindFirstOrThrowArgs} args - Arguments to find a SampleEquipmentUsage
     * @example
     * // Get one SampleEquipmentUsage
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SampleEquipmentUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, SampleEquipmentUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SampleEquipmentUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SampleEquipmentUsages
     * const sampleEquipmentUsages = await prisma.sampleEquipmentUsage.findMany()
     * 
     * // Get first 10 SampleEquipmentUsages
     * const sampleEquipmentUsages = await prisma.sampleEquipmentUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sampleEquipmentUsageWithIdOnly = await prisma.sampleEquipmentUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SampleEquipmentUsageFindManyArgs>(args?: SelectSubset<T, SampleEquipmentUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SampleEquipmentUsage.
     * @param {SampleEquipmentUsageCreateArgs} args - Arguments to create a SampleEquipmentUsage.
     * @example
     * // Create one SampleEquipmentUsage
     * const SampleEquipmentUsage = await prisma.sampleEquipmentUsage.create({
     *   data: {
     *     // ... data to create a SampleEquipmentUsage
     *   }
     * })
     * 
     */
    create<T extends SampleEquipmentUsageCreateArgs>(args: SelectSubset<T, SampleEquipmentUsageCreateArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SampleEquipmentUsages.
     * @param {SampleEquipmentUsageCreateManyArgs} args - Arguments to create many SampleEquipmentUsages.
     * @example
     * // Create many SampleEquipmentUsages
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SampleEquipmentUsageCreateManyArgs>(args?: SelectSubset<T, SampleEquipmentUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SampleEquipmentUsages and returns the data saved in the database.
     * @param {SampleEquipmentUsageCreateManyAndReturnArgs} args - Arguments to create many SampleEquipmentUsages.
     * @example
     * // Create many SampleEquipmentUsages
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SampleEquipmentUsages and only return the `id`
     * const sampleEquipmentUsageWithIdOnly = await prisma.sampleEquipmentUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SampleEquipmentUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, SampleEquipmentUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SampleEquipmentUsage.
     * @param {SampleEquipmentUsageDeleteArgs} args - Arguments to delete one SampleEquipmentUsage.
     * @example
     * // Delete one SampleEquipmentUsage
     * const SampleEquipmentUsage = await prisma.sampleEquipmentUsage.delete({
     *   where: {
     *     // ... filter to delete one SampleEquipmentUsage
     *   }
     * })
     * 
     */
    delete<T extends SampleEquipmentUsageDeleteArgs>(args: SelectSubset<T, SampleEquipmentUsageDeleteArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SampleEquipmentUsage.
     * @param {SampleEquipmentUsageUpdateArgs} args - Arguments to update one SampleEquipmentUsage.
     * @example
     * // Update one SampleEquipmentUsage
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SampleEquipmentUsageUpdateArgs>(args: SelectSubset<T, SampleEquipmentUsageUpdateArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SampleEquipmentUsages.
     * @param {SampleEquipmentUsageDeleteManyArgs} args - Arguments to filter SampleEquipmentUsages to delete.
     * @example
     * // Delete a few SampleEquipmentUsages
     * const { count } = await prisma.sampleEquipmentUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SampleEquipmentUsageDeleteManyArgs>(args?: SelectSubset<T, SampleEquipmentUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SampleEquipmentUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SampleEquipmentUsages
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SampleEquipmentUsageUpdateManyArgs>(args: SelectSubset<T, SampleEquipmentUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SampleEquipmentUsages and returns the data updated in the database.
     * @param {SampleEquipmentUsageUpdateManyAndReturnArgs} args - Arguments to update many SampleEquipmentUsages.
     * @example
     * // Update many SampleEquipmentUsages
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SampleEquipmentUsages and only return the `id`
     * const sampleEquipmentUsageWithIdOnly = await prisma.sampleEquipmentUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SampleEquipmentUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, SampleEquipmentUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SampleEquipmentUsage.
     * @param {SampleEquipmentUsageUpsertArgs} args - Arguments to update or create a SampleEquipmentUsage.
     * @example
     * // Update or create a SampleEquipmentUsage
     * const sampleEquipmentUsage = await prisma.sampleEquipmentUsage.upsert({
     *   create: {
     *     // ... data to create a SampleEquipmentUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SampleEquipmentUsage we want to update
     *   }
     * })
     */
    upsert<T extends SampleEquipmentUsageUpsertArgs>(args: SelectSubset<T, SampleEquipmentUsageUpsertArgs<ExtArgs>>): Prisma__SampleEquipmentUsageClient<$Result.GetResult<Prisma.$SampleEquipmentUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SampleEquipmentUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageCountArgs} args - Arguments to filter SampleEquipmentUsages to count.
     * @example
     * // Count the number of SampleEquipmentUsages
     * const count = await prisma.sampleEquipmentUsage.count({
     *   where: {
     *     // ... the filter for the SampleEquipmentUsages we want to count
     *   }
     * })
    **/
    count<T extends SampleEquipmentUsageCountArgs>(
      args?: Subset<T, SampleEquipmentUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SampleEquipmentUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SampleEquipmentUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SampleEquipmentUsageAggregateArgs>(args: Subset<T, SampleEquipmentUsageAggregateArgs>): Prisma.PrismaPromise<GetSampleEquipmentUsageAggregateType<T>>

    /**
     * Group by SampleEquipmentUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleEquipmentUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SampleEquipmentUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SampleEquipmentUsageGroupByArgs['orderBy'] }
        : { orderBy?: SampleEquipmentUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SampleEquipmentUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSampleEquipmentUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SampleEquipmentUsage model
   */
  readonly fields: SampleEquipmentUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SampleEquipmentUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SampleEquipmentUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookedItem<T extends BookingServiceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingServiceItemDefaultArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends LabEquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabEquipmentDefaultArgs<ExtArgs>>): Prisma__LabEquipmentClient<$Result.GetResult<Prisma.$LabEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SampleEquipmentUsage model
   */
  interface SampleEquipmentUsageFieldRefs {
    readonly id: FieldRef<"SampleEquipmentUsage", 'String'>
    readonly bookingServiceItemId: FieldRef<"SampleEquipmentUsage", 'String'>
    readonly equipmentId: FieldRef<"SampleEquipmentUsage", 'String'>
    readonly createdAt: FieldRef<"SampleEquipmentUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SampleEquipmentUsage findUnique
   */
  export type SampleEquipmentUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which SampleEquipmentUsage to fetch.
     */
    where: SampleEquipmentUsageWhereUniqueInput
  }

  /**
   * SampleEquipmentUsage findUniqueOrThrow
   */
  export type SampleEquipmentUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which SampleEquipmentUsage to fetch.
     */
    where: SampleEquipmentUsageWhereUniqueInput
  }

  /**
   * SampleEquipmentUsage findFirst
   */
  export type SampleEquipmentUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which SampleEquipmentUsage to fetch.
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleEquipmentUsages to fetch.
     */
    orderBy?: SampleEquipmentUsageOrderByWithRelationInput | SampleEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SampleEquipmentUsages.
     */
    cursor?: SampleEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleEquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SampleEquipmentUsages.
     */
    distinct?: SampleEquipmentUsageScalarFieldEnum | SampleEquipmentUsageScalarFieldEnum[]
  }

  /**
   * SampleEquipmentUsage findFirstOrThrow
   */
  export type SampleEquipmentUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which SampleEquipmentUsage to fetch.
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleEquipmentUsages to fetch.
     */
    orderBy?: SampleEquipmentUsageOrderByWithRelationInput | SampleEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SampleEquipmentUsages.
     */
    cursor?: SampleEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleEquipmentUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SampleEquipmentUsages.
     */
    distinct?: SampleEquipmentUsageScalarFieldEnum | SampleEquipmentUsageScalarFieldEnum[]
  }

  /**
   * SampleEquipmentUsage findMany
   */
  export type SampleEquipmentUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter, which SampleEquipmentUsages to fetch.
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SampleEquipmentUsages to fetch.
     */
    orderBy?: SampleEquipmentUsageOrderByWithRelationInput | SampleEquipmentUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SampleEquipmentUsages.
     */
    cursor?: SampleEquipmentUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SampleEquipmentUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SampleEquipmentUsages.
     */
    skip?: number
    distinct?: SampleEquipmentUsageScalarFieldEnum | SampleEquipmentUsageScalarFieldEnum[]
  }

  /**
   * SampleEquipmentUsage create
   */
  export type SampleEquipmentUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a SampleEquipmentUsage.
     */
    data: XOR<SampleEquipmentUsageCreateInput, SampleEquipmentUsageUncheckedCreateInput>
  }

  /**
   * SampleEquipmentUsage createMany
   */
  export type SampleEquipmentUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SampleEquipmentUsages.
     */
    data: SampleEquipmentUsageCreateManyInput | SampleEquipmentUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SampleEquipmentUsage createManyAndReturn
   */
  export type SampleEquipmentUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * The data used to create many SampleEquipmentUsages.
     */
    data: SampleEquipmentUsageCreateManyInput | SampleEquipmentUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SampleEquipmentUsage update
   */
  export type SampleEquipmentUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a SampleEquipmentUsage.
     */
    data: XOR<SampleEquipmentUsageUpdateInput, SampleEquipmentUsageUncheckedUpdateInput>
    /**
     * Choose, which SampleEquipmentUsage to update.
     */
    where: SampleEquipmentUsageWhereUniqueInput
  }

  /**
   * SampleEquipmentUsage updateMany
   */
  export type SampleEquipmentUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SampleEquipmentUsages.
     */
    data: XOR<SampleEquipmentUsageUpdateManyMutationInput, SampleEquipmentUsageUncheckedUpdateManyInput>
    /**
     * Filter which SampleEquipmentUsages to update
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * Limit how many SampleEquipmentUsages to update.
     */
    limit?: number
  }

  /**
   * SampleEquipmentUsage updateManyAndReturn
   */
  export type SampleEquipmentUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * The data used to update SampleEquipmentUsages.
     */
    data: XOR<SampleEquipmentUsageUpdateManyMutationInput, SampleEquipmentUsageUncheckedUpdateManyInput>
    /**
     * Filter which SampleEquipmentUsages to update
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * Limit how many SampleEquipmentUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SampleEquipmentUsage upsert
   */
  export type SampleEquipmentUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the SampleEquipmentUsage to update in case it exists.
     */
    where: SampleEquipmentUsageWhereUniqueInput
    /**
     * In case the SampleEquipmentUsage found by the `where` argument doesn't exist, create a new SampleEquipmentUsage with this data.
     */
    create: XOR<SampleEquipmentUsageCreateInput, SampleEquipmentUsageUncheckedCreateInput>
    /**
     * In case the SampleEquipmentUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SampleEquipmentUsageUpdateInput, SampleEquipmentUsageUncheckedUpdateInput>
  }

  /**
   * SampleEquipmentUsage delete
   */
  export type SampleEquipmentUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
    /**
     * Filter which SampleEquipmentUsage to delete.
     */
    where: SampleEquipmentUsageWhereUniqueInput
  }

  /**
   * SampleEquipmentUsage deleteMany
   */
  export type SampleEquipmentUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SampleEquipmentUsages to delete
     */
    where?: SampleEquipmentUsageWhereInput
    /**
     * Limit how many SampleEquipmentUsages to delete.
     */
    limit?: number
  }

  /**
   * SampleEquipmentUsage without action
   */
  export type SampleEquipmentUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleEquipmentUsage
     */
    select?: SampleEquipmentUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SampleEquipmentUsage
     */
    omit?: SampleEquipmentUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleEquipmentUsageInclude<ExtArgs> | null
  }


  /**
   * Model AnalysisResult
   */

  export type AggregateAnalysisResult = {
    _count: AnalysisResultCountAggregateOutputType | null
    _avg: AnalysisResultAvgAggregateOutputType | null
    _sum: AnalysisResultSumAggregateOutputType | null
    _min: AnalysisResultMinAggregateOutputType | null
    _max: AnalysisResultMaxAggregateOutputType | null
  }

  export type AnalysisResultAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type AnalysisResultSumAggregateOutputType = {
    fileSize: number | null
  }

  export type AnalysisResultMinAggregateOutputType = {
    id: string | null
    sampleTrackingId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    fileType: string | null
    description: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisResultMaxAggregateOutputType = {
    id: string | null
    sampleTrackingId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    fileType: string | null
    description: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalysisResultCountAggregateOutputType = {
    id: number
    sampleTrackingId: number
    fileName: number
    filePath: number
    fileSize: number
    fileType: number
    description: number
    uploadedBy: number
    uploadedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalysisResultAvgAggregateInputType = {
    fileSize?: true
  }

  export type AnalysisResultSumAggregateInputType = {
    fileSize?: true
  }

  export type AnalysisResultMinAggregateInputType = {
    id?: true
    sampleTrackingId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    fileType?: true
    description?: true
    uploadedBy?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisResultMaxAggregateInputType = {
    id?: true
    sampleTrackingId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    fileType?: true
    description?: true
    uploadedBy?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalysisResultCountAggregateInputType = {
    id?: true
    sampleTrackingId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    fileType?: true
    description?: true
    uploadedBy?: true
    uploadedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalysisResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisResult to aggregate.
     */
    where?: AnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisResults to fetch.
     */
    orderBy?: AnalysisResultOrderByWithRelationInput | AnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalysisResults
    **/
    _count?: true | AnalysisResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalysisResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalysisResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalysisResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalysisResultMaxAggregateInputType
  }

  export type GetAnalysisResultAggregateType<T extends AnalysisResultAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalysisResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalysisResult[P]>
      : GetScalarType<T[P], AggregateAnalysisResult[P]>
  }




  export type AnalysisResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalysisResultWhereInput
    orderBy?: AnalysisResultOrderByWithAggregationInput | AnalysisResultOrderByWithAggregationInput[]
    by: AnalysisResultScalarFieldEnum[] | AnalysisResultScalarFieldEnum
    having?: AnalysisResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalysisResultCountAggregateInputType | true
    _avg?: AnalysisResultAvgAggregateInputType
    _sum?: AnalysisResultSumAggregateInputType
    _min?: AnalysisResultMinAggregateInputType
    _max?: AnalysisResultMaxAggregateInputType
  }

  export type AnalysisResultGroupByOutputType = {
    id: string
    sampleTrackingId: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description: string | null
    uploadedBy: string
    uploadedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AnalysisResultCountAggregateOutputType | null
    _avg: AnalysisResultAvgAggregateOutputType | null
    _sum: AnalysisResultSumAggregateOutputType | null
    _min: AnalysisResultMinAggregateOutputType | null
    _max: AnalysisResultMaxAggregateOutputType | null
  }

  type GetAnalysisResultGroupByPayload<T extends AnalysisResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalysisResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalysisResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalysisResultGroupByOutputType[P]>
            : GetScalarType<T[P], AnalysisResultGroupByOutputType[P]>
        }
      >
    >


  export type AnalysisResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sampleTrackingId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    fileType?: boolean
    description?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sampleTracking?: boolean | SampleTrackingDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisResult"]>

  export type AnalysisResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sampleTrackingId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    fileType?: boolean
    description?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sampleTracking?: boolean | SampleTrackingDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisResult"]>

  export type AnalysisResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sampleTrackingId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    fileType?: boolean
    description?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sampleTracking?: boolean | SampleTrackingDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analysisResult"]>

  export type AnalysisResultSelectScalar = {
    id?: boolean
    sampleTrackingId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    fileType?: boolean
    description?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalysisResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sampleTrackingId" | "fileName" | "filePath" | "fileSize" | "fileType" | "description" | "uploadedBy" | "uploadedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["analysisResult"]>
  export type AnalysisResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sampleTracking?: boolean | SampleTrackingDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalysisResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sampleTracking?: boolean | SampleTrackingDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnalysisResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sampleTracking?: boolean | SampleTrackingDefaultArgs<ExtArgs>
    uploadedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnalysisResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalysisResult"
    objects: {
      sampleTracking: Prisma.$SampleTrackingPayload<ExtArgs>
      uploadedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sampleTrackingId: string
      fileName: string
      filePath: string
      fileSize: number
      fileType: string
      description: string | null
      uploadedBy: string
      uploadedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analysisResult"]>
    composites: {}
  }

  type AnalysisResultGetPayload<S extends boolean | null | undefined | AnalysisResultDefaultArgs> = $Result.GetResult<Prisma.$AnalysisResultPayload, S>

  type AnalysisResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalysisResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalysisResultCountAggregateInputType | true
    }

  export interface AnalysisResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalysisResult'], meta: { name: 'AnalysisResult' } }
    /**
     * Find zero or one AnalysisResult that matches the filter.
     * @param {AnalysisResultFindUniqueArgs} args - Arguments to find a AnalysisResult
     * @example
     * // Get one AnalysisResult
     * const analysisResult = await prisma.analysisResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalysisResultFindUniqueArgs>(args: SelectSubset<T, AnalysisResultFindUniqueArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalysisResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalysisResultFindUniqueOrThrowArgs} args - Arguments to find a AnalysisResult
     * @example
     * // Get one AnalysisResult
     * const analysisResult = await prisma.analysisResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalysisResultFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalysisResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultFindFirstArgs} args - Arguments to find a AnalysisResult
     * @example
     * // Get one AnalysisResult
     * const analysisResult = await prisma.analysisResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalysisResultFindFirstArgs>(args?: SelectSubset<T, AnalysisResultFindFirstArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalysisResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultFindFirstOrThrowArgs} args - Arguments to find a AnalysisResult
     * @example
     * // Get one AnalysisResult
     * const analysisResult = await prisma.analysisResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalysisResultFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalysisResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalysisResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalysisResults
     * const analysisResults = await prisma.analysisResult.findMany()
     * 
     * // Get first 10 AnalysisResults
     * const analysisResults = await prisma.analysisResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analysisResultWithIdOnly = await prisma.analysisResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalysisResultFindManyArgs>(args?: SelectSubset<T, AnalysisResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalysisResult.
     * @param {AnalysisResultCreateArgs} args - Arguments to create a AnalysisResult.
     * @example
     * // Create one AnalysisResult
     * const AnalysisResult = await prisma.analysisResult.create({
     *   data: {
     *     // ... data to create a AnalysisResult
     *   }
     * })
     * 
     */
    create<T extends AnalysisResultCreateArgs>(args: SelectSubset<T, AnalysisResultCreateArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalysisResults.
     * @param {AnalysisResultCreateManyArgs} args - Arguments to create many AnalysisResults.
     * @example
     * // Create many AnalysisResults
     * const analysisResult = await prisma.analysisResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalysisResultCreateManyArgs>(args?: SelectSubset<T, AnalysisResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalysisResults and returns the data saved in the database.
     * @param {AnalysisResultCreateManyAndReturnArgs} args - Arguments to create many AnalysisResults.
     * @example
     * // Create many AnalysisResults
     * const analysisResult = await prisma.analysisResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalysisResults and only return the `id`
     * const analysisResultWithIdOnly = await prisma.analysisResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalysisResultCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalysisResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalysisResult.
     * @param {AnalysisResultDeleteArgs} args - Arguments to delete one AnalysisResult.
     * @example
     * // Delete one AnalysisResult
     * const AnalysisResult = await prisma.analysisResult.delete({
     *   where: {
     *     // ... filter to delete one AnalysisResult
     *   }
     * })
     * 
     */
    delete<T extends AnalysisResultDeleteArgs>(args: SelectSubset<T, AnalysisResultDeleteArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalysisResult.
     * @param {AnalysisResultUpdateArgs} args - Arguments to update one AnalysisResult.
     * @example
     * // Update one AnalysisResult
     * const analysisResult = await prisma.analysisResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalysisResultUpdateArgs>(args: SelectSubset<T, AnalysisResultUpdateArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalysisResults.
     * @param {AnalysisResultDeleteManyArgs} args - Arguments to filter AnalysisResults to delete.
     * @example
     * // Delete a few AnalysisResults
     * const { count } = await prisma.analysisResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalysisResultDeleteManyArgs>(args?: SelectSubset<T, AnalysisResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalysisResults
     * const analysisResult = await prisma.analysisResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalysisResultUpdateManyArgs>(args: SelectSubset<T, AnalysisResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalysisResults and returns the data updated in the database.
     * @param {AnalysisResultUpdateManyAndReturnArgs} args - Arguments to update many AnalysisResults.
     * @example
     * // Update many AnalysisResults
     * const analysisResult = await prisma.analysisResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalysisResults and only return the `id`
     * const analysisResultWithIdOnly = await prisma.analysisResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalysisResultUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalysisResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalysisResult.
     * @param {AnalysisResultUpsertArgs} args - Arguments to update or create a AnalysisResult.
     * @example
     * // Update or create a AnalysisResult
     * const analysisResult = await prisma.analysisResult.upsert({
     *   create: {
     *     // ... data to create a AnalysisResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalysisResult we want to update
     *   }
     * })
     */
    upsert<T extends AnalysisResultUpsertArgs>(args: SelectSubset<T, AnalysisResultUpsertArgs<ExtArgs>>): Prisma__AnalysisResultClient<$Result.GetResult<Prisma.$AnalysisResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalysisResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultCountArgs} args - Arguments to filter AnalysisResults to count.
     * @example
     * // Count the number of AnalysisResults
     * const count = await prisma.analysisResult.count({
     *   where: {
     *     // ... the filter for the AnalysisResults we want to count
     *   }
     * })
    **/
    count<T extends AnalysisResultCountArgs>(
      args?: Subset<T, AnalysisResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalysisResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalysisResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalysisResultAggregateArgs>(args: Subset<T, AnalysisResultAggregateArgs>): Prisma.PrismaPromise<GetAnalysisResultAggregateType<T>>

    /**
     * Group by AnalysisResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalysisResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalysisResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalysisResultGroupByArgs['orderBy'] }
        : { orderBy?: AnalysisResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalysisResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalysisResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalysisResult model
   */
  readonly fields: AnalysisResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalysisResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalysisResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sampleTracking<T extends SampleTrackingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SampleTrackingDefaultArgs<ExtArgs>>): Prisma__SampleTrackingClient<$Result.GetResult<Prisma.$SampleTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalysisResult model
   */
  interface AnalysisResultFieldRefs {
    readonly id: FieldRef<"AnalysisResult", 'String'>
    readonly sampleTrackingId: FieldRef<"AnalysisResult", 'String'>
    readonly fileName: FieldRef<"AnalysisResult", 'String'>
    readonly filePath: FieldRef<"AnalysisResult", 'String'>
    readonly fileSize: FieldRef<"AnalysisResult", 'Int'>
    readonly fileType: FieldRef<"AnalysisResult", 'String'>
    readonly description: FieldRef<"AnalysisResult", 'String'>
    readonly uploadedBy: FieldRef<"AnalysisResult", 'String'>
    readonly uploadedAt: FieldRef<"AnalysisResult", 'DateTime'>
    readonly createdAt: FieldRef<"AnalysisResult", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalysisResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalysisResult findUnique
   */
  export type AnalysisResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisResult to fetch.
     */
    where: AnalysisResultWhereUniqueInput
  }

  /**
   * AnalysisResult findUniqueOrThrow
   */
  export type AnalysisResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisResult to fetch.
     */
    where: AnalysisResultWhereUniqueInput
  }

  /**
   * AnalysisResult findFirst
   */
  export type AnalysisResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisResult to fetch.
     */
    where?: AnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisResults to fetch.
     */
    orderBy?: AnalysisResultOrderByWithRelationInput | AnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisResults.
     */
    cursor?: AnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisResults.
     */
    distinct?: AnalysisResultScalarFieldEnum | AnalysisResultScalarFieldEnum[]
  }

  /**
   * AnalysisResult findFirstOrThrow
   */
  export type AnalysisResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisResult to fetch.
     */
    where?: AnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisResults to fetch.
     */
    orderBy?: AnalysisResultOrderByWithRelationInput | AnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalysisResults.
     */
    cursor?: AnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalysisResults.
     */
    distinct?: AnalysisResultScalarFieldEnum | AnalysisResultScalarFieldEnum[]
  }

  /**
   * AnalysisResult findMany
   */
  export type AnalysisResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * Filter, which AnalysisResults to fetch.
     */
    where?: AnalysisResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalysisResults to fetch.
     */
    orderBy?: AnalysisResultOrderByWithRelationInput | AnalysisResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalysisResults.
     */
    cursor?: AnalysisResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalysisResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalysisResults.
     */
    skip?: number
    distinct?: AnalysisResultScalarFieldEnum | AnalysisResultScalarFieldEnum[]
  }

  /**
   * AnalysisResult create
   */
  export type AnalysisResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalysisResult.
     */
    data: XOR<AnalysisResultCreateInput, AnalysisResultUncheckedCreateInput>
  }

  /**
   * AnalysisResult createMany
   */
  export type AnalysisResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalysisResults.
     */
    data: AnalysisResultCreateManyInput | AnalysisResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalysisResult createManyAndReturn
   */
  export type AnalysisResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * The data used to create many AnalysisResults.
     */
    data: AnalysisResultCreateManyInput | AnalysisResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisResult update
   */
  export type AnalysisResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalysisResult.
     */
    data: XOR<AnalysisResultUpdateInput, AnalysisResultUncheckedUpdateInput>
    /**
     * Choose, which AnalysisResult to update.
     */
    where: AnalysisResultWhereUniqueInput
  }

  /**
   * AnalysisResult updateMany
   */
  export type AnalysisResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalysisResults.
     */
    data: XOR<AnalysisResultUpdateManyMutationInput, AnalysisResultUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisResults to update
     */
    where?: AnalysisResultWhereInput
    /**
     * Limit how many AnalysisResults to update.
     */
    limit?: number
  }

  /**
   * AnalysisResult updateManyAndReturn
   */
  export type AnalysisResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * The data used to update AnalysisResults.
     */
    data: XOR<AnalysisResultUpdateManyMutationInput, AnalysisResultUncheckedUpdateManyInput>
    /**
     * Filter which AnalysisResults to update
     */
    where?: AnalysisResultWhereInput
    /**
     * Limit how many AnalysisResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalysisResult upsert
   */
  export type AnalysisResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalysisResult to update in case it exists.
     */
    where: AnalysisResultWhereUniqueInput
    /**
     * In case the AnalysisResult found by the `where` argument doesn't exist, create a new AnalysisResult with this data.
     */
    create: XOR<AnalysisResultCreateInput, AnalysisResultUncheckedCreateInput>
    /**
     * In case the AnalysisResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalysisResultUpdateInput, AnalysisResultUncheckedUpdateInput>
  }

  /**
   * AnalysisResult delete
   */
  export type AnalysisResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
    /**
     * Filter which AnalysisResult to delete.
     */
    where: AnalysisResultWhereUniqueInput
  }

  /**
   * AnalysisResult deleteMany
   */
  export type AnalysisResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalysisResults to delete
     */
    where?: AnalysisResultWhereInput
    /**
     * Limit how many AnalysisResults to delete.
     */
    limit?: number
  }

  /**
   * AnalysisResult without action
   */
  export type AnalysisResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalysisResult
     */
    select?: AnalysisResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalysisResult
     */
    omit?: AnalysisResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalysisResultInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.notification_type_enum | null
    relatedEntityType: string | null
    relatedEntityId: string | null
    title: string | null
    message: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.notification_type_enum | null
    relatedEntityType: string | null
    relatedEntityId: string | null
    title: string | null
    message: string | null
    emailSent: boolean | null
    emailSentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    relatedEntityType: number
    relatedEntityId: number
    title: number
    message: number
    emailSent: number
    emailSentAt: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    relatedEntityType?: true
    relatedEntityId?: true
    title?: true
    message?: true
    emailSent?: true
    emailSentAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    relatedEntityType?: true
    relatedEntityId?: true
    title?: true
    message?: true
    emailSent?: true
    emailSentAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    relatedEntityType?: true
    relatedEntityId?: true
    title?: true
    message?: true
    emailSent?: true
    emailSentAt?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.notification_type_enum
    relatedEntityType: string | null
    relatedEntityId: string | null
    title: string
    message: string
    emailSent: boolean
    emailSentAt: Date | null
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    relatedEntityType?: boolean
    relatedEntityId?: boolean
    title?: boolean
    message?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    relatedEntityType?: boolean
    relatedEntityId?: boolean
    title?: boolean
    message?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    relatedEntityType?: boolean
    relatedEntityId?: boolean
    title?: boolean
    message?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    relatedEntityType?: boolean
    relatedEntityId?: boolean
    title?: boolean
    message?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "relatedEntityType" | "relatedEntityId" | "title" | "message" | "emailSent" | "emailSentAt" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.notification_type_enum
      relatedEntityType: string | null
      relatedEntityId: string | null
      title: string
      message: string
      emailSent: boolean
      emailSentAt: Date | null
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'notification_type_enum'>
    readonly relatedEntityType: FieldRef<"Notification", 'String'>
    readonly relatedEntityId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly emailSent: FieldRef<"Notification", 'Boolean'>
    readonly emailSentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entity: string | null
    entityId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entity: string | null
      entityId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model GlobalAddOnCatalog
   */

  export type AggregateGlobalAddOnCatalog = {
    _count: GlobalAddOnCatalogCountAggregateOutputType | null
    _avg: GlobalAddOnCatalogAvgAggregateOutputType | null
    _sum: GlobalAddOnCatalogSumAggregateOutputType | null
    _min: GlobalAddOnCatalogMinAggregateOutputType | null
    _max: GlobalAddOnCatalogMaxAggregateOutputType | null
  }

  export type GlobalAddOnCatalogAvgAggregateOutputType = {
    defaultAmount: Decimal | null
  }

  export type GlobalAddOnCatalogSumAggregateOutputType = {
    defaultAmount: Decimal | null
  }

  export type GlobalAddOnCatalogMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    defaultAmount: Decimal | null
    applicableTo: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalAddOnCatalogMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    defaultAmount: Decimal | null
    applicableTo: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GlobalAddOnCatalogCountAggregateOutputType = {
    id: number
    name: number
    description: number
    defaultAmount: number
    applicableTo: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GlobalAddOnCatalogAvgAggregateInputType = {
    defaultAmount?: true
  }

  export type GlobalAddOnCatalogSumAggregateInputType = {
    defaultAmount?: true
  }

  export type GlobalAddOnCatalogMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultAmount?: true
    applicableTo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalAddOnCatalogMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultAmount?: true
    applicableTo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GlobalAddOnCatalogCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    defaultAmount?: true
    applicableTo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GlobalAddOnCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalAddOnCatalog to aggregate.
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalAddOnCatalogs to fetch.
     */
    orderBy?: GlobalAddOnCatalogOrderByWithRelationInput | GlobalAddOnCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalAddOnCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalAddOnCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalAddOnCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalAddOnCatalogs
    **/
    _count?: true | GlobalAddOnCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GlobalAddOnCatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GlobalAddOnCatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalAddOnCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalAddOnCatalogMaxAggregateInputType
  }

  export type GetGlobalAddOnCatalogAggregateType<T extends GlobalAddOnCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalAddOnCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalAddOnCatalog[P]>
      : GetScalarType<T[P], AggregateGlobalAddOnCatalog[P]>
  }




  export type GlobalAddOnCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalAddOnCatalogWhereInput
    orderBy?: GlobalAddOnCatalogOrderByWithAggregationInput | GlobalAddOnCatalogOrderByWithAggregationInput[]
    by: GlobalAddOnCatalogScalarFieldEnum[] | GlobalAddOnCatalogScalarFieldEnum
    having?: GlobalAddOnCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalAddOnCatalogCountAggregateInputType | true
    _avg?: GlobalAddOnCatalogAvgAggregateInputType
    _sum?: GlobalAddOnCatalogSumAggregateInputType
    _min?: GlobalAddOnCatalogMinAggregateInputType
    _max?: GlobalAddOnCatalogMaxAggregateInputType
  }

  export type GlobalAddOnCatalogGroupByOutputType = {
    id: string
    name: string
    description: string | null
    defaultAmount: Decimal
    applicableTo: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: GlobalAddOnCatalogCountAggregateOutputType | null
    _avg: GlobalAddOnCatalogAvgAggregateOutputType | null
    _sum: GlobalAddOnCatalogSumAggregateOutputType | null
    _min: GlobalAddOnCatalogMinAggregateOutputType | null
    _max: GlobalAddOnCatalogMaxAggregateOutputType | null
  }

  type GetGlobalAddOnCatalogGroupByPayload<T extends GlobalAddOnCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalAddOnCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalAddOnCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalAddOnCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalAddOnCatalogGroupByOutputType[P]>
        }
      >
    >


  export type GlobalAddOnCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultAmount?: boolean
    applicableTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceMappings?: boolean | GlobalAddOnCatalog$serviceMappingsArgs<ExtArgs>
    serviceAddOns?: boolean | GlobalAddOnCatalog$serviceAddOnsArgs<ExtArgs>
    _count?: boolean | GlobalAddOnCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["globalAddOnCatalog"]>

  export type GlobalAddOnCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultAmount?: boolean
    applicableTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalAddOnCatalog"]>

  export type GlobalAddOnCatalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    defaultAmount?: boolean
    applicableTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["globalAddOnCatalog"]>

  export type GlobalAddOnCatalogSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    defaultAmount?: boolean
    applicableTo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GlobalAddOnCatalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "defaultAmount" | "applicableTo" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["globalAddOnCatalog"]>
  export type GlobalAddOnCatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceMappings?: boolean | GlobalAddOnCatalog$serviceMappingsArgs<ExtArgs>
    serviceAddOns?: boolean | GlobalAddOnCatalog$serviceAddOnsArgs<ExtArgs>
    _count?: boolean | GlobalAddOnCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GlobalAddOnCatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GlobalAddOnCatalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GlobalAddOnCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalAddOnCatalog"
    objects: {
      serviceMappings: Prisma.$ServiceAddOnMappingPayload<ExtArgs>[]
      serviceAddOns: Prisma.$ServiceAddOnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      defaultAmount: Prisma.Decimal
      applicableTo: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["globalAddOnCatalog"]>
    composites: {}
  }

  type GlobalAddOnCatalogGetPayload<S extends boolean | null | undefined | GlobalAddOnCatalogDefaultArgs> = $Result.GetResult<Prisma.$GlobalAddOnCatalogPayload, S>

  type GlobalAddOnCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlobalAddOnCatalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlobalAddOnCatalogCountAggregateInputType | true
    }

  export interface GlobalAddOnCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalAddOnCatalog'], meta: { name: 'GlobalAddOnCatalog' } }
    /**
     * Find zero or one GlobalAddOnCatalog that matches the filter.
     * @param {GlobalAddOnCatalogFindUniqueArgs} args - Arguments to find a GlobalAddOnCatalog
     * @example
     * // Get one GlobalAddOnCatalog
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalAddOnCatalogFindUniqueArgs>(args: SelectSubset<T, GlobalAddOnCatalogFindUniqueArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GlobalAddOnCatalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlobalAddOnCatalogFindUniqueOrThrowArgs} args - Arguments to find a GlobalAddOnCatalog
     * @example
     * // Get one GlobalAddOnCatalog
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalAddOnCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalAddOnCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalAddOnCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogFindFirstArgs} args - Arguments to find a GlobalAddOnCatalog
     * @example
     * // Get one GlobalAddOnCatalog
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalAddOnCatalogFindFirstArgs>(args?: SelectSubset<T, GlobalAddOnCatalogFindFirstArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalAddOnCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogFindFirstOrThrowArgs} args - Arguments to find a GlobalAddOnCatalog
     * @example
     * // Get one GlobalAddOnCatalog
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalAddOnCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalAddOnCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GlobalAddOnCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalAddOnCatalogs
     * const globalAddOnCatalogs = await prisma.globalAddOnCatalog.findMany()
     * 
     * // Get first 10 GlobalAddOnCatalogs
     * const globalAddOnCatalogs = await prisma.globalAddOnCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalAddOnCatalogWithIdOnly = await prisma.globalAddOnCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalAddOnCatalogFindManyArgs>(args?: SelectSubset<T, GlobalAddOnCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GlobalAddOnCatalog.
     * @param {GlobalAddOnCatalogCreateArgs} args - Arguments to create a GlobalAddOnCatalog.
     * @example
     * // Create one GlobalAddOnCatalog
     * const GlobalAddOnCatalog = await prisma.globalAddOnCatalog.create({
     *   data: {
     *     // ... data to create a GlobalAddOnCatalog
     *   }
     * })
     * 
     */
    create<T extends GlobalAddOnCatalogCreateArgs>(args: SelectSubset<T, GlobalAddOnCatalogCreateArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GlobalAddOnCatalogs.
     * @param {GlobalAddOnCatalogCreateManyArgs} args - Arguments to create many GlobalAddOnCatalogs.
     * @example
     * // Create many GlobalAddOnCatalogs
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalAddOnCatalogCreateManyArgs>(args?: SelectSubset<T, GlobalAddOnCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalAddOnCatalogs and returns the data saved in the database.
     * @param {GlobalAddOnCatalogCreateManyAndReturnArgs} args - Arguments to create many GlobalAddOnCatalogs.
     * @example
     * // Create many GlobalAddOnCatalogs
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalAddOnCatalogs and only return the `id`
     * const globalAddOnCatalogWithIdOnly = await prisma.globalAddOnCatalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalAddOnCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalAddOnCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GlobalAddOnCatalog.
     * @param {GlobalAddOnCatalogDeleteArgs} args - Arguments to delete one GlobalAddOnCatalog.
     * @example
     * // Delete one GlobalAddOnCatalog
     * const GlobalAddOnCatalog = await prisma.globalAddOnCatalog.delete({
     *   where: {
     *     // ... filter to delete one GlobalAddOnCatalog
     *   }
     * })
     * 
     */
    delete<T extends GlobalAddOnCatalogDeleteArgs>(args: SelectSubset<T, GlobalAddOnCatalogDeleteArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GlobalAddOnCatalog.
     * @param {GlobalAddOnCatalogUpdateArgs} args - Arguments to update one GlobalAddOnCatalog.
     * @example
     * // Update one GlobalAddOnCatalog
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalAddOnCatalogUpdateArgs>(args: SelectSubset<T, GlobalAddOnCatalogUpdateArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GlobalAddOnCatalogs.
     * @param {GlobalAddOnCatalogDeleteManyArgs} args - Arguments to filter GlobalAddOnCatalogs to delete.
     * @example
     * // Delete a few GlobalAddOnCatalogs
     * const { count } = await prisma.globalAddOnCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalAddOnCatalogDeleteManyArgs>(args?: SelectSubset<T, GlobalAddOnCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalAddOnCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalAddOnCatalogs
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalAddOnCatalogUpdateManyArgs>(args: SelectSubset<T, GlobalAddOnCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalAddOnCatalogs and returns the data updated in the database.
     * @param {GlobalAddOnCatalogUpdateManyAndReturnArgs} args - Arguments to update many GlobalAddOnCatalogs.
     * @example
     * // Update many GlobalAddOnCatalogs
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GlobalAddOnCatalogs and only return the `id`
     * const globalAddOnCatalogWithIdOnly = await prisma.globalAddOnCatalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlobalAddOnCatalogUpdateManyAndReturnArgs>(args: SelectSubset<T, GlobalAddOnCatalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GlobalAddOnCatalog.
     * @param {GlobalAddOnCatalogUpsertArgs} args - Arguments to update or create a GlobalAddOnCatalog.
     * @example
     * // Update or create a GlobalAddOnCatalog
     * const globalAddOnCatalog = await prisma.globalAddOnCatalog.upsert({
     *   create: {
     *     // ... data to create a GlobalAddOnCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalAddOnCatalog we want to update
     *   }
     * })
     */
    upsert<T extends GlobalAddOnCatalogUpsertArgs>(args: SelectSubset<T, GlobalAddOnCatalogUpsertArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GlobalAddOnCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogCountArgs} args - Arguments to filter GlobalAddOnCatalogs to count.
     * @example
     * // Count the number of GlobalAddOnCatalogs
     * const count = await prisma.globalAddOnCatalog.count({
     *   where: {
     *     // ... the filter for the GlobalAddOnCatalogs we want to count
     *   }
     * })
    **/
    count<T extends GlobalAddOnCatalogCountArgs>(
      args?: Subset<T, GlobalAddOnCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalAddOnCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalAddOnCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalAddOnCatalogAggregateArgs>(args: Subset<T, GlobalAddOnCatalogAggregateArgs>): Prisma.PrismaPromise<GetGlobalAddOnCatalogAggregateType<T>>

    /**
     * Group by GlobalAddOnCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalAddOnCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalAddOnCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalAddOnCatalogGroupByArgs['orderBy'] }
        : { orderBy?: GlobalAddOnCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalAddOnCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalAddOnCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalAddOnCatalog model
   */
  readonly fields: GlobalAddOnCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalAddOnCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalAddOnCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceMappings<T extends GlobalAddOnCatalog$serviceMappingsArgs<ExtArgs> = {}>(args?: Subset<T, GlobalAddOnCatalog$serviceMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceAddOns<T extends GlobalAddOnCatalog$serviceAddOnsArgs<ExtArgs> = {}>(args?: Subset<T, GlobalAddOnCatalog$serviceAddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalAddOnCatalog model
   */
  interface GlobalAddOnCatalogFieldRefs {
    readonly id: FieldRef<"GlobalAddOnCatalog", 'String'>
    readonly name: FieldRef<"GlobalAddOnCatalog", 'String'>
    readonly description: FieldRef<"GlobalAddOnCatalog", 'String'>
    readonly defaultAmount: FieldRef<"GlobalAddOnCatalog", 'Decimal'>
    readonly applicableTo: FieldRef<"GlobalAddOnCatalog", 'String'>
    readonly isActive: FieldRef<"GlobalAddOnCatalog", 'Boolean'>
    readonly createdAt: FieldRef<"GlobalAddOnCatalog", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalAddOnCatalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GlobalAddOnCatalog findUnique
   */
  export type GlobalAddOnCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * Filter, which GlobalAddOnCatalog to fetch.
     */
    where: GlobalAddOnCatalogWhereUniqueInput
  }

  /**
   * GlobalAddOnCatalog findUniqueOrThrow
   */
  export type GlobalAddOnCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * Filter, which GlobalAddOnCatalog to fetch.
     */
    where: GlobalAddOnCatalogWhereUniqueInput
  }

  /**
   * GlobalAddOnCatalog findFirst
   */
  export type GlobalAddOnCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * Filter, which GlobalAddOnCatalog to fetch.
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalAddOnCatalogs to fetch.
     */
    orderBy?: GlobalAddOnCatalogOrderByWithRelationInput | GlobalAddOnCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalAddOnCatalogs.
     */
    cursor?: GlobalAddOnCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalAddOnCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalAddOnCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalAddOnCatalogs.
     */
    distinct?: GlobalAddOnCatalogScalarFieldEnum | GlobalAddOnCatalogScalarFieldEnum[]
  }

  /**
   * GlobalAddOnCatalog findFirstOrThrow
   */
  export type GlobalAddOnCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * Filter, which GlobalAddOnCatalog to fetch.
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalAddOnCatalogs to fetch.
     */
    orderBy?: GlobalAddOnCatalogOrderByWithRelationInput | GlobalAddOnCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalAddOnCatalogs.
     */
    cursor?: GlobalAddOnCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalAddOnCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalAddOnCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalAddOnCatalogs.
     */
    distinct?: GlobalAddOnCatalogScalarFieldEnum | GlobalAddOnCatalogScalarFieldEnum[]
  }

  /**
   * GlobalAddOnCatalog findMany
   */
  export type GlobalAddOnCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * Filter, which GlobalAddOnCatalogs to fetch.
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalAddOnCatalogs to fetch.
     */
    orderBy?: GlobalAddOnCatalogOrderByWithRelationInput | GlobalAddOnCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalAddOnCatalogs.
     */
    cursor?: GlobalAddOnCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalAddOnCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalAddOnCatalogs.
     */
    skip?: number
    distinct?: GlobalAddOnCatalogScalarFieldEnum | GlobalAddOnCatalogScalarFieldEnum[]
  }

  /**
   * GlobalAddOnCatalog create
   */
  export type GlobalAddOnCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a GlobalAddOnCatalog.
     */
    data: XOR<GlobalAddOnCatalogCreateInput, GlobalAddOnCatalogUncheckedCreateInput>
  }

  /**
   * GlobalAddOnCatalog createMany
   */
  export type GlobalAddOnCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalAddOnCatalogs.
     */
    data: GlobalAddOnCatalogCreateManyInput | GlobalAddOnCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalAddOnCatalog createManyAndReturn
   */
  export type GlobalAddOnCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * The data used to create many GlobalAddOnCatalogs.
     */
    data: GlobalAddOnCatalogCreateManyInput | GlobalAddOnCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalAddOnCatalog update
   */
  export type GlobalAddOnCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a GlobalAddOnCatalog.
     */
    data: XOR<GlobalAddOnCatalogUpdateInput, GlobalAddOnCatalogUncheckedUpdateInput>
    /**
     * Choose, which GlobalAddOnCatalog to update.
     */
    where: GlobalAddOnCatalogWhereUniqueInput
  }

  /**
   * GlobalAddOnCatalog updateMany
   */
  export type GlobalAddOnCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalAddOnCatalogs.
     */
    data: XOR<GlobalAddOnCatalogUpdateManyMutationInput, GlobalAddOnCatalogUncheckedUpdateManyInput>
    /**
     * Filter which GlobalAddOnCatalogs to update
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * Limit how many GlobalAddOnCatalogs to update.
     */
    limit?: number
  }

  /**
   * GlobalAddOnCatalog updateManyAndReturn
   */
  export type GlobalAddOnCatalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * The data used to update GlobalAddOnCatalogs.
     */
    data: XOR<GlobalAddOnCatalogUpdateManyMutationInput, GlobalAddOnCatalogUncheckedUpdateManyInput>
    /**
     * Filter which GlobalAddOnCatalogs to update
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * Limit how many GlobalAddOnCatalogs to update.
     */
    limit?: number
  }

  /**
   * GlobalAddOnCatalog upsert
   */
  export type GlobalAddOnCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the GlobalAddOnCatalog to update in case it exists.
     */
    where: GlobalAddOnCatalogWhereUniqueInput
    /**
     * In case the GlobalAddOnCatalog found by the `where` argument doesn't exist, create a new GlobalAddOnCatalog with this data.
     */
    create: XOR<GlobalAddOnCatalogCreateInput, GlobalAddOnCatalogUncheckedCreateInput>
    /**
     * In case the GlobalAddOnCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalAddOnCatalogUpdateInput, GlobalAddOnCatalogUncheckedUpdateInput>
  }

  /**
   * GlobalAddOnCatalog delete
   */
  export type GlobalAddOnCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
    /**
     * Filter which GlobalAddOnCatalog to delete.
     */
    where: GlobalAddOnCatalogWhereUniqueInput
  }

  /**
   * GlobalAddOnCatalog deleteMany
   */
  export type GlobalAddOnCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalAddOnCatalogs to delete
     */
    where?: GlobalAddOnCatalogWhereInput
    /**
     * Limit how many GlobalAddOnCatalogs to delete.
     */
    limit?: number
  }

  /**
   * GlobalAddOnCatalog.serviceMappings
   */
  export type GlobalAddOnCatalog$serviceMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    where?: ServiceAddOnMappingWhereInput
    orderBy?: ServiceAddOnMappingOrderByWithRelationInput | ServiceAddOnMappingOrderByWithRelationInput[]
    cursor?: ServiceAddOnMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAddOnMappingScalarFieldEnum | ServiceAddOnMappingScalarFieldEnum[]
  }

  /**
   * GlobalAddOnCatalog.serviceAddOns
   */
  export type GlobalAddOnCatalog$serviceAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    where?: ServiceAddOnWhereInput
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    cursor?: ServiceAddOnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAddOnScalarFieldEnum | ServiceAddOnScalarFieldEnum[]
  }

  /**
   * GlobalAddOnCatalog without action
   */
  export type GlobalAddOnCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalAddOnCatalog
     */
    select?: GlobalAddOnCatalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalAddOnCatalog
     */
    omit?: GlobalAddOnCatalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GlobalAddOnCatalogInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAddOnMapping
   */

  export type AggregateServiceAddOnMapping = {
    _count: ServiceAddOnMappingCountAggregateOutputType | null
    _avg: ServiceAddOnMappingAvgAggregateOutputType | null
    _sum: ServiceAddOnMappingSumAggregateOutputType | null
    _min: ServiceAddOnMappingMinAggregateOutputType | null
    _max: ServiceAddOnMappingMaxAggregateOutputType | null
  }

  export type ServiceAddOnMappingAvgAggregateOutputType = {
    customAmount: Decimal | null
  }

  export type ServiceAddOnMappingSumAggregateOutputType = {
    customAmount: Decimal | null
  }

  export type ServiceAddOnMappingMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    addOnId: string | null
    isEnabled: boolean | null
    customAmount: Decimal | null
    createdAt: Date | null
  }

  export type ServiceAddOnMappingMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    addOnId: string | null
    isEnabled: boolean | null
    customAmount: Decimal | null
    createdAt: Date | null
  }

  export type ServiceAddOnMappingCountAggregateOutputType = {
    id: number
    serviceId: number
    addOnId: number
    isEnabled: number
    customAmount: number
    createdAt: number
    _all: number
  }


  export type ServiceAddOnMappingAvgAggregateInputType = {
    customAmount?: true
  }

  export type ServiceAddOnMappingSumAggregateInputType = {
    customAmount?: true
  }

  export type ServiceAddOnMappingMinAggregateInputType = {
    id?: true
    serviceId?: true
    addOnId?: true
    isEnabled?: true
    customAmount?: true
    createdAt?: true
  }

  export type ServiceAddOnMappingMaxAggregateInputType = {
    id?: true
    serviceId?: true
    addOnId?: true
    isEnabled?: true
    customAmount?: true
    createdAt?: true
  }

  export type ServiceAddOnMappingCountAggregateInputType = {
    id?: true
    serviceId?: true
    addOnId?: true
    isEnabled?: true
    customAmount?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAddOnMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAddOnMapping to aggregate.
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOnMappings to fetch.
     */
    orderBy?: ServiceAddOnMappingOrderByWithRelationInput | ServiceAddOnMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAddOnMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOnMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOnMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAddOnMappings
    **/
    _count?: true | ServiceAddOnMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAddOnMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceAddOnMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAddOnMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAddOnMappingMaxAggregateInputType
  }

  export type GetServiceAddOnMappingAggregateType<T extends ServiceAddOnMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAddOnMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAddOnMapping[P]>
      : GetScalarType<T[P], AggregateServiceAddOnMapping[P]>
  }




  export type ServiceAddOnMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnMappingWhereInput
    orderBy?: ServiceAddOnMappingOrderByWithAggregationInput | ServiceAddOnMappingOrderByWithAggregationInput[]
    by: ServiceAddOnMappingScalarFieldEnum[] | ServiceAddOnMappingScalarFieldEnum
    having?: ServiceAddOnMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAddOnMappingCountAggregateInputType | true
    _avg?: ServiceAddOnMappingAvgAggregateInputType
    _sum?: ServiceAddOnMappingSumAggregateInputType
    _min?: ServiceAddOnMappingMinAggregateInputType
    _max?: ServiceAddOnMappingMaxAggregateInputType
  }

  export type ServiceAddOnMappingGroupByOutputType = {
    id: string
    serviceId: string
    addOnId: string
    isEnabled: boolean
    customAmount: Decimal | null
    createdAt: Date
    _count: ServiceAddOnMappingCountAggregateOutputType | null
    _avg: ServiceAddOnMappingAvgAggregateOutputType | null
    _sum: ServiceAddOnMappingSumAggregateOutputType | null
    _min: ServiceAddOnMappingMinAggregateOutputType | null
    _max: ServiceAddOnMappingMaxAggregateOutputType | null
  }

  type GetServiceAddOnMappingGroupByPayload<T extends ServiceAddOnMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAddOnMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAddOnMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAddOnMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAddOnMappingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAddOnMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    addOnId?: boolean
    isEnabled?: boolean
    customAmount?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAddOnMapping"]>

  export type ServiceAddOnMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    addOnId?: boolean
    isEnabled?: boolean
    customAmount?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAddOnMapping"]>

  export type ServiceAddOnMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    addOnId?: boolean
    isEnabled?: boolean
    customAmount?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAddOnMapping"]>

  export type ServiceAddOnMappingSelectScalar = {
    id?: boolean
    serviceId?: boolean
    addOnId?: boolean
    isEnabled?: boolean
    customAmount?: boolean
    createdAt?: boolean
  }

  export type ServiceAddOnMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "addOnId" | "isEnabled" | "customAmount" | "createdAt", ExtArgs["result"]["serviceAddOnMapping"]>
  export type ServiceAddOnMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }
  export type ServiceAddOnMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }
  export type ServiceAddOnMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }

  export type $ServiceAddOnMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAddOnMapping"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      addOnCatalog: Prisma.$GlobalAddOnCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      addOnId: string
      isEnabled: boolean
      customAmount: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["serviceAddOnMapping"]>
    composites: {}
  }

  type ServiceAddOnMappingGetPayload<S extends boolean | null | undefined | ServiceAddOnMappingDefaultArgs> = $Result.GetResult<Prisma.$ServiceAddOnMappingPayload, S>

  type ServiceAddOnMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceAddOnMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceAddOnMappingCountAggregateInputType | true
    }

  export interface ServiceAddOnMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAddOnMapping'], meta: { name: 'ServiceAddOnMapping' } }
    /**
     * Find zero or one ServiceAddOnMapping that matches the filter.
     * @param {ServiceAddOnMappingFindUniqueArgs} args - Arguments to find a ServiceAddOnMapping
     * @example
     * // Get one ServiceAddOnMapping
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAddOnMappingFindUniqueArgs>(args: SelectSubset<T, ServiceAddOnMappingFindUniqueArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceAddOnMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceAddOnMappingFindUniqueOrThrowArgs} args - Arguments to find a ServiceAddOnMapping
     * @example
     * // Get one ServiceAddOnMapping
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAddOnMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAddOnMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAddOnMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingFindFirstArgs} args - Arguments to find a ServiceAddOnMapping
     * @example
     * // Get one ServiceAddOnMapping
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAddOnMappingFindFirstArgs>(args?: SelectSubset<T, ServiceAddOnMappingFindFirstArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAddOnMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingFindFirstOrThrowArgs} args - Arguments to find a ServiceAddOnMapping
     * @example
     * // Get one ServiceAddOnMapping
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAddOnMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAddOnMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceAddOnMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAddOnMappings
     * const serviceAddOnMappings = await prisma.serviceAddOnMapping.findMany()
     * 
     * // Get first 10 ServiceAddOnMappings
     * const serviceAddOnMappings = await prisma.serviceAddOnMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAddOnMappingWithIdOnly = await prisma.serviceAddOnMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAddOnMappingFindManyArgs>(args?: SelectSubset<T, ServiceAddOnMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceAddOnMapping.
     * @param {ServiceAddOnMappingCreateArgs} args - Arguments to create a ServiceAddOnMapping.
     * @example
     * // Create one ServiceAddOnMapping
     * const ServiceAddOnMapping = await prisma.serviceAddOnMapping.create({
     *   data: {
     *     // ... data to create a ServiceAddOnMapping
     *   }
     * })
     * 
     */
    create<T extends ServiceAddOnMappingCreateArgs>(args: SelectSubset<T, ServiceAddOnMappingCreateArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceAddOnMappings.
     * @param {ServiceAddOnMappingCreateManyArgs} args - Arguments to create many ServiceAddOnMappings.
     * @example
     * // Create many ServiceAddOnMappings
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAddOnMappingCreateManyArgs>(args?: SelectSubset<T, ServiceAddOnMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAddOnMappings and returns the data saved in the database.
     * @param {ServiceAddOnMappingCreateManyAndReturnArgs} args - Arguments to create many ServiceAddOnMappings.
     * @example
     * // Create many ServiceAddOnMappings
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAddOnMappings and only return the `id`
     * const serviceAddOnMappingWithIdOnly = await prisma.serviceAddOnMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAddOnMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAddOnMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceAddOnMapping.
     * @param {ServiceAddOnMappingDeleteArgs} args - Arguments to delete one ServiceAddOnMapping.
     * @example
     * // Delete one ServiceAddOnMapping
     * const ServiceAddOnMapping = await prisma.serviceAddOnMapping.delete({
     *   where: {
     *     // ... filter to delete one ServiceAddOnMapping
     *   }
     * })
     * 
     */
    delete<T extends ServiceAddOnMappingDeleteArgs>(args: SelectSubset<T, ServiceAddOnMappingDeleteArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceAddOnMapping.
     * @param {ServiceAddOnMappingUpdateArgs} args - Arguments to update one ServiceAddOnMapping.
     * @example
     * // Update one ServiceAddOnMapping
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAddOnMappingUpdateArgs>(args: SelectSubset<T, ServiceAddOnMappingUpdateArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceAddOnMappings.
     * @param {ServiceAddOnMappingDeleteManyArgs} args - Arguments to filter ServiceAddOnMappings to delete.
     * @example
     * // Delete a few ServiceAddOnMappings
     * const { count } = await prisma.serviceAddOnMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAddOnMappingDeleteManyArgs>(args?: SelectSubset<T, ServiceAddOnMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAddOnMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAddOnMappings
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAddOnMappingUpdateManyArgs>(args: SelectSubset<T, ServiceAddOnMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAddOnMappings and returns the data updated in the database.
     * @param {ServiceAddOnMappingUpdateManyAndReturnArgs} args - Arguments to update many ServiceAddOnMappings.
     * @example
     * // Update many ServiceAddOnMappings
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceAddOnMappings and only return the `id`
     * const serviceAddOnMappingWithIdOnly = await prisma.serviceAddOnMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceAddOnMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceAddOnMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceAddOnMapping.
     * @param {ServiceAddOnMappingUpsertArgs} args - Arguments to update or create a ServiceAddOnMapping.
     * @example
     * // Update or create a ServiceAddOnMapping
     * const serviceAddOnMapping = await prisma.serviceAddOnMapping.upsert({
     *   create: {
     *     // ... data to create a ServiceAddOnMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAddOnMapping we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAddOnMappingUpsertArgs>(args: SelectSubset<T, ServiceAddOnMappingUpsertArgs<ExtArgs>>): Prisma__ServiceAddOnMappingClient<$Result.GetResult<Prisma.$ServiceAddOnMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceAddOnMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingCountArgs} args - Arguments to filter ServiceAddOnMappings to count.
     * @example
     * // Count the number of ServiceAddOnMappings
     * const count = await prisma.serviceAddOnMapping.count({
     *   where: {
     *     // ... the filter for the ServiceAddOnMappings we want to count
     *   }
     * })
    **/
    count<T extends ServiceAddOnMappingCountArgs>(
      args?: Subset<T, ServiceAddOnMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAddOnMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAddOnMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAddOnMappingAggregateArgs>(args: Subset<T, ServiceAddOnMappingAggregateArgs>): Prisma.PrismaPromise<GetServiceAddOnMappingAggregateType<T>>

    /**
     * Group by ServiceAddOnMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAddOnMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAddOnMappingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAddOnMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAddOnMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAddOnMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAddOnMapping model
   */
  readonly fields: ServiceAddOnMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAddOnMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAddOnMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addOnCatalog<T extends GlobalAddOnCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GlobalAddOnCatalogDefaultArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAddOnMapping model
   */
  interface ServiceAddOnMappingFieldRefs {
    readonly id: FieldRef<"ServiceAddOnMapping", 'String'>
    readonly serviceId: FieldRef<"ServiceAddOnMapping", 'String'>
    readonly addOnId: FieldRef<"ServiceAddOnMapping", 'String'>
    readonly isEnabled: FieldRef<"ServiceAddOnMapping", 'Boolean'>
    readonly customAmount: FieldRef<"ServiceAddOnMapping", 'Decimal'>
    readonly createdAt: FieldRef<"ServiceAddOnMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAddOnMapping findUnique
   */
  export type ServiceAddOnMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOnMapping to fetch.
     */
    where: ServiceAddOnMappingWhereUniqueInput
  }

  /**
   * ServiceAddOnMapping findUniqueOrThrow
   */
  export type ServiceAddOnMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOnMapping to fetch.
     */
    where: ServiceAddOnMappingWhereUniqueInput
  }

  /**
   * ServiceAddOnMapping findFirst
   */
  export type ServiceAddOnMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOnMapping to fetch.
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOnMappings to fetch.
     */
    orderBy?: ServiceAddOnMappingOrderByWithRelationInput | ServiceAddOnMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAddOnMappings.
     */
    cursor?: ServiceAddOnMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOnMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOnMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAddOnMappings.
     */
    distinct?: ServiceAddOnMappingScalarFieldEnum | ServiceAddOnMappingScalarFieldEnum[]
  }

  /**
   * ServiceAddOnMapping findFirstOrThrow
   */
  export type ServiceAddOnMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOnMapping to fetch.
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOnMappings to fetch.
     */
    orderBy?: ServiceAddOnMappingOrderByWithRelationInput | ServiceAddOnMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAddOnMappings.
     */
    cursor?: ServiceAddOnMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOnMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOnMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAddOnMappings.
     */
    distinct?: ServiceAddOnMappingScalarFieldEnum | ServiceAddOnMappingScalarFieldEnum[]
  }

  /**
   * ServiceAddOnMapping findMany
   */
  export type ServiceAddOnMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOnMappings to fetch.
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOnMappings to fetch.
     */
    orderBy?: ServiceAddOnMappingOrderByWithRelationInput | ServiceAddOnMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAddOnMappings.
     */
    cursor?: ServiceAddOnMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOnMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOnMappings.
     */
    skip?: number
    distinct?: ServiceAddOnMappingScalarFieldEnum | ServiceAddOnMappingScalarFieldEnum[]
  }

  /**
   * ServiceAddOnMapping create
   */
  export type ServiceAddOnMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAddOnMapping.
     */
    data: XOR<ServiceAddOnMappingCreateInput, ServiceAddOnMappingUncheckedCreateInput>
  }

  /**
   * ServiceAddOnMapping createMany
   */
  export type ServiceAddOnMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAddOnMappings.
     */
    data: ServiceAddOnMappingCreateManyInput | ServiceAddOnMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAddOnMapping createManyAndReturn
   */
  export type ServiceAddOnMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceAddOnMappings.
     */
    data: ServiceAddOnMappingCreateManyInput | ServiceAddOnMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAddOnMapping update
   */
  export type ServiceAddOnMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAddOnMapping.
     */
    data: XOR<ServiceAddOnMappingUpdateInput, ServiceAddOnMappingUncheckedUpdateInput>
    /**
     * Choose, which ServiceAddOnMapping to update.
     */
    where: ServiceAddOnMappingWhereUniqueInput
  }

  /**
   * ServiceAddOnMapping updateMany
   */
  export type ServiceAddOnMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAddOnMappings.
     */
    data: XOR<ServiceAddOnMappingUpdateManyMutationInput, ServiceAddOnMappingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAddOnMappings to update
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * Limit how many ServiceAddOnMappings to update.
     */
    limit?: number
  }

  /**
   * ServiceAddOnMapping updateManyAndReturn
   */
  export type ServiceAddOnMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * The data used to update ServiceAddOnMappings.
     */
    data: XOR<ServiceAddOnMappingUpdateManyMutationInput, ServiceAddOnMappingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAddOnMappings to update
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * Limit how many ServiceAddOnMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAddOnMapping upsert
   */
  export type ServiceAddOnMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAddOnMapping to update in case it exists.
     */
    where: ServiceAddOnMappingWhereUniqueInput
    /**
     * In case the ServiceAddOnMapping found by the `where` argument doesn't exist, create a new ServiceAddOnMapping with this data.
     */
    create: XOR<ServiceAddOnMappingCreateInput, ServiceAddOnMappingUncheckedCreateInput>
    /**
     * In case the ServiceAddOnMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAddOnMappingUpdateInput, ServiceAddOnMappingUncheckedUpdateInput>
  }

  /**
   * ServiceAddOnMapping delete
   */
  export type ServiceAddOnMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
    /**
     * Filter which ServiceAddOnMapping to delete.
     */
    where: ServiceAddOnMappingWhereUniqueInput
  }

  /**
   * ServiceAddOnMapping deleteMany
   */
  export type ServiceAddOnMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAddOnMappings to delete
     */
    where?: ServiceAddOnMappingWhereInput
    /**
     * Limit how many ServiceAddOnMappings to delete.
     */
    limit?: number
  }

  /**
   * ServiceAddOnMapping without action
   */
  export type ServiceAddOnMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOnMapping
     */
    select?: ServiceAddOnMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOnMapping
     */
    omit?: ServiceAddOnMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnMappingInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAddOn
   */

  export type AggregateServiceAddOn = {
    _count: ServiceAddOnCountAggregateOutputType | null
    _avg: ServiceAddOnAvgAggregateOutputType | null
    _sum: ServiceAddOnSumAggregateOutputType | null
    _min: ServiceAddOnMinAggregateOutputType | null
    _max: ServiceAddOnMaxAggregateOutputType | null
  }

  export type ServiceAddOnAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ServiceAddOnSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ServiceAddOnMinAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    workspaceBookingId: string | null
    addOnCatalogId: string | null
    name: string | null
    amount: Decimal | null
    taxable: boolean | null
    description: string | null
    createdAt: Date | null
  }

  export type ServiceAddOnMaxAggregateOutputType = {
    id: string | null
    bookingServiceItemId: string | null
    workspaceBookingId: string | null
    addOnCatalogId: string | null
    name: string | null
    amount: Decimal | null
    taxable: boolean | null
    description: string | null
    createdAt: Date | null
  }

  export type ServiceAddOnCountAggregateOutputType = {
    id: number
    bookingServiceItemId: number
    workspaceBookingId: number
    addOnCatalogId: number
    name: number
    amount: number
    taxable: number
    description: number
    createdAt: number
    _all: number
  }


  export type ServiceAddOnAvgAggregateInputType = {
    amount?: true
  }

  export type ServiceAddOnSumAggregateInputType = {
    amount?: true
  }

  export type ServiceAddOnMinAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    workspaceBookingId?: true
    addOnCatalogId?: true
    name?: true
    amount?: true
    taxable?: true
    description?: true
    createdAt?: true
  }

  export type ServiceAddOnMaxAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    workspaceBookingId?: true
    addOnCatalogId?: true
    name?: true
    amount?: true
    taxable?: true
    description?: true
    createdAt?: true
  }

  export type ServiceAddOnCountAggregateInputType = {
    id?: true
    bookingServiceItemId?: true
    workspaceBookingId?: true
    addOnCatalogId?: true
    name?: true
    amount?: true
    taxable?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAddOnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAddOn to aggregate.
     */
    where?: ServiceAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOns to fetch.
     */
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAddOns
    **/
    _count?: true | ServiceAddOnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAddOnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceAddOnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAddOnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAddOnMaxAggregateInputType
  }

  export type GetServiceAddOnAggregateType<T extends ServiceAddOnAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAddOn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAddOn[P]>
      : GetScalarType<T[P], AggregateServiceAddOn[P]>
  }




  export type ServiceAddOnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAddOnWhereInput
    orderBy?: ServiceAddOnOrderByWithAggregationInput | ServiceAddOnOrderByWithAggregationInput[]
    by: ServiceAddOnScalarFieldEnum[] | ServiceAddOnScalarFieldEnum
    having?: ServiceAddOnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAddOnCountAggregateInputType | true
    _avg?: ServiceAddOnAvgAggregateInputType
    _sum?: ServiceAddOnSumAggregateInputType
    _min?: ServiceAddOnMinAggregateInputType
    _max?: ServiceAddOnMaxAggregateInputType
  }

  export type ServiceAddOnGroupByOutputType = {
    id: string
    bookingServiceItemId: string | null
    workspaceBookingId: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal
    taxable: boolean
    description: string | null
    createdAt: Date
    _count: ServiceAddOnCountAggregateOutputType | null
    _avg: ServiceAddOnAvgAggregateOutputType | null
    _sum: ServiceAddOnSumAggregateOutputType | null
    _min: ServiceAddOnMinAggregateOutputType | null
    _max: ServiceAddOnMaxAggregateOutputType | null
  }

  type GetServiceAddOnGroupByPayload<T extends ServiceAddOnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAddOnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAddOnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAddOnGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAddOnGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAddOnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    workspaceBookingId?: boolean
    addOnCatalogId?: boolean
    name?: boolean
    amount?: boolean
    taxable?: boolean
    description?: boolean
    createdAt?: boolean
    bookingServiceItem?: boolean | ServiceAddOn$bookingServiceItemArgs<ExtArgs>
    workspaceBooking?: boolean | ServiceAddOn$workspaceBookingArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAddOn"]>

  export type ServiceAddOnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    workspaceBookingId?: boolean
    addOnCatalogId?: boolean
    name?: boolean
    amount?: boolean
    taxable?: boolean
    description?: boolean
    createdAt?: boolean
    bookingServiceItem?: boolean | ServiceAddOn$bookingServiceItemArgs<ExtArgs>
    workspaceBooking?: boolean | ServiceAddOn$workspaceBookingArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAddOn"]>

  export type ServiceAddOnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingServiceItemId?: boolean
    workspaceBookingId?: boolean
    addOnCatalogId?: boolean
    name?: boolean
    amount?: boolean
    taxable?: boolean
    description?: boolean
    createdAt?: boolean
    bookingServiceItem?: boolean | ServiceAddOn$bookingServiceItemArgs<ExtArgs>
    workspaceBooking?: boolean | ServiceAddOn$workspaceBookingArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAddOn"]>

  export type ServiceAddOnSelectScalar = {
    id?: boolean
    bookingServiceItemId?: boolean
    workspaceBookingId?: boolean
    addOnCatalogId?: boolean
    name?: boolean
    amount?: boolean
    taxable?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ServiceAddOnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingServiceItemId" | "workspaceBookingId" | "addOnCatalogId" | "name" | "amount" | "taxable" | "description" | "createdAt", ExtArgs["result"]["serviceAddOn"]>
  export type ServiceAddOnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | ServiceAddOn$bookingServiceItemArgs<ExtArgs>
    workspaceBooking?: boolean | ServiceAddOn$workspaceBookingArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }
  export type ServiceAddOnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | ServiceAddOn$bookingServiceItemArgs<ExtArgs>
    workspaceBooking?: boolean | ServiceAddOn$workspaceBookingArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }
  export type ServiceAddOnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingServiceItem?: boolean | ServiceAddOn$bookingServiceItemArgs<ExtArgs>
    workspaceBooking?: boolean | ServiceAddOn$workspaceBookingArgs<ExtArgs>
    addOnCatalog?: boolean | GlobalAddOnCatalogDefaultArgs<ExtArgs>
  }

  export type $ServiceAddOnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAddOn"
    objects: {
      bookingServiceItem: Prisma.$BookingServiceItemPayload<ExtArgs> | null
      workspaceBooking: Prisma.$WorkspaceBookingPayload<ExtArgs> | null
      addOnCatalog: Prisma.$GlobalAddOnCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingServiceItemId: string | null
      workspaceBookingId: string | null
      addOnCatalogId: string
      name: string
      amount: Prisma.Decimal
      taxable: boolean
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["serviceAddOn"]>
    composites: {}
  }

  type ServiceAddOnGetPayload<S extends boolean | null | undefined | ServiceAddOnDefaultArgs> = $Result.GetResult<Prisma.$ServiceAddOnPayload, S>

  type ServiceAddOnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceAddOnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceAddOnCountAggregateInputType | true
    }

  export interface ServiceAddOnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAddOn'], meta: { name: 'ServiceAddOn' } }
    /**
     * Find zero or one ServiceAddOn that matches the filter.
     * @param {ServiceAddOnFindUniqueArgs} args - Arguments to find a ServiceAddOn
     * @example
     * // Get one ServiceAddOn
     * const serviceAddOn = await prisma.serviceAddOn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAddOnFindUniqueArgs>(args: SelectSubset<T, ServiceAddOnFindUniqueArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceAddOn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceAddOnFindUniqueOrThrowArgs} args - Arguments to find a ServiceAddOn
     * @example
     * // Get one ServiceAddOn
     * const serviceAddOn = await prisma.serviceAddOn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAddOnFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAddOnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAddOn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnFindFirstArgs} args - Arguments to find a ServiceAddOn
     * @example
     * // Get one ServiceAddOn
     * const serviceAddOn = await prisma.serviceAddOn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAddOnFindFirstArgs>(args?: SelectSubset<T, ServiceAddOnFindFirstArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAddOn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnFindFirstOrThrowArgs} args - Arguments to find a ServiceAddOn
     * @example
     * // Get one ServiceAddOn
     * const serviceAddOn = await prisma.serviceAddOn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAddOnFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAddOnFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceAddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAddOns
     * const serviceAddOns = await prisma.serviceAddOn.findMany()
     * 
     * // Get first 10 ServiceAddOns
     * const serviceAddOns = await prisma.serviceAddOn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAddOnWithIdOnly = await prisma.serviceAddOn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAddOnFindManyArgs>(args?: SelectSubset<T, ServiceAddOnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceAddOn.
     * @param {ServiceAddOnCreateArgs} args - Arguments to create a ServiceAddOn.
     * @example
     * // Create one ServiceAddOn
     * const ServiceAddOn = await prisma.serviceAddOn.create({
     *   data: {
     *     // ... data to create a ServiceAddOn
     *   }
     * })
     * 
     */
    create<T extends ServiceAddOnCreateArgs>(args: SelectSubset<T, ServiceAddOnCreateArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceAddOns.
     * @param {ServiceAddOnCreateManyArgs} args - Arguments to create many ServiceAddOns.
     * @example
     * // Create many ServiceAddOns
     * const serviceAddOn = await prisma.serviceAddOn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAddOnCreateManyArgs>(args?: SelectSubset<T, ServiceAddOnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAddOns and returns the data saved in the database.
     * @param {ServiceAddOnCreateManyAndReturnArgs} args - Arguments to create many ServiceAddOns.
     * @example
     * // Create many ServiceAddOns
     * const serviceAddOn = await prisma.serviceAddOn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAddOns and only return the `id`
     * const serviceAddOnWithIdOnly = await prisma.serviceAddOn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAddOnCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAddOnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceAddOn.
     * @param {ServiceAddOnDeleteArgs} args - Arguments to delete one ServiceAddOn.
     * @example
     * // Delete one ServiceAddOn
     * const ServiceAddOn = await prisma.serviceAddOn.delete({
     *   where: {
     *     // ... filter to delete one ServiceAddOn
     *   }
     * })
     * 
     */
    delete<T extends ServiceAddOnDeleteArgs>(args: SelectSubset<T, ServiceAddOnDeleteArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceAddOn.
     * @param {ServiceAddOnUpdateArgs} args - Arguments to update one ServiceAddOn.
     * @example
     * // Update one ServiceAddOn
     * const serviceAddOn = await prisma.serviceAddOn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAddOnUpdateArgs>(args: SelectSubset<T, ServiceAddOnUpdateArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceAddOns.
     * @param {ServiceAddOnDeleteManyArgs} args - Arguments to filter ServiceAddOns to delete.
     * @example
     * // Delete a few ServiceAddOns
     * const { count } = await prisma.serviceAddOn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAddOnDeleteManyArgs>(args?: SelectSubset<T, ServiceAddOnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAddOns
     * const serviceAddOn = await prisma.serviceAddOn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAddOnUpdateManyArgs>(args: SelectSubset<T, ServiceAddOnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAddOns and returns the data updated in the database.
     * @param {ServiceAddOnUpdateManyAndReturnArgs} args - Arguments to update many ServiceAddOns.
     * @example
     * // Update many ServiceAddOns
     * const serviceAddOn = await prisma.serviceAddOn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceAddOns and only return the `id`
     * const serviceAddOnWithIdOnly = await prisma.serviceAddOn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceAddOnUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceAddOnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceAddOn.
     * @param {ServiceAddOnUpsertArgs} args - Arguments to update or create a ServiceAddOn.
     * @example
     * // Update or create a ServiceAddOn
     * const serviceAddOn = await prisma.serviceAddOn.upsert({
     *   create: {
     *     // ... data to create a ServiceAddOn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAddOn we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAddOnUpsertArgs>(args: SelectSubset<T, ServiceAddOnUpsertArgs<ExtArgs>>): Prisma__ServiceAddOnClient<$Result.GetResult<Prisma.$ServiceAddOnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceAddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnCountArgs} args - Arguments to filter ServiceAddOns to count.
     * @example
     * // Count the number of ServiceAddOns
     * const count = await prisma.serviceAddOn.count({
     *   where: {
     *     // ... the filter for the ServiceAddOns we want to count
     *   }
     * })
    **/
    count<T extends ServiceAddOnCountArgs>(
      args?: Subset<T, ServiceAddOnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAddOnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAddOnAggregateArgs>(args: Subset<T, ServiceAddOnAggregateArgs>): Prisma.PrismaPromise<GetServiceAddOnAggregateType<T>>

    /**
     * Group by ServiceAddOn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAddOnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAddOnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAddOnGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAddOnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAddOnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAddOnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAddOn model
   */
  readonly fields: ServiceAddOnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAddOn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAddOnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingServiceItem<T extends ServiceAddOn$bookingServiceItemArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAddOn$bookingServiceItemArgs<ExtArgs>>): Prisma__BookingServiceItemClient<$Result.GetResult<Prisma.$BookingServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workspaceBooking<T extends ServiceAddOn$workspaceBookingArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAddOn$workspaceBookingArgs<ExtArgs>>): Prisma__WorkspaceBookingClient<$Result.GetResult<Prisma.$WorkspaceBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addOnCatalog<T extends GlobalAddOnCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GlobalAddOnCatalogDefaultArgs<ExtArgs>>): Prisma__GlobalAddOnCatalogClient<$Result.GetResult<Prisma.$GlobalAddOnCatalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAddOn model
   */
  interface ServiceAddOnFieldRefs {
    readonly id: FieldRef<"ServiceAddOn", 'String'>
    readonly bookingServiceItemId: FieldRef<"ServiceAddOn", 'String'>
    readonly workspaceBookingId: FieldRef<"ServiceAddOn", 'String'>
    readonly addOnCatalogId: FieldRef<"ServiceAddOn", 'String'>
    readonly name: FieldRef<"ServiceAddOn", 'String'>
    readonly amount: FieldRef<"ServiceAddOn", 'Decimal'>
    readonly taxable: FieldRef<"ServiceAddOn", 'Boolean'>
    readonly description: FieldRef<"ServiceAddOn", 'String'>
    readonly createdAt: FieldRef<"ServiceAddOn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAddOn findUnique
   */
  export type ServiceAddOnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOn to fetch.
     */
    where: ServiceAddOnWhereUniqueInput
  }

  /**
   * ServiceAddOn findUniqueOrThrow
   */
  export type ServiceAddOnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOn to fetch.
     */
    where: ServiceAddOnWhereUniqueInput
  }

  /**
   * ServiceAddOn findFirst
   */
  export type ServiceAddOnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOn to fetch.
     */
    where?: ServiceAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOns to fetch.
     */
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAddOns.
     */
    cursor?: ServiceAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAddOns.
     */
    distinct?: ServiceAddOnScalarFieldEnum | ServiceAddOnScalarFieldEnum[]
  }

  /**
   * ServiceAddOn findFirstOrThrow
   */
  export type ServiceAddOnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOn to fetch.
     */
    where?: ServiceAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOns to fetch.
     */
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAddOns.
     */
    cursor?: ServiceAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAddOns.
     */
    distinct?: ServiceAddOnScalarFieldEnum | ServiceAddOnScalarFieldEnum[]
  }

  /**
   * ServiceAddOn findMany
   */
  export type ServiceAddOnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAddOns to fetch.
     */
    where?: ServiceAddOnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAddOns to fetch.
     */
    orderBy?: ServiceAddOnOrderByWithRelationInput | ServiceAddOnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAddOns.
     */
    cursor?: ServiceAddOnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAddOns.
     */
    skip?: number
    distinct?: ServiceAddOnScalarFieldEnum | ServiceAddOnScalarFieldEnum[]
  }

  /**
   * ServiceAddOn create
   */
  export type ServiceAddOnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAddOn.
     */
    data: XOR<ServiceAddOnCreateInput, ServiceAddOnUncheckedCreateInput>
  }

  /**
   * ServiceAddOn createMany
   */
  export type ServiceAddOnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAddOns.
     */
    data: ServiceAddOnCreateManyInput | ServiceAddOnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAddOn createManyAndReturn
   */
  export type ServiceAddOnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceAddOns.
     */
    data: ServiceAddOnCreateManyInput | ServiceAddOnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAddOn update
   */
  export type ServiceAddOnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAddOn.
     */
    data: XOR<ServiceAddOnUpdateInput, ServiceAddOnUncheckedUpdateInput>
    /**
     * Choose, which ServiceAddOn to update.
     */
    where: ServiceAddOnWhereUniqueInput
  }

  /**
   * ServiceAddOn updateMany
   */
  export type ServiceAddOnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAddOns.
     */
    data: XOR<ServiceAddOnUpdateManyMutationInput, ServiceAddOnUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAddOns to update
     */
    where?: ServiceAddOnWhereInput
    /**
     * Limit how many ServiceAddOns to update.
     */
    limit?: number
  }

  /**
   * ServiceAddOn updateManyAndReturn
   */
  export type ServiceAddOnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * The data used to update ServiceAddOns.
     */
    data: XOR<ServiceAddOnUpdateManyMutationInput, ServiceAddOnUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAddOns to update
     */
    where?: ServiceAddOnWhereInput
    /**
     * Limit how many ServiceAddOns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAddOn upsert
   */
  export type ServiceAddOnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAddOn to update in case it exists.
     */
    where: ServiceAddOnWhereUniqueInput
    /**
     * In case the ServiceAddOn found by the `where` argument doesn't exist, create a new ServiceAddOn with this data.
     */
    create: XOR<ServiceAddOnCreateInput, ServiceAddOnUncheckedCreateInput>
    /**
     * In case the ServiceAddOn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAddOnUpdateInput, ServiceAddOnUncheckedUpdateInput>
  }

  /**
   * ServiceAddOn delete
   */
  export type ServiceAddOnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
    /**
     * Filter which ServiceAddOn to delete.
     */
    where: ServiceAddOnWhereUniqueInput
  }

  /**
   * ServiceAddOn deleteMany
   */
  export type ServiceAddOnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAddOns to delete
     */
    where?: ServiceAddOnWhereInput
    /**
     * Limit how many ServiceAddOns to delete.
     */
    limit?: number
  }

  /**
   * ServiceAddOn.bookingServiceItem
   */
  export type ServiceAddOn$bookingServiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingServiceItem
     */
    select?: BookingServiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingServiceItem
     */
    omit?: BookingServiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceItemInclude<ExtArgs> | null
    where?: BookingServiceItemWhereInput
  }

  /**
   * ServiceAddOn.workspaceBooking
   */
  export type ServiceAddOn$workspaceBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceBooking
     */
    select?: WorkspaceBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceBooking
     */
    omit?: WorkspaceBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceBookingInclude<ExtArgs> | null
    where?: WorkspaceBookingWhereInput
  }

  /**
   * ServiceAddOn without action
   */
  export type ServiceAddOnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAddOn
     */
    select?: ServiceAddOnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAddOn
     */
    omit?: ServiceAddOnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAddOnInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BetterAuthUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BetterAuthUserScalarFieldEnum = (typeof BetterAuthUserScalarFieldEnum)[keyof typeof BetterAuthUserScalarFieldEnum]


  export const BetterAuthSessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BetterAuthSessionScalarFieldEnum = (typeof BetterAuthSessionScalarFieldEnum)[keyof typeof BetterAuthSessionScalarFieldEnum]


  export const BetterAuthAccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BetterAuthAccountScalarFieldEnum = (typeof BetterAuthAccountScalarFieldEnum)[keyof typeof BetterAuthAccountScalarFieldEnum]


  export const BetterAuthVerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type BetterAuthVerificationScalarFieldEnum = (typeof BetterAuthVerificationScalarFieldEnum)[keyof typeof BetterAuthVerificationScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const IkohzaScalarFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    code: 'code',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    leaderName: 'leaderName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IkohzaScalarFieldEnum = (typeof IkohzaScalarFieldEnum)[keyof typeof IkohzaScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    legalName: 'legalName',
    regNo: 'regNo',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyBranchScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    postcode: 'postcode',
    country: 'country',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyBranchScalarFieldEnum = (typeof CompanyBranchScalarFieldEnum)[keyof typeof CompanyBranchScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImageUrl: 'profileImageUrl',
    phone: 'phone',
    userType: 'userType',
    status: 'status',
    academicType: 'academicType',
    userIdentifier: 'userIdentifier',
    supervisorName: 'supervisorName',
    facultyId: 'facultyId',
    departmentId: 'departmentId',
    ikohzaId: 'ikohzaId',
    companyId: 'companyId',
    companyBranchId: 'companyBranchId',
    UTM: 'UTM',
    address: 'address',
    email: 'email',
    emailVerifiedAt: 'emailVerifiedAt',
    lastLoginAt: 'lastLoginAt',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    approvedBy: 'approvedBy'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AuthProviderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    passwordHash: 'passwordHash',
    oauthData: 'oauthData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthProviderScalarFieldEnum = (typeof AuthProviderScalarFieldEnum)[keyof typeof AuthProviderScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    category: 'category',
    isActive: 'isActive',
    requiresSample: 'requiresSample',
    minSampleMass: 'minSampleMass',
    operatingHours: 'operatingHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServicePricingScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    userType: 'userType',
    price: 'price',
    unit: 'unit',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicePricingScalarFieldEnum = (typeof ServicePricingScalarFieldEnum)[keyof typeof ServicePricingScalarFieldEnum]


  export const BookingRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    referenceNumber: 'referenceNumber',
    projectDescription: 'projectDescription',
    preferredStartDate: 'preferredStartDate',
    preferredEndDate: 'preferredEndDate',
    totalAmount: 'totalAmount',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    reviewNotes: 'reviewNotes',
    companyId: 'companyId',
    companyBranchId: 'companyBranchId'
  };

  export type BookingRequestScalarFieldEnum = (typeof BookingRequestScalarFieldEnum)[keyof typeof BookingRequestScalarFieldEnum]


  export const BookingServiceItemScalarFieldEnum: {
    id: 'id',
    bookingRequestId: 'bookingRequestId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    durationMonths: 'durationMonths',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    sampleName: 'sampleName',
    sampleDetails: 'sampleDetails',
    sampleType: 'sampleType',
    sampleHazard: 'sampleHazard',
    testingMethod: 'testingMethod',
    degasConditions: 'degasConditions',
    solventSystem: 'solventSystem',
    solvents: 'solvents',
    solventComposition: 'solventComposition',
    columnType: 'columnType',
    flowRate: 'flowRate',
    wavelength: 'wavelength',
    expectedRetentionTime: 'expectedRetentionTime',
    samplePreparation: 'samplePreparation',
    notes: 'notes',
    expectedCompletionDate: 'expectedCompletionDate',
    actualCompletionDate: 'actualCompletionDate',
    turnaroundEstimate: 'turnaroundEstimate',
    hplcPreparationRequired: 'hplcPreparationRequired',
    temperatureControlled: 'temperatureControlled',
    lightSensitive: 'lightSensitive',
    hazardousMaterial: 'hazardousMaterial',
    inertAtmosphere: 'inertAtmosphere',
    otherEquipmentRequests: 'otherEquipmentRequests',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingServiceItemScalarFieldEnum = (typeof BookingServiceItemScalarFieldEnum)[keyof typeof BookingServiceItemScalarFieldEnum]


  export const SampleModificationScalarFieldEnum: {
    id: 'id',
    bookingServiceItemId: 'bookingServiceItemId',
    originalQuantity: 'originalQuantity',
    newQuantity: 'newQuantity',
    originalDurationMonths: 'originalDurationMonths',
    newDurationMonths: 'newDurationMonths',
    originalTotalPrice: 'originalTotalPrice',
    newTotalPrice: 'newTotalPrice',
    reason: 'reason',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    approvedAt: 'approvedAt',
    approvedBy: 'approvedBy'
  };

  export type SampleModificationScalarFieldEnum = (typeof SampleModificationScalarFieldEnum)[keyof typeof SampleModificationScalarFieldEnum]


  export const ServiceFormScalarFieldEnum: {
    id: 'id',
    bookingRequestId: 'bookingRequestId',
    formNumber: 'formNumber',
    costCentre: 'costCentre',
    facilityLab: 'facilityLab',
    staffPicName: 'staffPicName',
    staffPicEmail: 'staffPicEmail',
    staffPicPhone: 'staffPicPhone',
    subtotal: 'subtotal',
    totalAmount: 'totalAmount',
    validUntil: 'validUntil',
    status: 'status',
    serviceFormUnsignedPdfPath: 'serviceFormUnsignedPdfPath',
    serviceFormSignedPdfPath: 'serviceFormSignedPdfPath',
    requiresWorkingAreaAgreement: 'requiresWorkingAreaAgreement',
    workingAreaAgreementUnsignedPdfPath: 'workingAreaAgreementUnsignedPdfPath',
    workingAreaAgreementSignedPdfPath: 'workingAreaAgreementSignedPdfPath',
    generatedAt: 'generatedAt',
    generatedBy: 'generatedBy',
    downloadedAt: 'downloadedAt',
    signedFormsUploadedAt: 'signedFormsUploadedAt',
    signedFormsUploadedBy: 'signedFormsUploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceFormScalarFieldEnum = (typeof ServiceFormScalarFieldEnum)[keyof typeof ServiceFormScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    serviceFormId: 'serviceFormId',
    invoiceNumber: 'invoiceNumber',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    amount: 'amount',
    status: 'status',
    filePath: 'filePath',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    referenceNumber: 'referenceNumber',
    receiptFilePath: 'receiptFilePath',
    status: 'status',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    verifiedAt: 'verifiedAt',
    verifiedBy: 'verifiedBy',
    verificationNotes: 'verificationNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SampleTrackingScalarFieldEnum: {
    id: 'id',
    bookingServiceItemId: 'bookingServiceItemId',
    sampleIdentifier: 'sampleIdentifier',
    status: 'status',
    receivedAt: 'receivedAt',
    analysisStartAt: 'analysisStartAt',
    analysisCompleteAt: 'analysisCompleteAt',
    returnRequestedAt: 'returnRequestedAt',
    returnedAt: 'returnedAt',
    notes: 'notes',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SampleTrackingScalarFieldEnum = (typeof SampleTrackingScalarFieldEnum)[keyof typeof SampleTrackingScalarFieldEnum]


  export const WorkspaceBookingScalarFieldEnum: {
    id: 'id',
    bookingRequestId: 'bookingRequestId',
    startDate: 'startDate',
    endDate: 'endDate',
    preferredTimeSlot: 'preferredTimeSlot',
    specialEquipment: 'specialEquipment',
    purpose: 'purpose',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceBookingScalarFieldEnum = (typeof WorkspaceBookingScalarFieldEnum)[keyof typeof WorkspaceBookingScalarFieldEnum]


  export const LabEquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isAvailable: 'isAvailable',
    maintenanceNotes: 'maintenanceNotes',
    expectedMaintenanceEnd: 'expectedMaintenanceEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabEquipmentScalarFieldEnum = (typeof LabEquipmentScalarFieldEnum)[keyof typeof LabEquipmentScalarFieldEnum]


  export const WorkspaceEquipmentUsageScalarFieldEnum: {
    id: 'id',
    workspaceBookingId: 'workspaceBookingId',
    equipmentId: 'equipmentId',
    createdAt: 'createdAt'
  };

  export type WorkspaceEquipmentUsageScalarFieldEnum = (typeof WorkspaceEquipmentUsageScalarFieldEnum)[keyof typeof WorkspaceEquipmentUsageScalarFieldEnum]


  export const SampleEquipmentUsageScalarFieldEnum: {
    id: 'id',
    bookingServiceItemId: 'bookingServiceItemId',
    equipmentId: 'equipmentId',
    createdAt: 'createdAt'
  };

  export type SampleEquipmentUsageScalarFieldEnum = (typeof SampleEquipmentUsageScalarFieldEnum)[keyof typeof SampleEquipmentUsageScalarFieldEnum]


  export const AnalysisResultScalarFieldEnum: {
    id: 'id',
    sampleTrackingId: 'sampleTrackingId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    fileType: 'fileType',
    description: 'description',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalysisResultScalarFieldEnum = (typeof AnalysisResultScalarFieldEnum)[keyof typeof AnalysisResultScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    relatedEntityType: 'relatedEntityType',
    relatedEntityId: 'relatedEntityId',
    title: 'title',
    message: 'message',
    emailSent: 'emailSent',
    emailSentAt: 'emailSentAt',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const GlobalAddOnCatalogScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    defaultAmount: 'defaultAmount',
    applicableTo: 'applicableTo',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GlobalAddOnCatalogScalarFieldEnum = (typeof GlobalAddOnCatalogScalarFieldEnum)[keyof typeof GlobalAddOnCatalogScalarFieldEnum]


  export const ServiceAddOnMappingScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    addOnId: 'addOnId',
    isEnabled: 'isEnabled',
    customAmount: 'customAmount',
    createdAt: 'createdAt'
  };

  export type ServiceAddOnMappingScalarFieldEnum = (typeof ServiceAddOnMappingScalarFieldEnum)[keyof typeof ServiceAddOnMappingScalarFieldEnum]


  export const ServiceAddOnScalarFieldEnum: {
    id: 'id',
    bookingServiceItemId: 'bookingServiceItemId',
    workspaceBookingId: 'workspaceBookingId',
    addOnCatalogId: 'addOnCatalogId',
    name: 'name',
    amount: 'amount',
    taxable: 'taxable',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ServiceAddOnScalarFieldEnum = (typeof ServiceAddOnScalarFieldEnum)[keyof typeof ServiceAddOnScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'user_type_enum'
   */
  export type Enumuser_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_type_enum'>
    


  /**
   * Reference to a field of type 'user_type_enum[]'
   */
  export type ListEnumuser_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_type_enum[]'>
    


  /**
   * Reference to a field of type 'user_status_enum'
   */
  export type Enumuser_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_status_enum'>
    


  /**
   * Reference to a field of type 'user_status_enum[]'
   */
  export type ListEnumuser_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_status_enum[]'>
    


  /**
   * Reference to a field of type 'academic_type_enum'
   */
  export type Enumacademic_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'academic_type_enum'>
    


  /**
   * Reference to a field of type 'academic_type_enum[]'
   */
  export type ListEnumacademic_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'academic_type_enum[]'>
    


  /**
   * Reference to a field of type 'UTM'
   */
  export type EnumUTMFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UTM'>
    


  /**
   * Reference to a field of type 'UTM[]'
   */
  export type ListEnumUTMFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UTM[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'service_category_enum'
   */
  export type Enumservice_category_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'service_category_enum'>
    


  /**
   * Reference to a field of type 'service_category_enum[]'
   */
  export type ListEnumservice_category_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'service_category_enum[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'booking_status_enum'
   */
  export type Enumbooking_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'booking_status_enum'>
    


  /**
   * Reference to a field of type 'booking_status_enum[]'
   */
  export type ListEnumbooking_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'booking_status_enum[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'modification_status_enum'
   */
  export type Enummodification_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'modification_status_enum'>
    


  /**
   * Reference to a field of type 'modification_status_enum[]'
   */
  export type ListEnummodification_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'modification_status_enum[]'>
    


  /**
   * Reference to a field of type 'form_status_enum'
   */
  export type Enumform_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'form_status_enum'>
    


  /**
   * Reference to a field of type 'form_status_enum[]'
   */
  export type ListEnumform_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'form_status_enum[]'>
    


  /**
   * Reference to a field of type 'invoice_status_enum'
   */
  export type Enuminvoice_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoice_status_enum'>
    


  /**
   * Reference to a field of type 'invoice_status_enum[]'
   */
  export type ListEnuminvoice_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoice_status_enum[]'>
    


  /**
   * Reference to a field of type 'payment_method_enum'
   */
  export type Enumpayment_method_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_method_enum'>
    


  /**
   * Reference to a field of type 'payment_method_enum[]'
   */
  export type ListEnumpayment_method_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_method_enum[]'>
    


  /**
   * Reference to a field of type 'payment_status_enum'
   */
  export type Enumpayment_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status_enum'>
    


  /**
   * Reference to a field of type 'payment_status_enum[]'
   */
  export type ListEnumpayment_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status_enum[]'>
    


  /**
   * Reference to a field of type 'sample_status_enum'
   */
  export type Enumsample_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'sample_status_enum'>
    


  /**
   * Reference to a field of type 'sample_status_enum[]'
   */
  export type ListEnumsample_status_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'sample_status_enum[]'>
    


  /**
   * Reference to a field of type 'notification_type_enum'
   */
  export type Enumnotification_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notification_type_enum'>
    


  /**
   * Reference to a field of type 'notification_type_enum[]'
   */
  export type ListEnumnotification_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notification_type_enum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BetterAuthUserWhereInput = {
    AND?: BetterAuthUserWhereInput | BetterAuthUserWhereInput[]
    OR?: BetterAuthUserWhereInput[]
    NOT?: BetterAuthUserWhereInput | BetterAuthUserWhereInput[]
    id?: UuidFilter<"BetterAuthUser"> | string
    name?: StringNullableFilter<"BetterAuthUser"> | string | null
    email?: StringFilter<"BetterAuthUser"> | string
    emailVerified?: BoolFilter<"BetterAuthUser"> | boolean
    image?: StringNullableFilter<"BetterAuthUser"> | string | null
    createdAt?: DateTimeFilter<"BetterAuthUser"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthUser"> | Date | string
    sessions?: BetterAuthSessionListRelationFilter
    accounts?: BetterAuthAccountListRelationFilter
    verifications?: BetterAuthVerificationListRelationFilter
  }

  export type BetterAuthUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: BetterAuthSessionOrderByRelationAggregateInput
    accounts?: BetterAuthAccountOrderByRelationAggregateInput
    verifications?: BetterAuthVerificationOrderByRelationAggregateInput
  }

  export type BetterAuthUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: BetterAuthUserWhereInput | BetterAuthUserWhereInput[]
    OR?: BetterAuthUserWhereInput[]
    NOT?: BetterAuthUserWhereInput | BetterAuthUserWhereInput[]
    name?: StringNullableFilter<"BetterAuthUser"> | string | null
    emailVerified?: BoolFilter<"BetterAuthUser"> | boolean
    image?: StringNullableFilter<"BetterAuthUser"> | string | null
    createdAt?: DateTimeFilter<"BetterAuthUser"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthUser"> | Date | string
    sessions?: BetterAuthSessionListRelationFilter
    accounts?: BetterAuthAccountListRelationFilter
    verifications?: BetterAuthVerificationListRelationFilter
  }, "id" | "email">

  export type BetterAuthUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BetterAuthUserCountOrderByAggregateInput
    _max?: BetterAuthUserMaxOrderByAggregateInput
    _min?: BetterAuthUserMinOrderByAggregateInput
  }

  export type BetterAuthUserScalarWhereWithAggregatesInput = {
    AND?: BetterAuthUserScalarWhereWithAggregatesInput | BetterAuthUserScalarWhereWithAggregatesInput[]
    OR?: BetterAuthUserScalarWhereWithAggregatesInput[]
    NOT?: BetterAuthUserScalarWhereWithAggregatesInput | BetterAuthUserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BetterAuthUser"> | string
    name?: StringNullableWithAggregatesFilter<"BetterAuthUser"> | string | null
    email?: StringWithAggregatesFilter<"BetterAuthUser"> | string
    emailVerified?: BoolWithAggregatesFilter<"BetterAuthUser"> | boolean
    image?: StringNullableWithAggregatesFilter<"BetterAuthUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BetterAuthUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BetterAuthUser"> | Date | string
  }

  export type BetterAuthSessionWhereInput = {
    AND?: BetterAuthSessionWhereInput | BetterAuthSessionWhereInput[]
    OR?: BetterAuthSessionWhereInput[]
    NOT?: BetterAuthSessionWhereInput | BetterAuthSessionWhereInput[]
    id?: UuidFilter<"BetterAuthSession"> | string
    expiresAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    token?: StringFilter<"BetterAuthSession"> | string
    ipAddress?: StringNullableFilter<"BetterAuthSession"> | string | null
    userAgent?: StringNullableFilter<"BetterAuthSession"> | string | null
    userId?: UuidFilter<"BetterAuthSession"> | string
    createdAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    user?: XOR<BetterAuthUserScalarRelationFilter, BetterAuthUserWhereInput>
  }

  export type BetterAuthSessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: BetterAuthUserOrderByWithRelationInput
  }

  export type BetterAuthSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: BetterAuthSessionWhereInput | BetterAuthSessionWhereInput[]
    OR?: BetterAuthSessionWhereInput[]
    NOT?: BetterAuthSessionWhereInput | BetterAuthSessionWhereInput[]
    expiresAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    ipAddress?: StringNullableFilter<"BetterAuthSession"> | string | null
    userAgent?: StringNullableFilter<"BetterAuthSession"> | string | null
    userId?: UuidFilter<"BetterAuthSession"> | string
    createdAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    user?: XOR<BetterAuthUserScalarRelationFilter, BetterAuthUserWhereInput>
  }, "id" | "token">

  export type BetterAuthSessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BetterAuthSessionCountOrderByAggregateInput
    _max?: BetterAuthSessionMaxOrderByAggregateInput
    _min?: BetterAuthSessionMinOrderByAggregateInput
  }

  export type BetterAuthSessionScalarWhereWithAggregatesInput = {
    AND?: BetterAuthSessionScalarWhereWithAggregatesInput | BetterAuthSessionScalarWhereWithAggregatesInput[]
    OR?: BetterAuthSessionScalarWhereWithAggregatesInput[]
    NOT?: BetterAuthSessionScalarWhereWithAggregatesInput | BetterAuthSessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BetterAuthSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"BetterAuthSession"> | Date | string
    token?: StringWithAggregatesFilter<"BetterAuthSession"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"BetterAuthSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"BetterAuthSession"> | string | null
    userId?: UuidWithAggregatesFilter<"BetterAuthSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BetterAuthSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BetterAuthSession"> | Date | string
  }

  export type BetterAuthAccountWhereInput = {
    AND?: BetterAuthAccountWhereInput | BetterAuthAccountWhereInput[]
    OR?: BetterAuthAccountWhereInput[]
    NOT?: BetterAuthAccountWhereInput | BetterAuthAccountWhereInput[]
    id?: UuidFilter<"BetterAuthAccount"> | string
    accountId?: StringFilter<"BetterAuthAccount"> | string
    providerId?: StringFilter<"BetterAuthAccount"> | string
    userId?: UuidFilter<"BetterAuthAccount"> | string
    accessToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    idToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"BetterAuthAccount"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"BetterAuthAccount"> | Date | string | null
    scope?: StringNullableFilter<"BetterAuthAccount"> | string | null
    password?: StringNullableFilter<"BetterAuthAccount"> | string | null
    createdAt?: DateTimeFilter<"BetterAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthAccount"> | Date | string
    user?: XOR<BetterAuthUserScalarRelationFilter, BetterAuthUserWhereInput>
  }

  export type BetterAuthAccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: BetterAuthUserOrderByWithRelationInput
  }

  export type BetterAuthAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: BetterAuthAccountProviderIdAccountIdCompoundUniqueInput
    AND?: BetterAuthAccountWhereInput | BetterAuthAccountWhereInput[]
    OR?: BetterAuthAccountWhereInput[]
    NOT?: BetterAuthAccountWhereInput | BetterAuthAccountWhereInput[]
    accountId?: StringFilter<"BetterAuthAccount"> | string
    providerId?: StringFilter<"BetterAuthAccount"> | string
    userId?: UuidFilter<"BetterAuthAccount"> | string
    accessToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    idToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"BetterAuthAccount"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"BetterAuthAccount"> | Date | string | null
    scope?: StringNullableFilter<"BetterAuthAccount"> | string | null
    password?: StringNullableFilter<"BetterAuthAccount"> | string | null
    createdAt?: DateTimeFilter<"BetterAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthAccount"> | Date | string
    user?: XOR<BetterAuthUserScalarRelationFilter, BetterAuthUserWhereInput>
  }, "id" | "providerId_accountId">

  export type BetterAuthAccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BetterAuthAccountCountOrderByAggregateInput
    _max?: BetterAuthAccountMaxOrderByAggregateInput
    _min?: BetterAuthAccountMinOrderByAggregateInput
  }

  export type BetterAuthAccountScalarWhereWithAggregatesInput = {
    AND?: BetterAuthAccountScalarWhereWithAggregatesInput | BetterAuthAccountScalarWhereWithAggregatesInput[]
    OR?: BetterAuthAccountScalarWhereWithAggregatesInput[]
    NOT?: BetterAuthAccountScalarWhereWithAggregatesInput | BetterAuthAccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BetterAuthAccount"> | string
    accountId?: StringWithAggregatesFilter<"BetterAuthAccount"> | string
    providerId?: StringWithAggregatesFilter<"BetterAuthAccount"> | string
    userId?: UuidWithAggregatesFilter<"BetterAuthAccount"> | string
    accessToken?: StringNullableWithAggregatesFilter<"BetterAuthAccount"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"BetterAuthAccount"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"BetterAuthAccount"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"BetterAuthAccount"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"BetterAuthAccount"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"BetterAuthAccount"> | string | null
    password?: StringNullableWithAggregatesFilter<"BetterAuthAccount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BetterAuthAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BetterAuthAccount"> | Date | string
  }

  export type BetterAuthVerificationWhereInput = {
    AND?: BetterAuthVerificationWhereInput | BetterAuthVerificationWhereInput[]
    OR?: BetterAuthVerificationWhereInput[]
    NOT?: BetterAuthVerificationWhereInput | BetterAuthVerificationWhereInput[]
    id?: UuidFilter<"BetterAuthVerification"> | string
    identifier?: StringFilter<"BetterAuthVerification"> | string
    value?: StringFilter<"BetterAuthVerification"> | string
    expiresAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    createdAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    userId?: UuidNullableFilter<"BetterAuthVerification"> | string | null
    user?: XOR<BetterAuthUserNullableScalarRelationFilter, BetterAuthUserWhereInput> | null
  }

  export type BetterAuthVerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: BetterAuthUserOrderByWithRelationInput
  }

  export type BetterAuthVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BetterAuthVerificationWhereInput | BetterAuthVerificationWhereInput[]
    OR?: BetterAuthVerificationWhereInput[]
    NOT?: BetterAuthVerificationWhereInput | BetterAuthVerificationWhereInput[]
    identifier?: StringFilter<"BetterAuthVerification"> | string
    value?: StringFilter<"BetterAuthVerification"> | string
    expiresAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    createdAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    userId?: UuidNullableFilter<"BetterAuthVerification"> | string | null
    user?: XOR<BetterAuthUserNullableScalarRelationFilter, BetterAuthUserWhereInput> | null
  }, "id">

  export type BetterAuthVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: BetterAuthVerificationCountOrderByAggregateInput
    _max?: BetterAuthVerificationMaxOrderByAggregateInput
    _min?: BetterAuthVerificationMinOrderByAggregateInput
  }

  export type BetterAuthVerificationScalarWhereWithAggregatesInput = {
    AND?: BetterAuthVerificationScalarWhereWithAggregatesInput | BetterAuthVerificationScalarWhereWithAggregatesInput[]
    OR?: BetterAuthVerificationScalarWhereWithAggregatesInput[]
    NOT?: BetterAuthVerificationScalarWhereWithAggregatesInput | BetterAuthVerificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BetterAuthVerification"> | string
    identifier?: StringWithAggregatesFilter<"BetterAuthVerification"> | string
    value?: StringWithAggregatesFilter<"BetterAuthVerification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"BetterAuthVerification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BetterAuthVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BetterAuthVerification"> | Date | string
    userId?: UuidNullableWithAggregatesFilter<"BetterAuthVerification"> | string | null
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    id?: UuidFilter<"Faculty"> | string
    code?: StringFilter<"Faculty"> | string
    name?: StringFilter<"Faculty"> | string
    isActive?: BoolFilter<"Faculty"> | boolean
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    departments?: DepartmentListRelationFilter
    ikohzas?: IkohzaListRelationFilter
    users?: UserListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    ikohzas?: IkohzaOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    name?: StringFilter<"Faculty"> | string
    isActive?: BoolFilter<"Faculty"> | boolean
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    departments?: DepartmentListRelationFilter
    ikohzas?: IkohzaListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "code">

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Faculty"> | string
    code?: StringWithAggregatesFilter<"Faculty"> | string
    name?: StringWithAggregatesFilter<"Faculty"> | string
    isActive?: BoolWithAggregatesFilter<"Faculty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: UuidFilter<"Department"> | string
    facultyId?: UuidFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    users?: UserListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    faculty?: FacultyOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    facultyId_code?: DepartmentFacultyIdCodeCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    facultyId?: UuidFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    users?: UserListRelationFilter
  }, "id" | "facultyId_code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Department"> | string
    facultyId?: UuidWithAggregatesFilter<"Department"> | string
    code?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type IkohzaWhereInput = {
    AND?: IkohzaWhereInput | IkohzaWhereInput[]
    OR?: IkohzaWhereInput[]
    NOT?: IkohzaWhereInput | IkohzaWhereInput[]
    id?: UuidFilter<"Ikohza"> | string
    facultyId?: UuidFilter<"Ikohza"> | string
    code?: StringFilter<"Ikohza"> | string
    name?: StringFilter<"Ikohza"> | string
    description?: StringNullableFilter<"Ikohza"> | string | null
    isActive?: BoolFilter<"Ikohza"> | boolean
    leaderName?: StringNullableFilter<"Ikohza"> | string | null
    createdAt?: DateTimeFilter<"Ikohza"> | Date | string
    updatedAt?: DateTimeFilter<"Ikohza"> | Date | string
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    users?: UserListRelationFilter
  }

  export type IkohzaOrderByWithRelationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    leaderName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    faculty?: FacultyOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type IkohzaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    facultyId_code?: IkohzaFacultyIdCodeCompoundUniqueInput
    AND?: IkohzaWhereInput | IkohzaWhereInput[]
    OR?: IkohzaWhereInput[]
    NOT?: IkohzaWhereInput | IkohzaWhereInput[]
    facultyId?: UuidFilter<"Ikohza"> | string
    code?: StringFilter<"Ikohza"> | string
    name?: StringFilter<"Ikohza"> | string
    description?: StringNullableFilter<"Ikohza"> | string | null
    isActive?: BoolFilter<"Ikohza"> | boolean
    leaderName?: StringNullableFilter<"Ikohza"> | string | null
    createdAt?: DateTimeFilter<"Ikohza"> | Date | string
    updatedAt?: DateTimeFilter<"Ikohza"> | Date | string
    faculty?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    users?: UserListRelationFilter
  }, "id" | "facultyId_code">

  export type IkohzaOrderByWithAggregationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    leaderName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IkohzaCountOrderByAggregateInput
    _max?: IkohzaMaxOrderByAggregateInput
    _min?: IkohzaMinOrderByAggregateInput
  }

  export type IkohzaScalarWhereWithAggregatesInput = {
    AND?: IkohzaScalarWhereWithAggregatesInput | IkohzaScalarWhereWithAggregatesInput[]
    OR?: IkohzaScalarWhereWithAggregatesInput[]
    NOT?: IkohzaScalarWhereWithAggregatesInput | IkohzaScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Ikohza"> | string
    facultyId?: UuidWithAggregatesFilter<"Ikohza"> | string
    code?: StringWithAggregatesFilter<"Ikohza"> | string
    name?: StringWithAggregatesFilter<"Ikohza"> | string
    description?: StringNullableWithAggregatesFilter<"Ikohza"> | string | null
    isActive?: BoolWithAggregatesFilter<"Ikohza"> | boolean
    leaderName?: StringNullableWithAggregatesFilter<"Ikohza"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ikohza"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ikohza"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: UuidFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    legalName?: StringNullableFilter<"Company"> | string | null
    regNo?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    branches?: CompanyBranchListRelationFilter
    users?: UserListRelationFilter
    bookings?: BookingRequestListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    regNo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branches?: CompanyBranchOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    bookings?: BookingRequestOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    regNo?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    legalName?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    branches?: CompanyBranchListRelationFilter
    users?: UserListRelationFilter
    bookings?: BookingRequestListRelationFilter
  }, "id" | "regNo">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrderInput | SortOrder
    regNo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    legalName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    regNo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type CompanyBranchWhereInput = {
    AND?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    OR?: CompanyBranchWhereInput[]
    NOT?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    id?: UuidFilter<"CompanyBranch"> | string
    companyId?: UuidFilter<"CompanyBranch"> | string
    name?: StringFilter<"CompanyBranch"> | string
    address?: StringNullableFilter<"CompanyBranch"> | string | null
    city?: StringNullableFilter<"CompanyBranch"> | string | null
    state?: StringNullableFilter<"CompanyBranch"> | string | null
    postcode?: StringNullableFilter<"CompanyBranch"> | string | null
    country?: StringNullableFilter<"CompanyBranch"> | string | null
    phone?: StringNullableFilter<"CompanyBranch"> | string | null
    isActive?: BoolFilter<"CompanyBranch"> | boolean
    createdAt?: DateTimeFilter<"CompanyBranch"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyBranch"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    users?: UserListRelationFilter
    bookings?: BookingRequestListRelationFilter
  }

  export type CompanyBranchOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    bookings?: BookingRequestOrderByRelationAggregateInput
  }

  export type CompanyBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_name?: CompanyBranchCompanyIdNameCompoundUniqueInput
    AND?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    OR?: CompanyBranchWhereInput[]
    NOT?: CompanyBranchWhereInput | CompanyBranchWhereInput[]
    companyId?: UuidFilter<"CompanyBranch"> | string
    name?: StringFilter<"CompanyBranch"> | string
    address?: StringNullableFilter<"CompanyBranch"> | string | null
    city?: StringNullableFilter<"CompanyBranch"> | string | null
    state?: StringNullableFilter<"CompanyBranch"> | string | null
    postcode?: StringNullableFilter<"CompanyBranch"> | string | null
    country?: StringNullableFilter<"CompanyBranch"> | string | null
    phone?: StringNullableFilter<"CompanyBranch"> | string | null
    isActive?: BoolFilter<"CompanyBranch"> | boolean
    createdAt?: DateTimeFilter<"CompanyBranch"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyBranch"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    users?: UserListRelationFilter
    bookings?: BookingRequestListRelationFilter
  }, "id" | "companyId_name">

  export type CompanyBranchOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyBranchCountOrderByAggregateInput
    _max?: CompanyBranchMaxOrderByAggregateInput
    _min?: CompanyBranchMinOrderByAggregateInput
  }

  export type CompanyBranchScalarWhereWithAggregatesInput = {
    AND?: CompanyBranchScalarWhereWithAggregatesInput | CompanyBranchScalarWhereWithAggregatesInput[]
    OR?: CompanyBranchScalarWhereWithAggregatesInput[]
    NOT?: CompanyBranchScalarWhereWithAggregatesInput | CompanyBranchScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CompanyBranch"> | string
    companyId?: UuidWithAggregatesFilter<"CompanyBranch"> | string
    name?: StringWithAggregatesFilter<"CompanyBranch"> | string
    address?: StringNullableWithAggregatesFilter<"CompanyBranch"> | string | null
    city?: StringNullableWithAggregatesFilter<"CompanyBranch"> | string | null
    state?: StringNullableWithAggregatesFilter<"CompanyBranch"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"CompanyBranch"> | string | null
    country?: StringNullableWithAggregatesFilter<"CompanyBranch"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CompanyBranch"> | string | null
    isActive?: BoolWithAggregatesFilter<"CompanyBranch"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CompanyBranch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyBranch"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    userType?: Enumuser_type_enumFilter<"User"> | $Enums.user_type_enum
    status?: Enumuser_status_enumFilter<"User"> | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFilter<"User"> | $Enums.academic_type_enum
    userIdentifier?: StringNullableFilter<"User"> | string | null
    supervisorName?: StringNullableFilter<"User"> | string | null
    facultyId?: UuidNullableFilter<"User"> | string | null
    departmentId?: UuidNullableFilter<"User"> | string | null
    ikohzaId?: UuidNullableFilter<"User"> | string | null
    companyId?: UuidNullableFilter<"User"> | string | null
    companyBranchId?: UuidNullableFilter<"User"> | string | null
    UTM?: EnumUTMNullableFilter<"User"> | $Enums.UTM | null
    address?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approvedBy?: UuidNullableFilter<"User"> | string | null
    facultyRelation?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    departmentRelation?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    ikohza?: XOR<IkohzaNullableScalarRelationFilter, IkohzaWhereInput> | null
    companyRelation?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    companyBranch?: XOR<CompanyBranchNullableScalarRelationFilter, CompanyBranchWhereInput> | null
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedUsers?: UserListRelationFilter
    authProviders?: AuthProviderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    bookingRequests?: BookingRequestListRelationFilter
    approvedBookings?: BookingRequestListRelationFilter
    serviceForms?: ServiceFormListRelationFilter
    uploadedInvoices?: InvoiceListRelationFilter
    verifiedPayments?: PaymentListRelationFilter
    uploadedResults?: AnalysisResultListRelationFilter
    notifications?: NotificationListRelationFilter
    sampleTracking?: SampleTrackingListRelationFilter
    createdModifications?: SampleModificationListRelationFilter
    approvedModifications?: SampleModificationListRelationFilter
    uploadedPayments?: PaymentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    userType?: SortOrder
    status?: SortOrder
    academicType?: SortOrder
    userIdentifier?: SortOrderInput | SortOrder
    supervisorName?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    ikohzaId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    companyBranchId?: SortOrderInput | SortOrder
    UTM?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    facultyRelation?: FacultyOrderByWithRelationInput
    departmentRelation?: DepartmentOrderByWithRelationInput
    ikohza?: IkohzaOrderByWithRelationInput
    companyRelation?: CompanyOrderByWithRelationInput
    companyBranch?: CompanyBranchOrderByWithRelationInput
    approvedByUser?: UserOrderByWithRelationInput
    approvedUsers?: UserOrderByRelationAggregateInput
    authProviders?: AuthProviderOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    bookingRequests?: BookingRequestOrderByRelationAggregateInput
    approvedBookings?: BookingRequestOrderByRelationAggregateInput
    serviceForms?: ServiceFormOrderByRelationAggregateInput
    uploadedInvoices?: InvoiceOrderByRelationAggregateInput
    verifiedPayments?: PaymentOrderByRelationAggregateInput
    uploadedResults?: AnalysisResultOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sampleTracking?: SampleTrackingOrderByRelationAggregateInput
    createdModifications?: SampleModificationOrderByRelationAggregateInput
    approvedModifications?: SampleModificationOrderByRelationAggregateInput
    uploadedPayments?: PaymentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    userType?: Enumuser_type_enumFilter<"User"> | $Enums.user_type_enum
    status?: Enumuser_status_enumFilter<"User"> | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFilter<"User"> | $Enums.academic_type_enum
    userIdentifier?: StringNullableFilter<"User"> | string | null
    supervisorName?: StringNullableFilter<"User"> | string | null
    facultyId?: UuidNullableFilter<"User"> | string | null
    departmentId?: UuidNullableFilter<"User"> | string | null
    ikohzaId?: UuidNullableFilter<"User"> | string | null
    companyId?: UuidNullableFilter<"User"> | string | null
    companyBranchId?: UuidNullableFilter<"User"> | string | null
    UTM?: EnumUTMNullableFilter<"User"> | $Enums.UTM | null
    address?: StringNullableFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approvedBy?: UuidNullableFilter<"User"> | string | null
    facultyRelation?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    departmentRelation?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    ikohza?: XOR<IkohzaNullableScalarRelationFilter, IkohzaWhereInput> | null
    companyRelation?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    companyBranch?: XOR<CompanyBranchNullableScalarRelationFilter, CompanyBranchWhereInput> | null
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedUsers?: UserListRelationFilter
    authProviders?: AuthProviderListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    bookingRequests?: BookingRequestListRelationFilter
    approvedBookings?: BookingRequestListRelationFilter
    serviceForms?: ServiceFormListRelationFilter
    uploadedInvoices?: InvoiceListRelationFilter
    verifiedPayments?: PaymentListRelationFilter
    uploadedResults?: AnalysisResultListRelationFilter
    notifications?: NotificationListRelationFilter
    sampleTracking?: SampleTrackingListRelationFilter
    createdModifications?: SampleModificationListRelationFilter
    approvedModifications?: SampleModificationListRelationFilter
    uploadedPayments?: PaymentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    userType?: SortOrder
    status?: SortOrder
    academicType?: SortOrder
    userIdentifier?: SortOrderInput | SortOrder
    supervisorName?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    ikohzaId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    companyBranchId?: SortOrderInput | SortOrder
    UTM?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    profileImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    userType?: Enumuser_type_enumWithAggregatesFilter<"User"> | $Enums.user_type_enum
    status?: Enumuser_status_enumWithAggregatesFilter<"User"> | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumWithAggregatesFilter<"User"> | $Enums.academic_type_enum
    userIdentifier?: StringNullableWithAggregatesFilter<"User"> | string | null
    supervisorName?: StringNullableWithAggregatesFilter<"User"> | string | null
    facultyId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    departmentId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    ikohzaId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    companyId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    companyBranchId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    UTM?: EnumUTMNullableWithAggregatesFilter<"User"> | $Enums.UTM | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    approvedBy?: UuidNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AuthProviderWhereInput = {
    AND?: AuthProviderWhereInput | AuthProviderWhereInput[]
    OR?: AuthProviderWhereInput[]
    NOT?: AuthProviderWhereInput | AuthProviderWhereInput[]
    id?: UuidFilter<"AuthProvider"> | string
    userId?: UuidFilter<"AuthProvider"> | string
    provider?: StringFilter<"AuthProvider"> | string
    providerAccountId?: StringFilter<"AuthProvider"> | string
    passwordHash?: StringNullableFilter<"AuthProvider"> | string | null
    oauthData?: JsonNullableFilter<"AuthProvider">
    createdAt?: DateTimeFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthProviderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    oauthData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AuthProviderProviderProviderAccountIdCompoundUniqueInput
    AND?: AuthProviderWhereInput | AuthProviderWhereInput[]
    OR?: AuthProviderWhereInput[]
    NOT?: AuthProviderWhereInput | AuthProviderWhereInput[]
    userId?: UuidFilter<"AuthProvider"> | string
    provider?: StringFilter<"AuthProvider"> | string
    providerAccountId?: StringFilter<"AuthProvider"> | string
    passwordHash?: StringNullableFilter<"AuthProvider"> | string | null
    oauthData?: JsonNullableFilter<"AuthProvider">
    createdAt?: DateTimeFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AuthProviderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    oauthData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthProviderCountOrderByAggregateInput
    _max?: AuthProviderMaxOrderByAggregateInput
    _min?: AuthProviderMinOrderByAggregateInput
  }

  export type AuthProviderScalarWhereWithAggregatesInput = {
    AND?: AuthProviderScalarWhereWithAggregatesInput | AuthProviderScalarWhereWithAggregatesInput[]
    OR?: AuthProviderScalarWhereWithAggregatesInput[]
    NOT?: AuthProviderScalarWhereWithAggregatesInput | AuthProviderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuthProvider"> | string
    userId?: UuidWithAggregatesFilter<"AuthProvider"> | string
    provider?: StringWithAggregatesFilter<"AuthProvider"> | string
    providerAccountId?: StringWithAggregatesFilter<"AuthProvider"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"AuthProvider"> | string | null
    oauthData?: JsonNullableWithAggregatesFilter<"AuthProvider">
    createdAt?: DateTimeWithAggregatesFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthProvider"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: UuidFilter<"Service"> | string
    code?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    category?: Enumservice_category_enumFilter<"Service"> | $Enums.service_category_enum
    isActive?: BoolFilter<"Service"> | boolean
    requiresSample?: BoolFilter<"Service"> | boolean
    minSampleMass?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    operatingHours?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    pricing?: ServicePricingListRelationFilter
    bookingItems?: BookingServiceItemListRelationFilter
    addOnMappings?: ServiceAddOnMappingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresSample?: SortOrder
    minSampleMass?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pricing?: ServicePricingOrderByRelationAggregateInput
    bookingItems?: BookingServiceItemOrderByRelationAggregateInput
    addOnMappings?: ServiceAddOnMappingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    category?: Enumservice_category_enumFilter<"Service"> | $Enums.service_category_enum
    isActive?: BoolFilter<"Service"> | boolean
    requiresSample?: BoolFilter<"Service"> | boolean
    minSampleMass?: DecimalNullableFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    operatingHours?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    pricing?: ServicePricingListRelationFilter
    bookingItems?: BookingServiceItemListRelationFilter
    addOnMappings?: ServiceAddOnMappingListRelationFilter
  }, "id" | "code">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresSample?: SortOrder
    minSampleMass?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Service"> | string
    code?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    category?: Enumservice_category_enumWithAggregatesFilter<"Service"> | $Enums.service_category_enum
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    requiresSample?: BoolWithAggregatesFilter<"Service"> | boolean
    minSampleMass?: DecimalNullableWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string | null
    operatingHours?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServicePricingWhereInput = {
    AND?: ServicePricingWhereInput | ServicePricingWhereInput[]
    OR?: ServicePricingWhereInput[]
    NOT?: ServicePricingWhereInput | ServicePricingWhereInput[]
    id?: UuidFilter<"ServicePricing"> | string
    serviceId?: UuidFilter<"ServicePricing"> | string
    userType?: Enumuser_type_enumFilter<"ServicePricing"> | $Enums.user_type_enum
    price?: DecimalFilter<"ServicePricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"ServicePricing"> | string
    effectiveFrom?: DateTimeFilter<"ServicePricing"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"ServicePricing"> | Date | string | null
    createdAt?: DateTimeFilter<"ServicePricing"> | Date | string
    updatedAt?: DateTimeFilter<"ServicePricing"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ServicePricingOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userType?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServicePricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicePricingWhereInput | ServicePricingWhereInput[]
    OR?: ServicePricingWhereInput[]
    NOT?: ServicePricingWhereInput | ServicePricingWhereInput[]
    serviceId?: UuidFilter<"ServicePricing"> | string
    userType?: Enumuser_type_enumFilter<"ServicePricing"> | $Enums.user_type_enum
    price?: DecimalFilter<"ServicePricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"ServicePricing"> | string
    effectiveFrom?: DateTimeFilter<"ServicePricing"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"ServicePricing"> | Date | string | null
    createdAt?: DateTimeFilter<"ServicePricing"> | Date | string
    updatedAt?: DateTimeFilter<"ServicePricing"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type ServicePricingOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userType?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicePricingCountOrderByAggregateInput
    _avg?: ServicePricingAvgOrderByAggregateInput
    _max?: ServicePricingMaxOrderByAggregateInput
    _min?: ServicePricingMinOrderByAggregateInput
    _sum?: ServicePricingSumOrderByAggregateInput
  }

  export type ServicePricingScalarWhereWithAggregatesInput = {
    AND?: ServicePricingScalarWhereWithAggregatesInput | ServicePricingScalarWhereWithAggregatesInput[]
    OR?: ServicePricingScalarWhereWithAggregatesInput[]
    NOT?: ServicePricingScalarWhereWithAggregatesInput | ServicePricingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServicePricing"> | string
    serviceId?: UuidWithAggregatesFilter<"ServicePricing"> | string
    userType?: Enumuser_type_enumWithAggregatesFilter<"ServicePricing"> | $Enums.user_type_enum
    price?: DecimalWithAggregatesFilter<"ServicePricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"ServicePricing"> | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"ServicePricing"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"ServicePricing"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServicePricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicePricing"> | Date | string
  }

  export type BookingRequestWhereInput = {
    AND?: BookingRequestWhereInput | BookingRequestWhereInput[]
    OR?: BookingRequestWhereInput[]
    NOT?: BookingRequestWhereInput | BookingRequestWhereInput[]
    id?: UuidFilter<"BookingRequest"> | string
    userId?: UuidFilter<"BookingRequest"> | string
    referenceNumber?: StringFilter<"BookingRequest"> | string
    projectDescription?: StringNullableFilter<"BookingRequest"> | string | null
    preferredStartDate?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    preferredEndDate?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    totalAmount?: DecimalFilter<"BookingRequest"> | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFilter<"BookingRequest"> | $Enums.booking_status_enum
    notes?: StringNullableFilter<"BookingRequest"> | string | null
    createdAt?: DateTimeFilter<"BookingRequest"> | Date | string
    updatedAt?: DateTimeFilter<"BookingRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    reviewedBy?: UuidNullableFilter<"BookingRequest"> | string | null
    reviewNotes?: StringNullableFilter<"BookingRequest"> | string | null
    companyId?: UuidNullableFilter<"BookingRequest"> | string | null
    companyBranchId?: UuidNullableFilter<"BookingRequest"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    companyRelation?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    companyBranch?: XOR<CompanyBranchNullableScalarRelationFilter, CompanyBranchWhereInput> | null
    serviceItems?: BookingServiceItemListRelationFilter
    workspaceBookings?: WorkspaceBookingListRelationFilter
    serviceForms?: ServiceFormListRelationFilter
  }

  export type BookingRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceNumber?: SortOrder
    projectDescription?: SortOrderInput | SortOrder
    preferredStartDate?: SortOrderInput | SortOrder
    preferredEndDate?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    companyBranchId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    reviewedByUser?: UserOrderByWithRelationInput
    companyRelation?: CompanyOrderByWithRelationInput
    companyBranch?: CompanyBranchOrderByWithRelationInput
    serviceItems?: BookingServiceItemOrderByRelationAggregateInput
    workspaceBookings?: WorkspaceBookingOrderByRelationAggregateInput
    serviceForms?: ServiceFormOrderByRelationAggregateInput
  }

  export type BookingRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: BookingRequestWhereInput | BookingRequestWhereInput[]
    OR?: BookingRequestWhereInput[]
    NOT?: BookingRequestWhereInput | BookingRequestWhereInput[]
    userId?: UuidFilter<"BookingRequest"> | string
    projectDescription?: StringNullableFilter<"BookingRequest"> | string | null
    preferredStartDate?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    preferredEndDate?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    totalAmount?: DecimalFilter<"BookingRequest"> | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFilter<"BookingRequest"> | $Enums.booking_status_enum
    notes?: StringNullableFilter<"BookingRequest"> | string | null
    createdAt?: DateTimeFilter<"BookingRequest"> | Date | string
    updatedAt?: DateTimeFilter<"BookingRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    reviewedBy?: UuidNullableFilter<"BookingRequest"> | string | null
    reviewNotes?: StringNullableFilter<"BookingRequest"> | string | null
    companyId?: UuidNullableFilter<"BookingRequest"> | string | null
    companyBranchId?: UuidNullableFilter<"BookingRequest"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    companyRelation?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    companyBranch?: XOR<CompanyBranchNullableScalarRelationFilter, CompanyBranchWhereInput> | null
    serviceItems?: BookingServiceItemListRelationFilter
    workspaceBookings?: WorkspaceBookingListRelationFilter
    serviceForms?: ServiceFormListRelationFilter
  }, "id" | "referenceNumber">

  export type BookingRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceNumber?: SortOrder
    projectDescription?: SortOrderInput | SortOrder
    preferredStartDate?: SortOrderInput | SortOrder
    preferredEndDate?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    companyBranchId?: SortOrderInput | SortOrder
    _count?: BookingRequestCountOrderByAggregateInput
    _avg?: BookingRequestAvgOrderByAggregateInput
    _max?: BookingRequestMaxOrderByAggregateInput
    _min?: BookingRequestMinOrderByAggregateInput
    _sum?: BookingRequestSumOrderByAggregateInput
  }

  export type BookingRequestScalarWhereWithAggregatesInput = {
    AND?: BookingRequestScalarWhereWithAggregatesInput | BookingRequestScalarWhereWithAggregatesInput[]
    OR?: BookingRequestScalarWhereWithAggregatesInput[]
    NOT?: BookingRequestScalarWhereWithAggregatesInput | BookingRequestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BookingRequest"> | string
    userId?: UuidWithAggregatesFilter<"BookingRequest"> | string
    referenceNumber?: StringWithAggregatesFilter<"BookingRequest"> | string
    projectDescription?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
    preferredStartDate?: DateTimeNullableWithAggregatesFilter<"BookingRequest"> | Date | string | null
    preferredEndDate?: DateTimeNullableWithAggregatesFilter<"BookingRequest"> | Date | string | null
    totalAmount?: DecimalWithAggregatesFilter<"BookingRequest"> | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumWithAggregatesFilter<"BookingRequest"> | $Enums.booking_status_enum
    notes?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BookingRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingRequest"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"BookingRequest"> | Date | string | null
    reviewedBy?: UuidNullableWithAggregatesFilter<"BookingRequest"> | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
    companyId?: UuidNullableWithAggregatesFilter<"BookingRequest"> | string | null
    companyBranchId?: UuidNullableWithAggregatesFilter<"BookingRequest"> | string | null
  }

  export type BookingServiceItemWhereInput = {
    AND?: BookingServiceItemWhereInput | BookingServiceItemWhereInput[]
    OR?: BookingServiceItemWhereInput[]
    NOT?: BookingServiceItemWhereInput | BookingServiceItemWhereInput[]
    id?: UuidFilter<"BookingServiceItem"> | string
    bookingRequestId?: UuidFilter<"BookingServiceItem"> | string
    serviceId?: UuidFilter<"BookingServiceItem"> | string
    quantity?: IntFilter<"BookingServiceItem"> | number
    durationMonths?: IntFilter<"BookingServiceItem"> | number
    unitPrice?: DecimalFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    sampleName?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleDetails?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleType?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleHazard?: StringNullableFilter<"BookingServiceItem"> | string | null
    testingMethod?: StringNullableFilter<"BookingServiceItem"> | string | null
    degasConditions?: StringNullableFilter<"BookingServiceItem"> | string | null
    solventSystem?: StringNullableFilter<"BookingServiceItem"> | string | null
    solvents?: StringNullableFilter<"BookingServiceItem"> | string | null
    solventComposition?: StringNullableFilter<"BookingServiceItem"> | string | null
    columnType?: StringNullableFilter<"BookingServiceItem"> | string | null
    flowRate?: DecimalNullableFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    wavelength?: IntNullableFilter<"BookingServiceItem"> | number | null
    expectedRetentionTime?: DecimalNullableFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: StringNullableFilter<"BookingServiceItem"> | string | null
    notes?: StringNullableFilter<"BookingServiceItem"> | string | null
    expectedCompletionDate?: DateTimeNullableFilter<"BookingServiceItem"> | Date | string | null
    actualCompletionDate?: DateTimeNullableFilter<"BookingServiceItem"> | Date | string | null
    turnaroundEstimate?: StringNullableFilter<"BookingServiceItem"> | string | null
    hplcPreparationRequired?: BoolFilter<"BookingServiceItem"> | boolean
    temperatureControlled?: BoolFilter<"BookingServiceItem"> | boolean
    lightSensitive?: BoolFilter<"BookingServiceItem"> | boolean
    hazardousMaterial?: BoolFilter<"BookingServiceItem"> | boolean
    inertAtmosphere?: BoolFilter<"BookingServiceItem"> | boolean
    otherEquipmentRequests?: JsonNullableFilter<"BookingServiceItem">
    createdAt?: DateTimeFilter<"BookingServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"BookingServiceItem"> | Date | string
    bookingRequest?: XOR<BookingRequestScalarRelationFilter, BookingRequestWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    equipmentUsages?: SampleEquipmentUsageListRelationFilter
    modifications?: SampleModificationListRelationFilter
    sampleTracking?: SampleTrackingListRelationFilter
    serviceAddOns?: ServiceAddOnListRelationFilter
  }

  export type BookingServiceItemOrderByWithRelationInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sampleName?: SortOrderInput | SortOrder
    sampleDetails?: SortOrderInput | SortOrder
    sampleType?: SortOrderInput | SortOrder
    sampleHazard?: SortOrderInput | SortOrder
    testingMethod?: SortOrderInput | SortOrder
    degasConditions?: SortOrderInput | SortOrder
    solventSystem?: SortOrderInput | SortOrder
    solvents?: SortOrderInput | SortOrder
    solventComposition?: SortOrderInput | SortOrder
    columnType?: SortOrderInput | SortOrder
    flowRate?: SortOrderInput | SortOrder
    wavelength?: SortOrderInput | SortOrder
    expectedRetentionTime?: SortOrderInput | SortOrder
    samplePreparation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    expectedCompletionDate?: SortOrderInput | SortOrder
    actualCompletionDate?: SortOrderInput | SortOrder
    turnaroundEstimate?: SortOrderInput | SortOrder
    hplcPreparationRequired?: SortOrder
    temperatureControlled?: SortOrder
    lightSensitive?: SortOrder
    hazardousMaterial?: SortOrder
    inertAtmosphere?: SortOrder
    otherEquipmentRequests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingRequest?: BookingRequestOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    equipmentUsages?: SampleEquipmentUsageOrderByRelationAggregateInput
    modifications?: SampleModificationOrderByRelationAggregateInput
    sampleTracking?: SampleTrackingOrderByRelationAggregateInput
    serviceAddOns?: ServiceAddOnOrderByRelationAggregateInput
  }

  export type BookingServiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingServiceItemWhereInput | BookingServiceItemWhereInput[]
    OR?: BookingServiceItemWhereInput[]
    NOT?: BookingServiceItemWhereInput | BookingServiceItemWhereInput[]
    bookingRequestId?: UuidFilter<"BookingServiceItem"> | string
    serviceId?: UuidFilter<"BookingServiceItem"> | string
    quantity?: IntFilter<"BookingServiceItem"> | number
    durationMonths?: IntFilter<"BookingServiceItem"> | number
    unitPrice?: DecimalFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    sampleName?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleDetails?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleType?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleHazard?: StringNullableFilter<"BookingServiceItem"> | string | null
    testingMethod?: StringNullableFilter<"BookingServiceItem"> | string | null
    degasConditions?: StringNullableFilter<"BookingServiceItem"> | string | null
    solventSystem?: StringNullableFilter<"BookingServiceItem"> | string | null
    solvents?: StringNullableFilter<"BookingServiceItem"> | string | null
    solventComposition?: StringNullableFilter<"BookingServiceItem"> | string | null
    columnType?: StringNullableFilter<"BookingServiceItem"> | string | null
    flowRate?: DecimalNullableFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    wavelength?: IntNullableFilter<"BookingServiceItem"> | number | null
    expectedRetentionTime?: DecimalNullableFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: StringNullableFilter<"BookingServiceItem"> | string | null
    notes?: StringNullableFilter<"BookingServiceItem"> | string | null
    expectedCompletionDate?: DateTimeNullableFilter<"BookingServiceItem"> | Date | string | null
    actualCompletionDate?: DateTimeNullableFilter<"BookingServiceItem"> | Date | string | null
    turnaroundEstimate?: StringNullableFilter<"BookingServiceItem"> | string | null
    hplcPreparationRequired?: BoolFilter<"BookingServiceItem"> | boolean
    temperatureControlled?: BoolFilter<"BookingServiceItem"> | boolean
    lightSensitive?: BoolFilter<"BookingServiceItem"> | boolean
    hazardousMaterial?: BoolFilter<"BookingServiceItem"> | boolean
    inertAtmosphere?: BoolFilter<"BookingServiceItem"> | boolean
    otherEquipmentRequests?: JsonNullableFilter<"BookingServiceItem">
    createdAt?: DateTimeFilter<"BookingServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"BookingServiceItem"> | Date | string
    bookingRequest?: XOR<BookingRequestScalarRelationFilter, BookingRequestWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    equipmentUsages?: SampleEquipmentUsageListRelationFilter
    modifications?: SampleModificationListRelationFilter
    sampleTracking?: SampleTrackingListRelationFilter
    serviceAddOns?: ServiceAddOnListRelationFilter
  }, "id">

  export type BookingServiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sampleName?: SortOrderInput | SortOrder
    sampleDetails?: SortOrderInput | SortOrder
    sampleType?: SortOrderInput | SortOrder
    sampleHazard?: SortOrderInput | SortOrder
    testingMethod?: SortOrderInput | SortOrder
    degasConditions?: SortOrderInput | SortOrder
    solventSystem?: SortOrderInput | SortOrder
    solvents?: SortOrderInput | SortOrder
    solventComposition?: SortOrderInput | SortOrder
    columnType?: SortOrderInput | SortOrder
    flowRate?: SortOrderInput | SortOrder
    wavelength?: SortOrderInput | SortOrder
    expectedRetentionTime?: SortOrderInput | SortOrder
    samplePreparation?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    expectedCompletionDate?: SortOrderInput | SortOrder
    actualCompletionDate?: SortOrderInput | SortOrder
    turnaroundEstimate?: SortOrderInput | SortOrder
    hplcPreparationRequired?: SortOrder
    temperatureControlled?: SortOrder
    lightSensitive?: SortOrder
    hazardousMaterial?: SortOrder
    inertAtmosphere?: SortOrder
    otherEquipmentRequests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingServiceItemCountOrderByAggregateInput
    _avg?: BookingServiceItemAvgOrderByAggregateInput
    _max?: BookingServiceItemMaxOrderByAggregateInput
    _min?: BookingServiceItemMinOrderByAggregateInput
    _sum?: BookingServiceItemSumOrderByAggregateInput
  }

  export type BookingServiceItemScalarWhereWithAggregatesInput = {
    AND?: BookingServiceItemScalarWhereWithAggregatesInput | BookingServiceItemScalarWhereWithAggregatesInput[]
    OR?: BookingServiceItemScalarWhereWithAggregatesInput[]
    NOT?: BookingServiceItemScalarWhereWithAggregatesInput | BookingServiceItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BookingServiceItem"> | string
    bookingRequestId?: UuidWithAggregatesFilter<"BookingServiceItem"> | string
    serviceId?: UuidWithAggregatesFilter<"BookingServiceItem"> | string
    quantity?: IntWithAggregatesFilter<"BookingServiceItem"> | number
    durationMonths?: IntWithAggregatesFilter<"BookingServiceItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    sampleName?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    sampleDetails?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    sampleType?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    sampleHazard?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    testingMethod?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    degasConditions?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    solventSystem?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    solvents?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    solventComposition?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    columnType?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    flowRate?: DecimalNullableWithAggregatesFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    wavelength?: IntNullableWithAggregatesFilter<"BookingServiceItem"> | number | null
    expectedRetentionTime?: DecimalNullableWithAggregatesFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    expectedCompletionDate?: DateTimeNullableWithAggregatesFilter<"BookingServiceItem"> | Date | string | null
    actualCompletionDate?: DateTimeNullableWithAggregatesFilter<"BookingServiceItem"> | Date | string | null
    turnaroundEstimate?: StringNullableWithAggregatesFilter<"BookingServiceItem"> | string | null
    hplcPreparationRequired?: BoolWithAggregatesFilter<"BookingServiceItem"> | boolean
    temperatureControlled?: BoolWithAggregatesFilter<"BookingServiceItem"> | boolean
    lightSensitive?: BoolWithAggregatesFilter<"BookingServiceItem"> | boolean
    hazardousMaterial?: BoolWithAggregatesFilter<"BookingServiceItem"> | boolean
    inertAtmosphere?: BoolWithAggregatesFilter<"BookingServiceItem"> | boolean
    otherEquipmentRequests?: JsonNullableWithAggregatesFilter<"BookingServiceItem">
    createdAt?: DateTimeWithAggregatesFilter<"BookingServiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingServiceItem"> | Date | string
  }

  export type SampleModificationWhereInput = {
    AND?: SampleModificationWhereInput | SampleModificationWhereInput[]
    OR?: SampleModificationWhereInput[]
    NOT?: SampleModificationWhereInput | SampleModificationWhereInput[]
    id?: UuidFilter<"SampleModification"> | string
    bookingServiceItemId?: UuidFilter<"SampleModification"> | string
    originalQuantity?: IntFilter<"SampleModification"> | number
    newQuantity?: IntFilter<"SampleModification"> | number
    originalDurationMonths?: IntFilter<"SampleModification"> | number
    newDurationMonths?: IntFilter<"SampleModification"> | number
    originalTotalPrice?: DecimalFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"SampleModification"> | string
    status?: Enummodification_status_enumFilter<"SampleModification"> | $Enums.modification_status_enum
    createdBy?: UuidFilter<"SampleModification"> | string
    createdAt?: DateTimeFilter<"SampleModification"> | Date | string
    approvedAt?: DateTimeNullableFilter<"SampleModification"> | Date | string | null
    approvedBy?: UuidNullableFilter<"SampleModification"> | string | null
    bookingServiceItem?: XOR<BookingServiceItemScalarRelationFilter, BookingServiceItemWhereInput>
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SampleModificationOrderByWithRelationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    bookingServiceItem?: BookingServiceItemOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
    approvedByUser?: UserOrderByWithRelationInput
  }

  export type SampleModificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SampleModificationWhereInput | SampleModificationWhereInput[]
    OR?: SampleModificationWhereInput[]
    NOT?: SampleModificationWhereInput | SampleModificationWhereInput[]
    bookingServiceItemId?: UuidFilter<"SampleModification"> | string
    originalQuantity?: IntFilter<"SampleModification"> | number
    newQuantity?: IntFilter<"SampleModification"> | number
    originalDurationMonths?: IntFilter<"SampleModification"> | number
    newDurationMonths?: IntFilter<"SampleModification"> | number
    originalTotalPrice?: DecimalFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"SampleModification"> | string
    status?: Enummodification_status_enumFilter<"SampleModification"> | $Enums.modification_status_enum
    createdBy?: UuidFilter<"SampleModification"> | string
    createdAt?: DateTimeFilter<"SampleModification"> | Date | string
    approvedAt?: DateTimeNullableFilter<"SampleModification"> | Date | string | null
    approvedBy?: UuidNullableFilter<"SampleModification"> | string | null
    bookingServiceItem?: XOR<BookingServiceItemScalarRelationFilter, BookingServiceItemWhereInput>
    createdByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SampleModificationOrderByWithAggregationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    _count?: SampleModificationCountOrderByAggregateInput
    _avg?: SampleModificationAvgOrderByAggregateInput
    _max?: SampleModificationMaxOrderByAggregateInput
    _min?: SampleModificationMinOrderByAggregateInput
    _sum?: SampleModificationSumOrderByAggregateInput
  }

  export type SampleModificationScalarWhereWithAggregatesInput = {
    AND?: SampleModificationScalarWhereWithAggregatesInput | SampleModificationScalarWhereWithAggregatesInput[]
    OR?: SampleModificationScalarWhereWithAggregatesInput[]
    NOT?: SampleModificationScalarWhereWithAggregatesInput | SampleModificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SampleModification"> | string
    bookingServiceItemId?: UuidWithAggregatesFilter<"SampleModification"> | string
    originalQuantity?: IntWithAggregatesFilter<"SampleModification"> | number
    newQuantity?: IntWithAggregatesFilter<"SampleModification"> | number
    originalDurationMonths?: IntWithAggregatesFilter<"SampleModification"> | number
    newDurationMonths?: IntWithAggregatesFilter<"SampleModification"> | number
    originalTotalPrice?: DecimalWithAggregatesFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalWithAggregatesFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    reason?: StringWithAggregatesFilter<"SampleModification"> | string
    status?: Enummodification_status_enumWithAggregatesFilter<"SampleModification"> | $Enums.modification_status_enum
    createdBy?: UuidWithAggregatesFilter<"SampleModification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SampleModification"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"SampleModification"> | Date | string | null
    approvedBy?: UuidNullableWithAggregatesFilter<"SampleModification"> | string | null
  }

  export type ServiceFormWhereInput = {
    AND?: ServiceFormWhereInput | ServiceFormWhereInput[]
    OR?: ServiceFormWhereInput[]
    NOT?: ServiceFormWhereInput | ServiceFormWhereInput[]
    id?: UuidFilter<"ServiceForm"> | string
    bookingRequestId?: UuidFilter<"ServiceForm"> | string
    formNumber?: StringFilter<"ServiceForm"> | string
    costCentre?: StringNullableFilter<"ServiceForm"> | string | null
    facilityLab?: StringFilter<"ServiceForm"> | string
    staffPicName?: StringNullableFilter<"ServiceForm"> | string | null
    staffPicEmail?: StringNullableFilter<"ServiceForm"> | string | null
    staffPicPhone?: StringNullableFilter<"ServiceForm"> | string | null
    subtotal?: DecimalFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFilter<"ServiceForm"> | Date | string
    status?: Enumform_status_enumFilter<"ServiceForm"> | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFilter<"ServiceForm"> | string
    serviceFormSignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    requiresWorkingAreaAgreement?: BoolFilter<"ServiceForm"> | boolean
    workingAreaAgreementUnsignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    workingAreaAgreementSignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    generatedAt?: DateTimeFilter<"ServiceForm"> | Date | string
    generatedBy?: UuidFilter<"ServiceForm"> | string
    downloadedAt?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedAt?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedBy?: UuidNullableFilter<"ServiceForm"> | string | null
    createdAt?: DateTimeFilter<"ServiceForm"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceForm"> | Date | string
    bookingRequest?: XOR<BookingRequestScalarRelationFilter, BookingRequestWhereInput>
    generatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }

  export type ServiceFormOrderByWithRelationInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    formNumber?: SortOrder
    costCentre?: SortOrderInput | SortOrder
    facilityLab?: SortOrder
    staffPicName?: SortOrderInput | SortOrder
    staffPicEmail?: SortOrderInput | SortOrder
    staffPicPhone?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    serviceFormUnsignedPdfPath?: SortOrder
    serviceFormSignedPdfPath?: SortOrderInput | SortOrder
    requiresWorkingAreaAgreement?: SortOrder
    workingAreaAgreementUnsignedPdfPath?: SortOrderInput | SortOrder
    workingAreaAgreementSignedPdfPath?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    downloadedAt?: SortOrderInput | SortOrder
    signedFormsUploadedAt?: SortOrderInput | SortOrder
    signedFormsUploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingRequest?: BookingRequestOrderByWithRelationInput
    generatedByUser?: UserOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type ServiceFormWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formNumber?: string
    AND?: ServiceFormWhereInput | ServiceFormWhereInput[]
    OR?: ServiceFormWhereInput[]
    NOT?: ServiceFormWhereInput | ServiceFormWhereInput[]
    bookingRequestId?: UuidFilter<"ServiceForm"> | string
    costCentre?: StringNullableFilter<"ServiceForm"> | string | null
    facilityLab?: StringFilter<"ServiceForm"> | string
    staffPicName?: StringNullableFilter<"ServiceForm"> | string | null
    staffPicEmail?: StringNullableFilter<"ServiceForm"> | string | null
    staffPicPhone?: StringNullableFilter<"ServiceForm"> | string | null
    subtotal?: DecimalFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFilter<"ServiceForm"> | Date | string
    status?: Enumform_status_enumFilter<"ServiceForm"> | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFilter<"ServiceForm"> | string
    serviceFormSignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    requiresWorkingAreaAgreement?: BoolFilter<"ServiceForm"> | boolean
    workingAreaAgreementUnsignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    workingAreaAgreementSignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    generatedAt?: DateTimeFilter<"ServiceForm"> | Date | string
    generatedBy?: UuidFilter<"ServiceForm"> | string
    downloadedAt?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedAt?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedBy?: UuidNullableFilter<"ServiceForm"> | string | null
    createdAt?: DateTimeFilter<"ServiceForm"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceForm"> | Date | string
    bookingRequest?: XOR<BookingRequestScalarRelationFilter, BookingRequestWhereInput>
    generatedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
  }, "id" | "formNumber">

  export type ServiceFormOrderByWithAggregationInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    formNumber?: SortOrder
    costCentre?: SortOrderInput | SortOrder
    facilityLab?: SortOrder
    staffPicName?: SortOrderInput | SortOrder
    staffPicEmail?: SortOrderInput | SortOrder
    staffPicPhone?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    serviceFormUnsignedPdfPath?: SortOrder
    serviceFormSignedPdfPath?: SortOrderInput | SortOrder
    requiresWorkingAreaAgreement?: SortOrder
    workingAreaAgreementUnsignedPdfPath?: SortOrderInput | SortOrder
    workingAreaAgreementSignedPdfPath?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    downloadedAt?: SortOrderInput | SortOrder
    signedFormsUploadedAt?: SortOrderInput | SortOrder
    signedFormsUploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceFormCountOrderByAggregateInput
    _avg?: ServiceFormAvgOrderByAggregateInput
    _max?: ServiceFormMaxOrderByAggregateInput
    _min?: ServiceFormMinOrderByAggregateInput
    _sum?: ServiceFormSumOrderByAggregateInput
  }

  export type ServiceFormScalarWhereWithAggregatesInput = {
    AND?: ServiceFormScalarWhereWithAggregatesInput | ServiceFormScalarWhereWithAggregatesInput[]
    OR?: ServiceFormScalarWhereWithAggregatesInput[]
    NOT?: ServiceFormScalarWhereWithAggregatesInput | ServiceFormScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServiceForm"> | string
    bookingRequestId?: UuidWithAggregatesFilter<"ServiceForm"> | string
    formNumber?: StringWithAggregatesFilter<"ServiceForm"> | string
    costCentre?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    facilityLab?: StringWithAggregatesFilter<"ServiceForm"> | string
    staffPicName?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    staffPicEmail?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    staffPicPhone?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeWithAggregatesFilter<"ServiceForm"> | Date | string
    status?: Enumform_status_enumWithAggregatesFilter<"ServiceForm"> | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringWithAggregatesFilter<"ServiceForm"> | string
    serviceFormSignedPdfPath?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    requiresWorkingAreaAgreement?: BoolWithAggregatesFilter<"ServiceForm"> | boolean
    workingAreaAgreementUnsignedPdfPath?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    workingAreaAgreementSignedPdfPath?: StringNullableWithAggregatesFilter<"ServiceForm"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"ServiceForm"> | Date | string
    generatedBy?: UuidWithAggregatesFilter<"ServiceForm"> | string
    downloadedAt?: DateTimeNullableWithAggregatesFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedAt?: DateTimeNullableWithAggregatesFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedBy?: UuidNullableWithAggregatesFilter<"ServiceForm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceForm"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    serviceFormId?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFilter<"Invoice"> | $Enums.invoice_status_enum
    filePath?: StringFilter<"Invoice"> | string
    uploadedBy?: UuidFilter<"Invoice"> | string
    uploadedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    serviceForm?: XOR<ServiceFormScalarRelationFilter, ServiceFormWhereInput>
    uploadedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    serviceFormId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceForm?: ServiceFormOrderByWithRelationInput
    uploadedByUser?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    serviceFormId?: UuidFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFilter<"Invoice"> | $Enums.invoice_status_enum
    filePath?: StringFilter<"Invoice"> | string
    uploadedBy?: UuidFilter<"Invoice"> | string
    uploadedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    serviceForm?: XOR<ServiceFormScalarRelationFilter, ServiceFormWhereInput>
    uploadedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    serviceFormId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    serviceFormId?: UuidWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumWithAggregatesFilter<"Invoice"> | $Enums.invoice_status_enum
    filePath?: StringWithAggregatesFilter<"Invoice"> | string
    uploadedBy?: UuidWithAggregatesFilter<"Invoice"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFilter<"Payment"> | $Enums.payment_method_enum
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    receiptFilePath?: StringFilter<"Payment"> | string
    status?: Enumpayment_status_enumFilter<"Payment"> | $Enums.payment_status_enum
    uploadedBy?: UuidFilter<"Payment"> | string
    uploadedAt?: DateTimeFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verifiedBy?: UuidNullableFilter<"Payment"> | string | null
    verificationNotes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    uploadedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    verifiedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    receiptFilePath?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    uploadedByUser?: UserOrderByWithRelationInput
    verifiedByUser?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFilter<"Payment"> | $Enums.payment_method_enum
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    receiptFilePath?: StringFilter<"Payment"> | string
    status?: Enumpayment_status_enumFilter<"Payment"> | $Enums.payment_status_enum
    uploadedBy?: UuidFilter<"Payment"> | string
    uploadedAt?: DateTimeFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verifiedBy?: UuidNullableFilter<"Payment"> | string | null
    verificationNotes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    uploadedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    verifiedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    receiptFilePath?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    invoiceId?: UuidWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumWithAggregatesFilter<"Payment"> | $Enums.payment_method_enum
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptFilePath?: StringWithAggregatesFilter<"Payment"> | string
    status?: Enumpayment_status_enumWithAggregatesFilter<"Payment"> | $Enums.payment_status_enum
    uploadedBy?: UuidWithAggregatesFilter<"Payment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    verifiedBy?: UuidNullableWithAggregatesFilter<"Payment"> | string | null
    verificationNotes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type SampleTrackingWhereInput = {
    AND?: SampleTrackingWhereInput | SampleTrackingWhereInput[]
    OR?: SampleTrackingWhereInput[]
    NOT?: SampleTrackingWhereInput | SampleTrackingWhereInput[]
    id?: UuidFilter<"SampleTracking"> | string
    bookingServiceItemId?: UuidFilter<"SampleTracking"> | string
    sampleIdentifier?: StringFilter<"SampleTracking"> | string
    status?: Enumsample_status_enumFilter<"SampleTracking"> | $Enums.sample_status_enum
    receivedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    analysisStartAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    analysisCompleteAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    returnRequestedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    notes?: StringNullableFilter<"SampleTracking"> | string | null
    updatedBy?: UuidNullableFilter<"SampleTracking"> | string | null
    createdAt?: DateTimeFilter<"SampleTracking"> | Date | string
    updatedAt?: DateTimeFilter<"SampleTracking"> | Date | string
    bookingServiceItem?: XOR<BookingServiceItemScalarRelationFilter, BookingServiceItemWhereInput>
    updatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    analysisResults?: AnalysisResultListRelationFilter
  }

  export type SampleTrackingOrderByWithRelationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    sampleIdentifier?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    analysisStartAt?: SortOrderInput | SortOrder
    analysisCompleteAt?: SortOrderInput | SortOrder
    returnRequestedAt?: SortOrderInput | SortOrder
    returnedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingServiceItem?: BookingServiceItemOrderByWithRelationInput
    updatedByUser?: UserOrderByWithRelationInput
    analysisResults?: AnalysisResultOrderByRelationAggregateInput
  }

  export type SampleTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SampleTrackingWhereInput | SampleTrackingWhereInput[]
    OR?: SampleTrackingWhereInput[]
    NOT?: SampleTrackingWhereInput | SampleTrackingWhereInput[]
    bookingServiceItemId?: UuidFilter<"SampleTracking"> | string
    sampleIdentifier?: StringFilter<"SampleTracking"> | string
    status?: Enumsample_status_enumFilter<"SampleTracking"> | $Enums.sample_status_enum
    receivedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    analysisStartAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    analysisCompleteAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    returnRequestedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    notes?: StringNullableFilter<"SampleTracking"> | string | null
    updatedBy?: UuidNullableFilter<"SampleTracking"> | string | null
    createdAt?: DateTimeFilter<"SampleTracking"> | Date | string
    updatedAt?: DateTimeFilter<"SampleTracking"> | Date | string
    bookingServiceItem?: XOR<BookingServiceItemScalarRelationFilter, BookingServiceItemWhereInput>
    updatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    analysisResults?: AnalysisResultListRelationFilter
  }, "id">

  export type SampleTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    sampleIdentifier?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    analysisStartAt?: SortOrderInput | SortOrder
    analysisCompleteAt?: SortOrderInput | SortOrder
    returnRequestedAt?: SortOrderInput | SortOrder
    returnedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SampleTrackingCountOrderByAggregateInput
    _max?: SampleTrackingMaxOrderByAggregateInput
    _min?: SampleTrackingMinOrderByAggregateInput
  }

  export type SampleTrackingScalarWhereWithAggregatesInput = {
    AND?: SampleTrackingScalarWhereWithAggregatesInput | SampleTrackingScalarWhereWithAggregatesInput[]
    OR?: SampleTrackingScalarWhereWithAggregatesInput[]
    NOT?: SampleTrackingScalarWhereWithAggregatesInput | SampleTrackingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SampleTracking"> | string
    bookingServiceItemId?: UuidWithAggregatesFilter<"SampleTracking"> | string
    sampleIdentifier?: StringWithAggregatesFilter<"SampleTracking"> | string
    status?: Enumsample_status_enumWithAggregatesFilter<"SampleTracking"> | $Enums.sample_status_enum
    receivedAt?: DateTimeNullableWithAggregatesFilter<"SampleTracking"> | Date | string | null
    analysisStartAt?: DateTimeNullableWithAggregatesFilter<"SampleTracking"> | Date | string | null
    analysisCompleteAt?: DateTimeNullableWithAggregatesFilter<"SampleTracking"> | Date | string | null
    returnRequestedAt?: DateTimeNullableWithAggregatesFilter<"SampleTracking"> | Date | string | null
    returnedAt?: DateTimeNullableWithAggregatesFilter<"SampleTracking"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"SampleTracking"> | string | null
    updatedBy?: UuidNullableWithAggregatesFilter<"SampleTracking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SampleTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SampleTracking"> | Date | string
  }

  export type WorkspaceBookingWhereInput = {
    AND?: WorkspaceBookingWhereInput | WorkspaceBookingWhereInput[]
    OR?: WorkspaceBookingWhereInput[]
    NOT?: WorkspaceBookingWhereInput | WorkspaceBookingWhereInput[]
    id?: UuidFilter<"WorkspaceBooking"> | string
    bookingRequestId?: UuidFilter<"WorkspaceBooking"> | string
    startDate?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    endDate?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    preferredTimeSlot?: StringNullableFilter<"WorkspaceBooking"> | string | null
    specialEquipment?: JsonNullableFilter<"WorkspaceBooking">
    purpose?: StringNullableFilter<"WorkspaceBooking"> | string | null
    notes?: StringNullableFilter<"WorkspaceBooking"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    bookingRequest?: XOR<BookingRequestScalarRelationFilter, BookingRequestWhereInput>
    equipmentUsages?: WorkspaceEquipmentUsageListRelationFilter
    serviceAddOns?: ServiceAddOnListRelationFilter
  }

  export type WorkspaceBookingOrderByWithRelationInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    preferredTimeSlot?: SortOrderInput | SortOrder
    specialEquipment?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingRequest?: BookingRequestOrderByWithRelationInput
    equipmentUsages?: WorkspaceEquipmentUsageOrderByRelationAggregateInput
    serviceAddOns?: ServiceAddOnOrderByRelationAggregateInput
  }

  export type WorkspaceBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceBookingWhereInput | WorkspaceBookingWhereInput[]
    OR?: WorkspaceBookingWhereInput[]
    NOT?: WorkspaceBookingWhereInput | WorkspaceBookingWhereInput[]
    bookingRequestId?: UuidFilter<"WorkspaceBooking"> | string
    startDate?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    endDate?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    preferredTimeSlot?: StringNullableFilter<"WorkspaceBooking"> | string | null
    specialEquipment?: JsonNullableFilter<"WorkspaceBooking">
    purpose?: StringNullableFilter<"WorkspaceBooking"> | string | null
    notes?: StringNullableFilter<"WorkspaceBooking"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    bookingRequest?: XOR<BookingRequestScalarRelationFilter, BookingRequestWhereInput>
    equipmentUsages?: WorkspaceEquipmentUsageListRelationFilter
    serviceAddOns?: ServiceAddOnListRelationFilter
  }, "id">

  export type WorkspaceBookingOrderByWithAggregationInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    preferredTimeSlot?: SortOrderInput | SortOrder
    specialEquipment?: SortOrderInput | SortOrder
    purpose?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceBookingCountOrderByAggregateInput
    _max?: WorkspaceBookingMaxOrderByAggregateInput
    _min?: WorkspaceBookingMinOrderByAggregateInput
  }

  export type WorkspaceBookingScalarWhereWithAggregatesInput = {
    AND?: WorkspaceBookingScalarWhereWithAggregatesInput | WorkspaceBookingScalarWhereWithAggregatesInput[]
    OR?: WorkspaceBookingScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceBookingScalarWhereWithAggregatesInput | WorkspaceBookingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WorkspaceBooking"> | string
    bookingRequestId?: UuidWithAggregatesFilter<"WorkspaceBooking"> | string
    startDate?: DateTimeWithAggregatesFilter<"WorkspaceBooking"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"WorkspaceBooking"> | Date | string
    preferredTimeSlot?: StringNullableWithAggregatesFilter<"WorkspaceBooking"> | string | null
    specialEquipment?: JsonNullableWithAggregatesFilter<"WorkspaceBooking">
    purpose?: StringNullableWithAggregatesFilter<"WorkspaceBooking"> | string | null
    notes?: StringNullableWithAggregatesFilter<"WorkspaceBooking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceBooking"> | Date | string
  }

  export type LabEquipmentWhereInput = {
    AND?: LabEquipmentWhereInput | LabEquipmentWhereInput[]
    OR?: LabEquipmentWhereInput[]
    NOT?: LabEquipmentWhereInput | LabEquipmentWhereInput[]
    id?: UuidFilter<"LabEquipment"> | string
    name?: StringFilter<"LabEquipment"> | string
    description?: StringNullableFilter<"LabEquipment"> | string | null
    isAvailable?: BoolFilter<"LabEquipment"> | boolean
    maintenanceNotes?: StringNullableFilter<"LabEquipment"> | string | null
    expectedMaintenanceEnd?: DateTimeNullableFilter<"LabEquipment"> | Date | string | null
    createdAt?: DateTimeFilter<"LabEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"LabEquipment"> | Date | string
    workspaceUsages?: WorkspaceEquipmentUsageListRelationFilter
    sampleUsages?: SampleEquipmentUsageListRelationFilter
  }

  export type LabEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    maintenanceNotes?: SortOrderInput | SortOrder
    expectedMaintenanceEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceUsages?: WorkspaceEquipmentUsageOrderByRelationAggregateInput
    sampleUsages?: SampleEquipmentUsageOrderByRelationAggregateInput
  }

  export type LabEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: LabEquipmentWhereInput | LabEquipmentWhereInput[]
    OR?: LabEquipmentWhereInput[]
    NOT?: LabEquipmentWhereInput | LabEquipmentWhereInput[]
    description?: StringNullableFilter<"LabEquipment"> | string | null
    isAvailable?: BoolFilter<"LabEquipment"> | boolean
    maintenanceNotes?: StringNullableFilter<"LabEquipment"> | string | null
    expectedMaintenanceEnd?: DateTimeNullableFilter<"LabEquipment"> | Date | string | null
    createdAt?: DateTimeFilter<"LabEquipment"> | Date | string
    updatedAt?: DateTimeFilter<"LabEquipment"> | Date | string
    workspaceUsages?: WorkspaceEquipmentUsageListRelationFilter
    sampleUsages?: SampleEquipmentUsageListRelationFilter
  }, "id" | "name">

  export type LabEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isAvailable?: SortOrder
    maintenanceNotes?: SortOrderInput | SortOrder
    expectedMaintenanceEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabEquipmentCountOrderByAggregateInput
    _max?: LabEquipmentMaxOrderByAggregateInput
    _min?: LabEquipmentMinOrderByAggregateInput
  }

  export type LabEquipmentScalarWhereWithAggregatesInput = {
    AND?: LabEquipmentScalarWhereWithAggregatesInput | LabEquipmentScalarWhereWithAggregatesInput[]
    OR?: LabEquipmentScalarWhereWithAggregatesInput[]
    NOT?: LabEquipmentScalarWhereWithAggregatesInput | LabEquipmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LabEquipment"> | string
    name?: StringWithAggregatesFilter<"LabEquipment"> | string
    description?: StringNullableWithAggregatesFilter<"LabEquipment"> | string | null
    isAvailable?: BoolWithAggregatesFilter<"LabEquipment"> | boolean
    maintenanceNotes?: StringNullableWithAggregatesFilter<"LabEquipment"> | string | null
    expectedMaintenanceEnd?: DateTimeNullableWithAggregatesFilter<"LabEquipment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LabEquipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabEquipment"> | Date | string
  }

  export type WorkspaceEquipmentUsageWhereInput = {
    AND?: WorkspaceEquipmentUsageWhereInput | WorkspaceEquipmentUsageWhereInput[]
    OR?: WorkspaceEquipmentUsageWhereInput[]
    NOT?: WorkspaceEquipmentUsageWhereInput | WorkspaceEquipmentUsageWhereInput[]
    id?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    workspaceBookingId?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    equipmentId?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    createdAt?: DateTimeFilter<"WorkspaceEquipmentUsage"> | Date | string
    workspaceBooking?: XOR<WorkspaceBookingScalarRelationFilter, WorkspaceBookingWhereInput>
    equipment?: XOR<LabEquipmentScalarRelationFilter, LabEquipmentWhereInput>
  }

  export type WorkspaceEquipmentUsageOrderByWithRelationInput = {
    id?: SortOrder
    workspaceBookingId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    workspaceBooking?: WorkspaceBookingOrderByWithRelationInput
    equipment?: LabEquipmentOrderByWithRelationInput
  }

  export type WorkspaceEquipmentUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceEquipmentUsageWhereInput | WorkspaceEquipmentUsageWhereInput[]
    OR?: WorkspaceEquipmentUsageWhereInput[]
    NOT?: WorkspaceEquipmentUsageWhereInput | WorkspaceEquipmentUsageWhereInput[]
    workspaceBookingId?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    equipmentId?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    createdAt?: DateTimeFilter<"WorkspaceEquipmentUsage"> | Date | string
    workspaceBooking?: XOR<WorkspaceBookingScalarRelationFilter, WorkspaceBookingWhereInput>
    equipment?: XOR<LabEquipmentScalarRelationFilter, LabEquipmentWhereInput>
  }, "id">

  export type WorkspaceEquipmentUsageOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceBookingId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    _count?: WorkspaceEquipmentUsageCountOrderByAggregateInput
    _max?: WorkspaceEquipmentUsageMaxOrderByAggregateInput
    _min?: WorkspaceEquipmentUsageMinOrderByAggregateInput
  }

  export type WorkspaceEquipmentUsageScalarWhereWithAggregatesInput = {
    AND?: WorkspaceEquipmentUsageScalarWhereWithAggregatesInput | WorkspaceEquipmentUsageScalarWhereWithAggregatesInput[]
    OR?: WorkspaceEquipmentUsageScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceEquipmentUsageScalarWhereWithAggregatesInput | WorkspaceEquipmentUsageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WorkspaceEquipmentUsage"> | string
    workspaceBookingId?: UuidWithAggregatesFilter<"WorkspaceEquipmentUsage"> | string
    equipmentId?: UuidWithAggregatesFilter<"WorkspaceEquipmentUsage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceEquipmentUsage"> | Date | string
  }

  export type SampleEquipmentUsageWhereInput = {
    AND?: SampleEquipmentUsageWhereInput | SampleEquipmentUsageWhereInput[]
    OR?: SampleEquipmentUsageWhereInput[]
    NOT?: SampleEquipmentUsageWhereInput | SampleEquipmentUsageWhereInput[]
    id?: UuidFilter<"SampleEquipmentUsage"> | string
    bookingServiceItemId?: UuidFilter<"SampleEquipmentUsage"> | string
    equipmentId?: UuidFilter<"SampleEquipmentUsage"> | string
    createdAt?: DateTimeFilter<"SampleEquipmentUsage"> | Date | string
    bookedItem?: XOR<BookingServiceItemScalarRelationFilter, BookingServiceItemWhereInput>
    equipment?: XOR<LabEquipmentScalarRelationFilter, LabEquipmentWhereInput>
  }

  export type SampleEquipmentUsageOrderByWithRelationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    bookedItem?: BookingServiceItemOrderByWithRelationInput
    equipment?: LabEquipmentOrderByWithRelationInput
  }

  export type SampleEquipmentUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SampleEquipmentUsageWhereInput | SampleEquipmentUsageWhereInput[]
    OR?: SampleEquipmentUsageWhereInput[]
    NOT?: SampleEquipmentUsageWhereInput | SampleEquipmentUsageWhereInput[]
    bookingServiceItemId?: UuidFilter<"SampleEquipmentUsage"> | string
    equipmentId?: UuidFilter<"SampleEquipmentUsage"> | string
    createdAt?: DateTimeFilter<"SampleEquipmentUsage"> | Date | string
    bookedItem?: XOR<BookingServiceItemScalarRelationFilter, BookingServiceItemWhereInput>
    equipment?: XOR<LabEquipmentScalarRelationFilter, LabEquipmentWhereInput>
  }, "id">

  export type SampleEquipmentUsageOrderByWithAggregationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    _count?: SampleEquipmentUsageCountOrderByAggregateInput
    _max?: SampleEquipmentUsageMaxOrderByAggregateInput
    _min?: SampleEquipmentUsageMinOrderByAggregateInput
  }

  export type SampleEquipmentUsageScalarWhereWithAggregatesInput = {
    AND?: SampleEquipmentUsageScalarWhereWithAggregatesInput | SampleEquipmentUsageScalarWhereWithAggregatesInput[]
    OR?: SampleEquipmentUsageScalarWhereWithAggregatesInput[]
    NOT?: SampleEquipmentUsageScalarWhereWithAggregatesInput | SampleEquipmentUsageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SampleEquipmentUsage"> | string
    bookingServiceItemId?: UuidWithAggregatesFilter<"SampleEquipmentUsage"> | string
    equipmentId?: UuidWithAggregatesFilter<"SampleEquipmentUsage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SampleEquipmentUsage"> | Date | string
  }

  export type AnalysisResultWhereInput = {
    AND?: AnalysisResultWhereInput | AnalysisResultWhereInput[]
    OR?: AnalysisResultWhereInput[]
    NOT?: AnalysisResultWhereInput | AnalysisResultWhereInput[]
    id?: UuidFilter<"AnalysisResult"> | string
    sampleTrackingId?: UuidFilter<"AnalysisResult"> | string
    fileName?: StringFilter<"AnalysisResult"> | string
    filePath?: StringFilter<"AnalysisResult"> | string
    fileSize?: IntFilter<"AnalysisResult"> | number
    fileType?: StringFilter<"AnalysisResult"> | string
    description?: StringNullableFilter<"AnalysisResult"> | string | null
    uploadedBy?: UuidFilter<"AnalysisResult"> | string
    uploadedAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    createdAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    sampleTracking?: XOR<SampleTrackingScalarRelationFilter, SampleTrackingWhereInput>
    uploadedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnalysisResultOrderByWithRelationInput = {
    id?: SortOrder
    sampleTrackingId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    description?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sampleTracking?: SampleTrackingOrderByWithRelationInput
    uploadedByUser?: UserOrderByWithRelationInput
  }

  export type AnalysisResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalysisResultWhereInput | AnalysisResultWhereInput[]
    OR?: AnalysisResultWhereInput[]
    NOT?: AnalysisResultWhereInput | AnalysisResultWhereInput[]
    sampleTrackingId?: UuidFilter<"AnalysisResult"> | string
    fileName?: StringFilter<"AnalysisResult"> | string
    filePath?: StringFilter<"AnalysisResult"> | string
    fileSize?: IntFilter<"AnalysisResult"> | number
    fileType?: StringFilter<"AnalysisResult"> | string
    description?: StringNullableFilter<"AnalysisResult"> | string | null
    uploadedBy?: UuidFilter<"AnalysisResult"> | string
    uploadedAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    createdAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    sampleTracking?: XOR<SampleTrackingScalarRelationFilter, SampleTrackingWhereInput>
    uploadedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnalysisResultOrderByWithAggregationInput = {
    id?: SortOrder
    sampleTrackingId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    description?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalysisResultCountOrderByAggregateInput
    _avg?: AnalysisResultAvgOrderByAggregateInput
    _max?: AnalysisResultMaxOrderByAggregateInput
    _min?: AnalysisResultMinOrderByAggregateInput
    _sum?: AnalysisResultSumOrderByAggregateInput
  }

  export type AnalysisResultScalarWhereWithAggregatesInput = {
    AND?: AnalysisResultScalarWhereWithAggregatesInput | AnalysisResultScalarWhereWithAggregatesInput[]
    OR?: AnalysisResultScalarWhereWithAggregatesInput[]
    NOT?: AnalysisResultScalarWhereWithAggregatesInput | AnalysisResultScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AnalysisResult"> | string
    sampleTrackingId?: UuidWithAggregatesFilter<"AnalysisResult"> | string
    fileName?: StringWithAggregatesFilter<"AnalysisResult"> | string
    filePath?: StringWithAggregatesFilter<"AnalysisResult"> | string
    fileSize?: IntWithAggregatesFilter<"AnalysisResult"> | number
    fileType?: StringWithAggregatesFilter<"AnalysisResult"> | string
    description?: StringNullableWithAggregatesFilter<"AnalysisResult"> | string | null
    uploadedBy?: UuidWithAggregatesFilter<"AnalysisResult"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"AnalysisResult"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AnalysisResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalysisResult"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: Enumnotification_type_enumFilter<"Notification"> | $Enums.notification_type_enum
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    emailSent?: BoolFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: UuidFilter<"Notification"> | string
    type?: Enumnotification_type_enumFilter<"Notification"> | $Enums.notification_type_enum
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    emailSent?: BoolFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    relatedEntityType?: SortOrderInput | SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    userId?: UuidWithAggregatesFilter<"Notification"> | string
    type?: Enumnotification_type_enumWithAggregatesFilter<"Notification"> | $Enums.notification_type_enum
    relatedEntityType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedEntityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    emailSent?: BoolWithAggregatesFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type GlobalAddOnCatalogWhereInput = {
    AND?: GlobalAddOnCatalogWhereInput | GlobalAddOnCatalogWhereInput[]
    OR?: GlobalAddOnCatalogWhereInput[]
    NOT?: GlobalAddOnCatalogWhereInput | GlobalAddOnCatalogWhereInput[]
    id?: UuidFilter<"GlobalAddOnCatalog"> | string
    name?: StringFilter<"GlobalAddOnCatalog"> | string
    description?: StringNullableFilter<"GlobalAddOnCatalog"> | string | null
    defaultAmount?: DecimalFilter<"GlobalAddOnCatalog"> | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFilter<"GlobalAddOnCatalog"> | string
    isActive?: BoolFilter<"GlobalAddOnCatalog"> | boolean
    createdAt?: DateTimeFilter<"GlobalAddOnCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalAddOnCatalog"> | Date | string
    serviceMappings?: ServiceAddOnMappingListRelationFilter
    serviceAddOns?: ServiceAddOnListRelationFilter
  }

  export type GlobalAddOnCatalogOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultAmount?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceMappings?: ServiceAddOnMappingOrderByRelationAggregateInput
    serviceAddOns?: ServiceAddOnOrderByRelationAggregateInput
  }

  export type GlobalAddOnCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GlobalAddOnCatalogWhereInput | GlobalAddOnCatalogWhereInput[]
    OR?: GlobalAddOnCatalogWhereInput[]
    NOT?: GlobalAddOnCatalogWhereInput | GlobalAddOnCatalogWhereInput[]
    description?: StringNullableFilter<"GlobalAddOnCatalog"> | string | null
    defaultAmount?: DecimalFilter<"GlobalAddOnCatalog"> | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFilter<"GlobalAddOnCatalog"> | string
    isActive?: BoolFilter<"GlobalAddOnCatalog"> | boolean
    createdAt?: DateTimeFilter<"GlobalAddOnCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalAddOnCatalog"> | Date | string
    serviceMappings?: ServiceAddOnMappingListRelationFilter
    serviceAddOns?: ServiceAddOnListRelationFilter
  }, "id" | "name">

  export type GlobalAddOnCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultAmount?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GlobalAddOnCatalogCountOrderByAggregateInput
    _avg?: GlobalAddOnCatalogAvgOrderByAggregateInput
    _max?: GlobalAddOnCatalogMaxOrderByAggregateInput
    _min?: GlobalAddOnCatalogMinOrderByAggregateInput
    _sum?: GlobalAddOnCatalogSumOrderByAggregateInput
  }

  export type GlobalAddOnCatalogScalarWhereWithAggregatesInput = {
    AND?: GlobalAddOnCatalogScalarWhereWithAggregatesInput | GlobalAddOnCatalogScalarWhereWithAggregatesInput[]
    OR?: GlobalAddOnCatalogScalarWhereWithAggregatesInput[]
    NOT?: GlobalAddOnCatalogScalarWhereWithAggregatesInput | GlobalAddOnCatalogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"GlobalAddOnCatalog"> | string
    name?: StringWithAggregatesFilter<"GlobalAddOnCatalog"> | string
    description?: StringNullableWithAggregatesFilter<"GlobalAddOnCatalog"> | string | null
    defaultAmount?: DecimalWithAggregatesFilter<"GlobalAddOnCatalog"> | Decimal | DecimalJsLike | number | string
    applicableTo?: StringWithAggregatesFilter<"GlobalAddOnCatalog"> | string
    isActive?: BoolWithAggregatesFilter<"GlobalAddOnCatalog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GlobalAddOnCatalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalAddOnCatalog"> | Date | string
  }

  export type ServiceAddOnMappingWhereInput = {
    AND?: ServiceAddOnMappingWhereInput | ServiceAddOnMappingWhereInput[]
    OR?: ServiceAddOnMappingWhereInput[]
    NOT?: ServiceAddOnMappingWhereInput | ServiceAddOnMappingWhereInput[]
    id?: UuidFilter<"ServiceAddOnMapping"> | string
    serviceId?: UuidFilter<"ServiceAddOnMapping"> | string
    addOnId?: UuidFilter<"ServiceAddOnMapping"> | string
    isEnabled?: BoolFilter<"ServiceAddOnMapping"> | boolean
    customAmount?: DecimalNullableFilter<"ServiceAddOnMapping"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ServiceAddOnMapping"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    addOnCatalog?: XOR<GlobalAddOnCatalogScalarRelationFilter, GlobalAddOnCatalogWhereInput>
  }

  export type ServiceAddOnMappingOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    addOnId?: SortOrder
    isEnabled?: SortOrder
    customAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    addOnCatalog?: GlobalAddOnCatalogOrderByWithRelationInput
  }

  export type ServiceAddOnMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serviceId_addOnId?: ServiceAddOnMappingServiceIdAddOnIdCompoundUniqueInput
    AND?: ServiceAddOnMappingWhereInput | ServiceAddOnMappingWhereInput[]
    OR?: ServiceAddOnMappingWhereInput[]
    NOT?: ServiceAddOnMappingWhereInput | ServiceAddOnMappingWhereInput[]
    serviceId?: UuidFilter<"ServiceAddOnMapping"> | string
    addOnId?: UuidFilter<"ServiceAddOnMapping"> | string
    isEnabled?: BoolFilter<"ServiceAddOnMapping"> | boolean
    customAmount?: DecimalNullableFilter<"ServiceAddOnMapping"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ServiceAddOnMapping"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    addOnCatalog?: XOR<GlobalAddOnCatalogScalarRelationFilter, GlobalAddOnCatalogWhereInput>
  }, "id" | "serviceId_addOnId">

  export type ServiceAddOnMappingOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    addOnId?: SortOrder
    isEnabled?: SortOrder
    customAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceAddOnMappingCountOrderByAggregateInput
    _avg?: ServiceAddOnMappingAvgOrderByAggregateInput
    _max?: ServiceAddOnMappingMaxOrderByAggregateInput
    _min?: ServiceAddOnMappingMinOrderByAggregateInput
    _sum?: ServiceAddOnMappingSumOrderByAggregateInput
  }

  export type ServiceAddOnMappingScalarWhereWithAggregatesInput = {
    AND?: ServiceAddOnMappingScalarWhereWithAggregatesInput | ServiceAddOnMappingScalarWhereWithAggregatesInput[]
    OR?: ServiceAddOnMappingScalarWhereWithAggregatesInput[]
    NOT?: ServiceAddOnMappingScalarWhereWithAggregatesInput | ServiceAddOnMappingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServiceAddOnMapping"> | string
    serviceId?: UuidWithAggregatesFilter<"ServiceAddOnMapping"> | string
    addOnId?: UuidWithAggregatesFilter<"ServiceAddOnMapping"> | string
    isEnabled?: BoolWithAggregatesFilter<"ServiceAddOnMapping"> | boolean
    customAmount?: DecimalNullableWithAggregatesFilter<"ServiceAddOnMapping"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceAddOnMapping"> | Date | string
  }

  export type ServiceAddOnWhereInput = {
    AND?: ServiceAddOnWhereInput | ServiceAddOnWhereInput[]
    OR?: ServiceAddOnWhereInput[]
    NOT?: ServiceAddOnWhereInput | ServiceAddOnWhereInput[]
    id?: UuidFilter<"ServiceAddOn"> | string
    bookingServiceItemId?: UuidNullableFilter<"ServiceAddOn"> | string | null
    workspaceBookingId?: UuidNullableFilter<"ServiceAddOn"> | string | null
    addOnCatalogId?: UuidFilter<"ServiceAddOn"> | string
    name?: StringFilter<"ServiceAddOn"> | string
    amount?: DecimalFilter<"ServiceAddOn"> | Decimal | DecimalJsLike | number | string
    taxable?: BoolFilter<"ServiceAddOn"> | boolean
    description?: StringNullableFilter<"ServiceAddOn"> | string | null
    createdAt?: DateTimeFilter<"ServiceAddOn"> | Date | string
    bookingServiceItem?: XOR<BookingServiceItemNullableScalarRelationFilter, BookingServiceItemWhereInput> | null
    workspaceBooking?: XOR<WorkspaceBookingNullableScalarRelationFilter, WorkspaceBookingWhereInput> | null
    addOnCatalog?: XOR<GlobalAddOnCatalogScalarRelationFilter, GlobalAddOnCatalogWhereInput>
  }

  export type ServiceAddOnOrderByWithRelationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrderInput | SortOrder
    workspaceBookingId?: SortOrderInput | SortOrder
    addOnCatalogId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bookingServiceItem?: BookingServiceItemOrderByWithRelationInput
    workspaceBooking?: WorkspaceBookingOrderByWithRelationInput
    addOnCatalog?: GlobalAddOnCatalogOrderByWithRelationInput
  }

  export type ServiceAddOnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceAddOnWhereInput | ServiceAddOnWhereInput[]
    OR?: ServiceAddOnWhereInput[]
    NOT?: ServiceAddOnWhereInput | ServiceAddOnWhereInput[]
    bookingServiceItemId?: UuidNullableFilter<"ServiceAddOn"> | string | null
    workspaceBookingId?: UuidNullableFilter<"ServiceAddOn"> | string | null
    addOnCatalogId?: UuidFilter<"ServiceAddOn"> | string
    name?: StringFilter<"ServiceAddOn"> | string
    amount?: DecimalFilter<"ServiceAddOn"> | Decimal | DecimalJsLike | number | string
    taxable?: BoolFilter<"ServiceAddOn"> | boolean
    description?: StringNullableFilter<"ServiceAddOn"> | string | null
    createdAt?: DateTimeFilter<"ServiceAddOn"> | Date | string
    bookingServiceItem?: XOR<BookingServiceItemNullableScalarRelationFilter, BookingServiceItemWhereInput> | null
    workspaceBooking?: XOR<WorkspaceBookingNullableScalarRelationFilter, WorkspaceBookingWhereInput> | null
    addOnCatalog?: XOR<GlobalAddOnCatalogScalarRelationFilter, GlobalAddOnCatalogWhereInput>
  }, "id">

  export type ServiceAddOnOrderByWithAggregationInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrderInput | SortOrder
    workspaceBookingId?: SortOrderInput | SortOrder
    addOnCatalogId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceAddOnCountOrderByAggregateInput
    _avg?: ServiceAddOnAvgOrderByAggregateInput
    _max?: ServiceAddOnMaxOrderByAggregateInput
    _min?: ServiceAddOnMinOrderByAggregateInput
    _sum?: ServiceAddOnSumOrderByAggregateInput
  }

  export type ServiceAddOnScalarWhereWithAggregatesInput = {
    AND?: ServiceAddOnScalarWhereWithAggregatesInput | ServiceAddOnScalarWhereWithAggregatesInput[]
    OR?: ServiceAddOnScalarWhereWithAggregatesInput[]
    NOT?: ServiceAddOnScalarWhereWithAggregatesInput | ServiceAddOnScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ServiceAddOn"> | string
    bookingServiceItemId?: UuidNullableWithAggregatesFilter<"ServiceAddOn"> | string | null
    workspaceBookingId?: UuidNullableWithAggregatesFilter<"ServiceAddOn"> | string | null
    addOnCatalogId?: UuidWithAggregatesFilter<"ServiceAddOn"> | string
    name?: StringWithAggregatesFilter<"ServiceAddOn"> | string
    amount?: DecimalWithAggregatesFilter<"ServiceAddOn"> | Decimal | DecimalJsLike | number | string
    taxable?: BoolWithAggregatesFilter<"ServiceAddOn"> | boolean
    description?: StringNullableWithAggregatesFilter<"ServiceAddOn"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceAddOn"> | Date | string
  }

  export type BetterAuthUserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: BetterAuthSessionCreateNestedManyWithoutUserInput
    accounts?: BetterAuthAccountCreateNestedManyWithoutUserInput
    verifications?: BetterAuthVerificationCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: BetterAuthSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: BetterAuthAccountUncheckedCreateNestedManyWithoutUserInput
    verifications?: BetterAuthVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BetterAuthSessionUpdateManyWithoutUserNestedInput
    accounts?: BetterAuthAccountUpdateManyWithoutUserNestedInput
    verifications?: BetterAuthVerificationUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BetterAuthSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: BetterAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    verifications?: BetterAuthVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthSessionCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: BetterAuthUserCreateNestedOneWithoutSessionsInput
  }

  export type BetterAuthSessionUncheckedCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BetterAuthUserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type BetterAuthSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthSessionCreateManyInput = {
    id?: string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthAccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: BetterAuthUserCreateNestedOneWithoutAccountsInput
  }

  export type BetterAuthAccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BetterAuthUserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type BetterAuthAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthAccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthVerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: BetterAuthUserCreateNestedOneWithoutVerificationsInput
  }

  export type BetterAuthVerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type BetterAuthVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: BetterAuthUserUpdateOneWithoutVerificationsNestedInput
  }

  export type BetterAuthVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BetterAuthVerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type BetterAuthVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FacultyCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutFacultyInput
    ikohzas?: IkohzaCreateNestedManyWithoutFacultyInput
    users?: UserCreateNestedManyWithoutFacultyRelationInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacultyInput
    ikohzas?: IkohzaUncheckedCreateNestedManyWithoutFacultyInput
    users?: UserUncheckedCreateNestedManyWithoutFacultyRelationInput
  }

  export type FacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutFacultyNestedInput
    ikohzas?: IkohzaUpdateManyWithoutFacultyNestedInput
    users?: UserUpdateManyWithoutFacultyRelationNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutFacultyNestedInput
    ikohzas?: IkohzaUncheckedUpdateManyWithoutFacultyNestedInput
    users?: UserUncheckedUpdateManyWithoutFacultyRelationNestedInput
  }

  export type FacultyCreateManyInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty: FacultyCreateNestedOneWithoutDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentRelationInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    facultyId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentRelationInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyUpdateOneRequiredWithoutDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentRelationNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentRelationNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    facultyId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IkohzaCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty: FacultyCreateNestedOneWithoutIkohzasInput
    users?: UserCreateNestedManyWithoutIkohzaInput
  }

  export type IkohzaUncheckedCreateInput = {
    id?: string
    facultyId: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutIkohzaInput
  }

  export type IkohzaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyUpdateOneRequiredWithoutIkohzasNestedInput
    users?: UserUpdateManyWithoutIkohzaNestedInput
  }

  export type IkohzaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutIkohzaNestedInput
  }

  export type IkohzaCreateManyInput = {
    id?: string
    facultyId: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IkohzaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IkohzaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: CompanyBranchCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyRelationInput
    bookings?: BookingRequestCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: CompanyBranchUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyRelationInput
    bookings?: BookingRequestUncheckedCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: CompanyBranchUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyRelationNestedInput
    bookings?: BookingRequestUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: CompanyBranchUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyRelationNestedInput
    bookings?: BookingRequestUncheckedUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBranchCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutCompanyBranchInput
    bookings?: BookingRequestCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyBranchInput
    bookings?: BookingRequestUncheckedCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutCompanyBranchNestedInput
    bookings?: BookingRequestUpdateManyWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyBranchNestedInput
    bookings?: BookingRequestUncheckedUpdateManyWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchCreateManyInput = {
    id?: string
    companyId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyBranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthProviderCreateInput = {
    id?: string
    provider: string
    providerAccountId: string
    passwordHash?: string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuthProvidersInput
  }

  export type AuthProviderUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    providerAccountId: string
    passwordHash?: string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthProvidersNestedInput
  }

  export type AuthProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderCreateManyInput = {
    id?: string
    userId: string
    provider: string
    providerAccountId: string
    passwordHash?: string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: ServicePricingCreateNestedManyWithoutServiceInput
    bookingItems?: BookingServiceItemCreateNestedManyWithoutServiceInput
    addOnMappings?: ServiceAddOnMappingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: ServicePricingUncheckedCreateNestedManyWithoutServiceInput
    bookingItems?: BookingServiceItemUncheckedCreateNestedManyWithoutServiceInput
    addOnMappings?: ServiceAddOnMappingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: ServicePricingUpdateManyWithoutServiceNestedInput
    bookingItems?: BookingServiceItemUpdateManyWithoutServiceNestedInput
    addOnMappings?: ServiceAddOnMappingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: ServicePricingUncheckedUpdateManyWithoutServiceNestedInput
    bookingItems?: BookingServiceItemUncheckedUpdateManyWithoutServiceNestedInput
    addOnMappings?: ServiceAddOnMappingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingCreateInput = {
    id?: string
    userType: $Enums.user_type_enum
    price: Decimal | DecimalJsLike | number | string
    unit: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutPricingInput
  }

  export type ServicePricingUncheckedCreateInput = {
    id?: string
    serviceId: string
    userType: $Enums.user_type_enum
    price: Decimal | DecimalJsLike | number | string
    unit: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutPricingNestedInput
  }

  export type ServicePricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingCreateManyInput = {
    id?: string
    serviceId: string
    userType: $Enums.user_type_enum
    price: Decimal | DecimalJsLike | number | string
    unit: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRequestCreateInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestCreateManyInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
  }

  export type BookingRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingServiceItemCreateInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceItemsInput
    service: ServiceCreateNestedOneWithoutBookingItemsInput
    equipmentUsages?: SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateInput = {
    id?: string
    bookingRequestId: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingItemsNestedInput
    equipmentUsages?: SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemCreateManyInput = {
    id?: string
    bookingRequestId: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingServiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingServiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleModificationCreateInput = {
    id?: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdAt?: Date | string
    approvedAt?: Date | string | null
    bookingServiceItem: BookingServiceItemCreateNestedOneWithoutModificationsInput
    createdByUser: UserCreateNestedOneWithoutCreatedModificationsInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedModificationsInput
  }

  export type SampleModificationUncheckedCreateInput = {
    id?: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type SampleModificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingServiceItem?: BookingServiceItemUpdateOneRequiredWithoutModificationsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedModificationsNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedModificationsNestedInput
  }

  export type SampleModificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleModificationCreateManyInput = {
    id?: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type SampleModificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SampleModificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceFormCreateInput = {
    id?: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceFormsInput
    generatedByUser: UserCreateNestedOneWithoutServiceFormsInput
    invoices?: InvoiceCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUncheckedCreateInput = {
    id?: string
    bookingRequestId: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    generatedBy: string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceFormsNestedInput
    generatedByUser?: UserUpdateOneRequiredWithoutServiceFormsNestedInput
    invoices?: InvoiceUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormCreateManyInput = {
    id?: string
    bookingRequestId: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    generatedBy: string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceFormUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFormUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceForm: ServiceFormCreateNestedOneWithoutInvoicesInput
    uploadedByUser: UserCreateNestedOneWithoutUploadedInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    serviceFormId: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceForm?: ServiceFormUpdateOneRequiredWithoutInvoicesNestedInput
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    serviceFormId: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    uploadedByUser: UserCreateNestedOneWithoutUploadedPaymentsInput
    verifiedByUser?: UserCreateNestedOneWithoutVerifiedPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedPaymentsNestedInput
    verifiedByUser?: UserUpdateOneWithoutVerifiedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleTrackingCreateInput = {
    id?: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingServiceItem: BookingServiceItemCreateNestedOneWithoutSampleTrackingInput
    updatedByUser?: UserCreateNestedOneWithoutSampleTrackingInput
    analysisResults?: AnalysisResultCreateNestedManyWithoutSampleTrackingInput
  }

  export type SampleTrackingUncheckedCreateInput = {
    id?: string
    bookingServiceItemId: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisResults?: AnalysisResultUncheckedCreateNestedManyWithoutSampleTrackingInput
  }

  export type SampleTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingServiceItem?: BookingServiceItemUpdateOneRequiredWithoutSampleTrackingNestedInput
    updatedByUser?: UserUpdateOneWithoutSampleTrackingNestedInput
    analysisResults?: AnalysisResultUpdateManyWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisResults?: AnalysisResultUncheckedUpdateManyWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingCreateManyInput = {
    id?: string
    bookingServiceItemId: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceBookingCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutWorkspaceBookingsInput
    equipmentUsages?: WorkspaceEquipmentUsageCreateNestedManyWithoutWorkspaceBookingInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingUncheckedCreateInput = {
    id?: string
    bookingRequestId: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutWorkspaceBookingInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutWorkspaceBookingsNestedInput
    equipmentUsages?: WorkspaceEquipmentUsageUpdateManyWithoutWorkspaceBookingNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type WorkspaceBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUncheckedUpdateManyWithoutWorkspaceBookingNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type WorkspaceBookingCreateManyInput = {
    id?: string
    bookingRequestId: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabEquipmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceUsages?: WorkspaceEquipmentUsageCreateNestedManyWithoutEquipmentInput
    sampleUsages?: SampleEquipmentUsageCreateNestedManyWithoutEquipmentInput
  }

  export type LabEquipmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceUsages?: WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
    sampleUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type LabEquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceUsages?: WorkspaceEquipmentUsageUpdateManyWithoutEquipmentNestedInput
    sampleUsages?: SampleEquipmentUsageUpdateManyWithoutEquipmentNestedInput
  }

  export type LabEquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceUsages?: WorkspaceEquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
    sampleUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type LabEquipmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabEquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabEquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageCreateInput = {
    id?: string
    createdAt?: Date | string
    workspaceBooking: WorkspaceBookingCreateNestedOneWithoutEquipmentUsagesInput
    equipment: LabEquipmentCreateNestedOneWithoutWorkspaceUsagesInput
  }

  export type WorkspaceEquipmentUsageUncheckedCreateInput = {
    id?: string
    workspaceBookingId: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type WorkspaceEquipmentUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceBooking?: WorkspaceBookingUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    equipment?: LabEquipmentUpdateOneRequiredWithoutWorkspaceUsagesNestedInput
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceBookingId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageCreateManyInput = {
    id?: string
    workspaceBookingId: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type WorkspaceEquipmentUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceBookingId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageCreateInput = {
    id?: string
    createdAt?: Date | string
    bookedItem: BookingServiceItemCreateNestedOneWithoutEquipmentUsagesInput
    equipment: LabEquipmentCreateNestedOneWithoutSampleUsagesInput
  }

  export type SampleEquipmentUsageUncheckedCreateInput = {
    id?: string
    bookingServiceItemId: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type SampleEquipmentUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedItem?: BookingServiceItemUpdateOneRequiredWithoutEquipmentUsagesNestedInput
    equipment?: LabEquipmentUpdateOneRequiredWithoutSampleUsagesNestedInput
  }

  export type SampleEquipmentUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageCreateManyInput = {
    id?: string
    bookingServiceItemId: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type SampleEquipmentUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultCreateInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sampleTracking: SampleTrackingCreateNestedOneWithoutAnalysisResultsInput
    uploadedByUser: UserCreateNestedOneWithoutUploadedResultsInput
  }

  export type AnalysisResultUncheckedCreateInput = {
    id?: string
    sampleTrackingId: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleTracking?: SampleTrackingUpdateOneRequiredWithoutAnalysisResultsNestedInput
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedResultsNestedInput
  }

  export type AnalysisResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleTrackingId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultCreateManyInput = {
    id?: string
    sampleTrackingId: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleTrackingId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.notification_type_enum
    relatedEntityType?: string | null
    relatedEntityId?: string | null
    title: string
    message: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.notification_type_enum
    relatedEntityType?: string | null
    relatedEntityId?: string | null
    title: string
    message: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.notification_type_enum
    relatedEntityType?: string | null
    relatedEntityId?: string | null
    title: string
    message: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entity?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entity?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalAddOnCatalogCreateInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceMappings?: ServiceAddOnMappingCreateNestedManyWithoutAddOnCatalogInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutAddOnCatalogInput
  }

  export type GlobalAddOnCatalogUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceMappings?: ServiceAddOnMappingUncheckedCreateNestedManyWithoutAddOnCatalogInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutAddOnCatalogInput
  }

  export type GlobalAddOnCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceMappings?: ServiceAddOnMappingUpdateManyWithoutAddOnCatalogNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutAddOnCatalogNestedInput
  }

  export type GlobalAddOnCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceMappings?: ServiceAddOnMappingUncheckedUpdateManyWithoutAddOnCatalogNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutAddOnCatalogNestedInput
  }

  export type GlobalAddOnCatalogCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GlobalAddOnCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GlobalAddOnCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingCreateInput = {
    id?: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutAddOnMappingsInput
    addOnCatalog: GlobalAddOnCatalogCreateNestedOneWithoutServiceMappingsInput
  }

  export type ServiceAddOnMappingUncheckedCreateInput = {
    id?: string
    serviceId: string
    addOnId: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutAddOnMappingsNestedInput
    addOnCatalog?: GlobalAddOnCatalogUpdateOneRequiredWithoutServiceMappingsNestedInput
  }

  export type ServiceAddOnMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingCreateManyInput = {
    id?: string
    serviceId: string
    addOnId: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnCreateInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
    bookingServiceItem?: BookingServiceItemCreateNestedOneWithoutServiceAddOnsInput
    workspaceBooking?: WorkspaceBookingCreateNestedOneWithoutServiceAddOnsInput
    addOnCatalog: GlobalAddOnCatalogCreateNestedOneWithoutServiceAddOnsInput
  }

  export type ServiceAddOnUncheckedCreateInput = {
    id?: string
    bookingServiceItemId?: string | null
    workspaceBookingId?: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingServiceItem?: BookingServiceItemUpdateOneWithoutServiceAddOnsNestedInput
    workspaceBooking?: WorkspaceBookingUpdateOneWithoutServiceAddOnsNestedInput
    addOnCatalog?: GlobalAddOnCatalogUpdateOneRequiredWithoutServiceAddOnsNestedInput
  }

  export type ServiceAddOnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnCatalogId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnCreateManyInput = {
    id?: string
    bookingServiceItemId?: string | null
    workspaceBookingId?: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnCatalogId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BetterAuthSessionListRelationFilter = {
    every?: BetterAuthSessionWhereInput
    some?: BetterAuthSessionWhereInput
    none?: BetterAuthSessionWhereInput
  }

  export type BetterAuthAccountListRelationFilter = {
    every?: BetterAuthAccountWhereInput
    some?: BetterAuthAccountWhereInput
    none?: BetterAuthAccountWhereInput
  }

  export type BetterAuthVerificationListRelationFilter = {
    every?: BetterAuthVerificationWhereInput
    some?: BetterAuthVerificationWhereInput
    none?: BetterAuthVerificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BetterAuthSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetterAuthAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetterAuthVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BetterAuthUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetterAuthUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetterAuthUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BetterAuthUserScalarRelationFilter = {
    is?: BetterAuthUserWhereInput
    isNot?: BetterAuthUserWhereInput
  }

  export type BetterAuthSessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetterAuthSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetterAuthSessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BetterAuthAccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type BetterAuthAccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetterAuthAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BetterAuthAccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type BetterAuthUserNullableScalarRelationFilter = {
    is?: BetterAuthUserWhereInput | null
    isNot?: BetterAuthUserWhereInput | null
  }

  export type BetterAuthVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type BetterAuthVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type BetterAuthVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type IkohzaListRelationFilter = {
    every?: IkohzaWhereInput
    some?: IkohzaWhereInput
    none?: IkohzaWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IkohzaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacultyScalarRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type DepartmentFacultyIdCodeCompoundUniqueInput = {
    facultyId: string
    code: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IkohzaFacultyIdCodeCompoundUniqueInput = {
    facultyId: string
    code: string
  }

  export type IkohzaCountOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    leaderName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IkohzaMaxOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    leaderName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IkohzaMinOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    leaderName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyBranchListRelationFilter = {
    every?: CompanyBranchWhereInput
    some?: CompanyBranchWhereInput
    none?: CompanyBranchWhereInput
  }

  export type BookingRequestListRelationFilter = {
    every?: BookingRequestWhereInput
    some?: BookingRequestWhereInput
    none?: BookingRequestWhereInput
  }

  export type CompanyBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    regNo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    regNo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    legalName?: SortOrder
    regNo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyBranchCompanyIdNameCompoundUniqueInput = {
    companyId: string
    name: string
  }

  export type CompanyBranchCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyBranchMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumuser_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.user_type_enum | Enumuser_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_type_enumFilter<$PrismaModel> | $Enums.user_type_enum
  }

  export type Enumuser_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status_enum | Enumuser_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_status_enumFilter<$PrismaModel> | $Enums.user_status_enum
  }

  export type Enumacademic_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.academic_type_enum | Enumacademic_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumacademic_type_enumFilter<$PrismaModel> | $Enums.academic_type_enum
  }

  export type EnumUTMNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UTM | EnumUTMFieldRefInput<$PrismaModel> | null
    in?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUTMNullableFilter<$PrismaModel> | $Enums.UTM | null
  }

  export type FacultyNullableScalarRelationFilter = {
    is?: FacultyWhereInput | null
    isNot?: FacultyWhereInput | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type IkohzaNullableScalarRelationFilter = {
    is?: IkohzaWhereInput | null
    isNot?: IkohzaWhereInput | null
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type CompanyBranchNullableScalarRelationFilter = {
    is?: CompanyBranchWhereInput | null
    isNot?: CompanyBranchWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuthProviderListRelationFilter = {
    every?: AuthProviderWhereInput
    some?: AuthProviderWhereInput
    none?: AuthProviderWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ServiceFormListRelationFilter = {
    every?: ServiceFormWhereInput
    some?: ServiceFormWhereInput
    none?: ServiceFormWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type AnalysisResultListRelationFilter = {
    every?: AnalysisResultWhereInput
    some?: AnalysisResultWhereInput
    none?: AnalysisResultWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SampleTrackingListRelationFilter = {
    every?: SampleTrackingWhereInput
    some?: SampleTrackingWhereInput
    none?: SampleTrackingWhereInput
  }

  export type SampleModificationListRelationFilter = {
    every?: SampleModificationWhereInput
    some?: SampleModificationWhereInput
    none?: SampleModificationWhereInput
  }

  export type AuthProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalysisResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SampleTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SampleModificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    phone?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    academicType?: SortOrder
    userIdentifier?: SortOrder
    supervisorName?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    ikohzaId?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    UTM?: SortOrder
    address?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    phone?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    academicType?: SortOrder
    userIdentifier?: SortOrder
    supervisorName?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    ikohzaId?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    UTM?: SortOrder
    address?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    phone?: SortOrder
    userType?: SortOrder
    status?: SortOrder
    academicType?: SortOrder
    userIdentifier?: SortOrder
    supervisorName?: SortOrder
    facultyId?: SortOrder
    departmentId?: SortOrder
    ikohzaId?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
    UTM?: SortOrder
    address?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type Enumuser_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_type_enum | Enumuser_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.user_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_type_enumFilter<$PrismaModel>
    _max?: NestedEnumuser_type_enumFilter<$PrismaModel>
  }

  export type Enumuser_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status_enum | Enumuser_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.user_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_status_enumFilter<$PrismaModel>
    _max?: NestedEnumuser_status_enumFilter<$PrismaModel>
  }

  export type Enumacademic_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.academic_type_enum | Enumacademic_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumacademic_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.academic_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumacademic_type_enumFilter<$PrismaModel>
    _max?: NestedEnumacademic_type_enumFilter<$PrismaModel>
  }

  export type EnumUTMNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UTM | EnumUTMFieldRefInput<$PrismaModel> | null
    in?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUTMNullableWithAggregatesFilter<$PrismaModel> | $Enums.UTM | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUTMNullableFilter<$PrismaModel>
    _max?: NestedEnumUTMNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuthProviderProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AuthProviderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    passwordHash?: SortOrder
    oauthData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthProviderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type Enumservice_category_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.service_category_enum | Enumservice_category_enumFieldRefInput<$PrismaModel>
    in?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumservice_category_enumFilter<$PrismaModel> | $Enums.service_category_enum
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicePricingListRelationFilter = {
    every?: ServicePricingWhereInput
    some?: ServicePricingWhereInput
    none?: ServicePricingWhereInput
  }

  export type BookingServiceItemListRelationFilter = {
    every?: BookingServiceItemWhereInput
    some?: BookingServiceItemWhereInput
    none?: BookingServiceItemWhereInput
  }

  export type ServiceAddOnMappingListRelationFilter = {
    every?: ServiceAddOnMappingWhereInput
    some?: ServiceAddOnMappingWhereInput
    none?: ServiceAddOnMappingWhereInput
  }

  export type ServicePricingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingServiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceAddOnMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresSample?: SortOrder
    minSampleMass?: SortOrder
    operatingHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    minSampleMass?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresSample?: SortOrder
    minSampleMass?: SortOrder
    operatingHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    requiresSample?: SortOrder
    minSampleMass?: SortOrder
    operatingHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    minSampleMass?: SortOrder
  }

  export type Enumservice_category_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.service_category_enum | Enumservice_category_enumFieldRefInput<$PrismaModel>
    in?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumservice_category_enumWithAggregatesFilter<$PrismaModel> | $Enums.service_category_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumservice_category_enumFilter<$PrismaModel>
    _max?: NestedEnumservice_category_enumFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServicePricingCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userType?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicePricingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ServicePricingMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userType?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicePricingMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userType?: SortOrder
    price?: SortOrder
    unit?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicePricingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Enumbooking_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.booking_status_enum | Enumbooking_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumbooking_status_enumFilter<$PrismaModel> | $Enums.booking_status_enum
  }

  export type WorkspaceBookingListRelationFilter = {
    every?: WorkspaceBookingWhereInput
    some?: WorkspaceBookingWhereInput
    none?: WorkspaceBookingWhereInput
  }

  export type WorkspaceBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceNumber?: SortOrder
    projectDescription?: SortOrder
    preferredStartDate?: SortOrder
    preferredEndDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
  }

  export type BookingRequestAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type BookingRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceNumber?: SortOrder
    projectDescription?: SortOrder
    preferredStartDate?: SortOrder
    preferredEndDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
  }

  export type BookingRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    referenceNumber?: SortOrder
    projectDescription?: SortOrder
    preferredStartDate?: SortOrder
    preferredEndDate?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewNotes?: SortOrder
    companyId?: SortOrder
    companyBranchId?: SortOrder
  }

  export type BookingRequestSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type Enumbooking_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.booking_status_enum | Enumbooking_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumbooking_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.booking_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbooking_status_enumFilter<$PrismaModel>
    _max?: NestedEnumbooking_status_enumFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BookingRequestScalarRelationFilter = {
    is?: BookingRequestWhereInput
    isNot?: BookingRequestWhereInput
  }

  export type SampleEquipmentUsageListRelationFilter = {
    every?: SampleEquipmentUsageWhereInput
    some?: SampleEquipmentUsageWhereInput
    none?: SampleEquipmentUsageWhereInput
  }

  export type ServiceAddOnListRelationFilter = {
    every?: ServiceAddOnWhereInput
    some?: ServiceAddOnWhereInput
    none?: ServiceAddOnWhereInput
  }

  export type SampleEquipmentUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceAddOnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingServiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sampleName?: SortOrder
    sampleDetails?: SortOrder
    sampleType?: SortOrder
    sampleHazard?: SortOrder
    testingMethod?: SortOrder
    degasConditions?: SortOrder
    solventSystem?: SortOrder
    solvents?: SortOrder
    solventComposition?: SortOrder
    columnType?: SortOrder
    flowRate?: SortOrder
    wavelength?: SortOrder
    expectedRetentionTime?: SortOrder
    samplePreparation?: SortOrder
    notes?: SortOrder
    expectedCompletionDate?: SortOrder
    actualCompletionDate?: SortOrder
    turnaroundEstimate?: SortOrder
    hplcPreparationRequired?: SortOrder
    temperatureControlled?: SortOrder
    lightSensitive?: SortOrder
    hazardousMaterial?: SortOrder
    inertAtmosphere?: SortOrder
    otherEquipmentRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingServiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    flowRate?: SortOrder
    wavelength?: SortOrder
    expectedRetentionTime?: SortOrder
  }

  export type BookingServiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sampleName?: SortOrder
    sampleDetails?: SortOrder
    sampleType?: SortOrder
    sampleHazard?: SortOrder
    testingMethod?: SortOrder
    degasConditions?: SortOrder
    solventSystem?: SortOrder
    solvents?: SortOrder
    solventComposition?: SortOrder
    columnType?: SortOrder
    flowRate?: SortOrder
    wavelength?: SortOrder
    expectedRetentionTime?: SortOrder
    samplePreparation?: SortOrder
    notes?: SortOrder
    expectedCompletionDate?: SortOrder
    actualCompletionDate?: SortOrder
    turnaroundEstimate?: SortOrder
    hplcPreparationRequired?: SortOrder
    temperatureControlled?: SortOrder
    lightSensitive?: SortOrder
    hazardousMaterial?: SortOrder
    inertAtmosphere?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingServiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    sampleName?: SortOrder
    sampleDetails?: SortOrder
    sampleType?: SortOrder
    sampleHazard?: SortOrder
    testingMethod?: SortOrder
    degasConditions?: SortOrder
    solventSystem?: SortOrder
    solvents?: SortOrder
    solventComposition?: SortOrder
    columnType?: SortOrder
    flowRate?: SortOrder
    wavelength?: SortOrder
    expectedRetentionTime?: SortOrder
    samplePreparation?: SortOrder
    notes?: SortOrder
    expectedCompletionDate?: SortOrder
    actualCompletionDate?: SortOrder
    turnaroundEstimate?: SortOrder
    hplcPreparationRequired?: SortOrder
    temperatureControlled?: SortOrder
    lightSensitive?: SortOrder
    hazardousMaterial?: SortOrder
    inertAtmosphere?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingServiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    durationMonths?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    flowRate?: SortOrder
    wavelength?: SortOrder
    expectedRetentionTime?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enummodification_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.modification_status_enum | Enummodification_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnummodification_status_enumFilter<$PrismaModel> | $Enums.modification_status_enum
  }

  export type BookingServiceItemScalarRelationFilter = {
    is?: BookingServiceItemWhereInput
    isNot?: BookingServiceItemWhereInput
  }

  export type SampleModificationCountOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type SampleModificationAvgOrderByAggregateInput = {
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
  }

  export type SampleModificationMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type SampleModificationMinOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
    approvedBy?: SortOrder
  }

  export type SampleModificationSumOrderByAggregateInput = {
    originalQuantity?: SortOrder
    newQuantity?: SortOrder
    originalDurationMonths?: SortOrder
    newDurationMonths?: SortOrder
    originalTotalPrice?: SortOrder
    newTotalPrice?: SortOrder
  }

  export type Enummodification_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.modification_status_enum | Enummodification_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnummodification_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.modification_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummodification_status_enumFilter<$PrismaModel>
    _max?: NestedEnummodification_status_enumFilter<$PrismaModel>
  }

  export type Enumform_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.form_status_enum | Enumform_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumform_status_enumFilter<$PrismaModel> | $Enums.form_status_enum
  }

  export type ServiceFormCountOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    formNumber?: SortOrder
    costCentre?: SortOrder
    facilityLab?: SortOrder
    staffPicName?: SortOrder
    staffPicEmail?: SortOrder
    staffPicPhone?: SortOrder
    subtotal?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    serviceFormUnsignedPdfPath?: SortOrder
    serviceFormSignedPdfPath?: SortOrder
    requiresWorkingAreaAgreement?: SortOrder
    workingAreaAgreementUnsignedPdfPath?: SortOrder
    workingAreaAgreementSignedPdfPath?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    downloadedAt?: SortOrder
    signedFormsUploadedAt?: SortOrder
    signedFormsUploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceFormAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    totalAmount?: SortOrder
  }

  export type ServiceFormMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    formNumber?: SortOrder
    costCentre?: SortOrder
    facilityLab?: SortOrder
    staffPicName?: SortOrder
    staffPicEmail?: SortOrder
    staffPicPhone?: SortOrder
    subtotal?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    serviceFormUnsignedPdfPath?: SortOrder
    serviceFormSignedPdfPath?: SortOrder
    requiresWorkingAreaAgreement?: SortOrder
    workingAreaAgreementUnsignedPdfPath?: SortOrder
    workingAreaAgreementSignedPdfPath?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    downloadedAt?: SortOrder
    signedFormsUploadedAt?: SortOrder
    signedFormsUploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceFormMinOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    formNumber?: SortOrder
    costCentre?: SortOrder
    facilityLab?: SortOrder
    staffPicName?: SortOrder
    staffPicEmail?: SortOrder
    staffPicPhone?: SortOrder
    subtotal?: SortOrder
    totalAmount?: SortOrder
    validUntil?: SortOrder
    status?: SortOrder
    serviceFormUnsignedPdfPath?: SortOrder
    serviceFormSignedPdfPath?: SortOrder
    requiresWorkingAreaAgreement?: SortOrder
    workingAreaAgreementUnsignedPdfPath?: SortOrder
    workingAreaAgreementSignedPdfPath?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    downloadedAt?: SortOrder
    signedFormsUploadedAt?: SortOrder
    signedFormsUploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceFormSumOrderByAggregateInput = {
    subtotal?: SortOrder
    totalAmount?: SortOrder
  }

  export type Enumform_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.form_status_enum | Enumform_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumform_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.form_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumform_status_enumFilter<$PrismaModel>
    _max?: NestedEnumform_status_enumFilter<$PrismaModel>
  }

  export type Enuminvoice_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumFilter<$PrismaModel> | $Enums.invoice_status_enum
  }

  export type ServiceFormScalarRelationFilter = {
    is?: ServiceFormWhereInput
    isNot?: ServiceFormWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    serviceFormId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceFormId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    serviceFormId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    filePath?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Enuminvoice_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.invoice_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
    _max?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
  }

  export type Enumpayment_method_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumFilter<$PrismaModel> | $Enums.payment_method_enum
  }

  export type Enumpayment_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumFilter<$PrismaModel> | $Enums.payment_status_enum
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    receiptFilePath?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    verificationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    receiptFilePath?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    verificationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    receiptFilePath?: SortOrder
    status?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    verificationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Enumpayment_method_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_enumFilter<$PrismaModel>
  }

  export type Enumpayment_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_status_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_status_enumFilter<$PrismaModel>
  }

  export type Enumsample_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.sample_status_enum | Enumsample_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsample_status_enumFilter<$PrismaModel> | $Enums.sample_status_enum
  }

  export type SampleTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    sampleIdentifier?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrder
    analysisStartAt?: SortOrder
    analysisCompleteAt?: SortOrder
    returnRequestedAt?: SortOrder
    returnedAt?: SortOrder
    notes?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SampleTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    sampleIdentifier?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrder
    analysisStartAt?: SortOrder
    analysisCompleteAt?: SortOrder
    returnRequestedAt?: SortOrder
    returnedAt?: SortOrder
    notes?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SampleTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    sampleIdentifier?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrder
    analysisStartAt?: SortOrder
    analysisCompleteAt?: SortOrder
    returnRequestedAt?: SortOrder
    returnedAt?: SortOrder
    notes?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumsample_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sample_status_enum | Enumsample_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsample_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.sample_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsample_status_enumFilter<$PrismaModel>
    _max?: NestedEnumsample_status_enumFilter<$PrismaModel>
  }

  export type WorkspaceEquipmentUsageListRelationFilter = {
    every?: WorkspaceEquipmentUsageWhereInput
    some?: WorkspaceEquipmentUsageWhereInput
    none?: WorkspaceEquipmentUsageWhereInput
  }

  export type WorkspaceEquipmentUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceBookingCountOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    preferredTimeSlot?: SortOrder
    specialEquipment?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    preferredTimeSlot?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceBookingMinOrderByAggregateInput = {
    id?: SortOrder
    bookingRequestId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    preferredTimeSlot?: SortOrder
    purpose?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isAvailable?: SortOrder
    maintenanceNotes?: SortOrder
    expectedMaintenanceEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isAvailable?: SortOrder
    maintenanceNotes?: SortOrder
    expectedMaintenanceEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isAvailable?: SortOrder
    maintenanceNotes?: SortOrder
    expectedMaintenanceEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceBookingScalarRelationFilter = {
    is?: WorkspaceBookingWhereInput
    isNot?: WorkspaceBookingWhereInput
  }

  export type LabEquipmentScalarRelationFilter = {
    is?: LabEquipmentWhereInput
    isNot?: LabEquipmentWhereInput
  }

  export type WorkspaceEquipmentUsageCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceBookingId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkspaceEquipmentUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceBookingId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkspaceEquipmentUsageMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceBookingId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type SampleEquipmentUsageCountOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type SampleEquipmentUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type SampleEquipmentUsageMinOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type SampleTrackingScalarRelationFilter = {
    is?: SampleTrackingWhereInput
    isNot?: SampleTrackingWhereInput
  }

  export type AnalysisResultCountOrderByAggregateInput = {
    id?: SortOrder
    sampleTrackingId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    description?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisResultAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type AnalysisResultMaxOrderByAggregateInput = {
    id?: SortOrder
    sampleTrackingId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    description?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisResultMinOrderByAggregateInput = {
    id?: SortOrder
    sampleTrackingId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    description?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalysisResultSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type Enumnotification_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type_enum | Enumnotification_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_type_enumFilter<$PrismaModel> | $Enums.notification_type_enum
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    relatedEntityType?: SortOrder
    relatedEntityId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    relatedEntityType?: SortOrder
    relatedEntityId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    relatedEntityType?: SortOrder
    relatedEntityId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumnotification_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type_enum | Enumnotification_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.notification_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotification_type_enumFilter<$PrismaModel>
    _max?: NestedEnumnotification_type_enumFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type GlobalAddOnCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultAmount?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalAddOnCatalogAvgOrderByAggregateInput = {
    defaultAmount?: SortOrder
  }

  export type GlobalAddOnCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultAmount?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalAddOnCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultAmount?: SortOrder
    applicableTo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GlobalAddOnCatalogSumOrderByAggregateInput = {
    defaultAmount?: SortOrder
  }

  export type GlobalAddOnCatalogScalarRelationFilter = {
    is?: GlobalAddOnCatalogWhereInput
    isNot?: GlobalAddOnCatalogWhereInput
  }

  export type ServiceAddOnMappingServiceIdAddOnIdCompoundUniqueInput = {
    serviceId: string
    addOnId: string
  }

  export type ServiceAddOnMappingCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    addOnId?: SortOrder
    isEnabled?: SortOrder
    customAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAddOnMappingAvgOrderByAggregateInput = {
    customAmount?: SortOrder
  }

  export type ServiceAddOnMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    addOnId?: SortOrder
    isEnabled?: SortOrder
    customAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAddOnMappingMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    addOnId?: SortOrder
    isEnabled?: SortOrder
    customAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAddOnMappingSumOrderByAggregateInput = {
    customAmount?: SortOrder
  }

  export type BookingServiceItemNullableScalarRelationFilter = {
    is?: BookingServiceItemWhereInput | null
    isNot?: BookingServiceItemWhereInput | null
  }

  export type WorkspaceBookingNullableScalarRelationFilter = {
    is?: WorkspaceBookingWhereInput | null
    isNot?: WorkspaceBookingWhereInput | null
  }

  export type ServiceAddOnCountOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    workspaceBookingId?: SortOrder
    addOnCatalogId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAddOnAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ServiceAddOnMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    workspaceBookingId?: SortOrder
    addOnCatalogId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAddOnMinOrderByAggregateInput = {
    id?: SortOrder
    bookingServiceItemId?: SortOrder
    workspaceBookingId?: SortOrder
    addOnCatalogId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    taxable?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAddOnSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BetterAuthSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<BetterAuthSessionCreateWithoutUserInput, BetterAuthSessionUncheckedCreateWithoutUserInput> | BetterAuthSessionCreateWithoutUserInput[] | BetterAuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthSessionCreateOrConnectWithoutUserInput | BetterAuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: BetterAuthSessionCreateManyUserInputEnvelope
    connect?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
  }

  export type BetterAuthAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<BetterAuthAccountCreateWithoutUserInput, BetterAuthAccountUncheckedCreateWithoutUserInput> | BetterAuthAccountCreateWithoutUserInput[] | BetterAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthAccountCreateOrConnectWithoutUserInput | BetterAuthAccountCreateOrConnectWithoutUserInput[]
    createMany?: BetterAuthAccountCreateManyUserInputEnvelope
    connect?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
  }

  export type BetterAuthVerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<BetterAuthVerificationCreateWithoutUserInput, BetterAuthVerificationUncheckedCreateWithoutUserInput> | BetterAuthVerificationCreateWithoutUserInput[] | BetterAuthVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthVerificationCreateOrConnectWithoutUserInput | BetterAuthVerificationCreateOrConnectWithoutUserInput[]
    createMany?: BetterAuthVerificationCreateManyUserInputEnvelope
    connect?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
  }

  export type BetterAuthSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BetterAuthSessionCreateWithoutUserInput, BetterAuthSessionUncheckedCreateWithoutUserInput> | BetterAuthSessionCreateWithoutUserInput[] | BetterAuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthSessionCreateOrConnectWithoutUserInput | BetterAuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: BetterAuthSessionCreateManyUserInputEnvelope
    connect?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
  }

  export type BetterAuthAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BetterAuthAccountCreateWithoutUserInput, BetterAuthAccountUncheckedCreateWithoutUserInput> | BetterAuthAccountCreateWithoutUserInput[] | BetterAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthAccountCreateOrConnectWithoutUserInput | BetterAuthAccountCreateOrConnectWithoutUserInput[]
    createMany?: BetterAuthAccountCreateManyUserInputEnvelope
    connect?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
  }

  export type BetterAuthVerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BetterAuthVerificationCreateWithoutUserInput, BetterAuthVerificationUncheckedCreateWithoutUserInput> | BetterAuthVerificationCreateWithoutUserInput[] | BetterAuthVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthVerificationCreateOrConnectWithoutUserInput | BetterAuthVerificationCreateOrConnectWithoutUserInput[]
    createMany?: BetterAuthVerificationCreateManyUserInputEnvelope
    connect?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BetterAuthSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetterAuthSessionCreateWithoutUserInput, BetterAuthSessionUncheckedCreateWithoutUserInput> | BetterAuthSessionCreateWithoutUserInput[] | BetterAuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthSessionCreateOrConnectWithoutUserInput | BetterAuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: BetterAuthSessionUpsertWithWhereUniqueWithoutUserInput | BetterAuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetterAuthSessionCreateManyUserInputEnvelope
    set?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    disconnect?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    delete?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    connect?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    update?: BetterAuthSessionUpdateWithWhereUniqueWithoutUserInput | BetterAuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetterAuthSessionUpdateManyWithWhereWithoutUserInput | BetterAuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetterAuthSessionScalarWhereInput | BetterAuthSessionScalarWhereInput[]
  }

  export type BetterAuthAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetterAuthAccountCreateWithoutUserInput, BetterAuthAccountUncheckedCreateWithoutUserInput> | BetterAuthAccountCreateWithoutUserInput[] | BetterAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthAccountCreateOrConnectWithoutUserInput | BetterAuthAccountCreateOrConnectWithoutUserInput[]
    upsert?: BetterAuthAccountUpsertWithWhereUniqueWithoutUserInput | BetterAuthAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetterAuthAccountCreateManyUserInputEnvelope
    set?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    disconnect?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    delete?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    connect?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    update?: BetterAuthAccountUpdateWithWhereUniqueWithoutUserInput | BetterAuthAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetterAuthAccountUpdateManyWithWhereWithoutUserInput | BetterAuthAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetterAuthAccountScalarWhereInput | BetterAuthAccountScalarWhereInput[]
  }

  export type BetterAuthVerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetterAuthVerificationCreateWithoutUserInput, BetterAuthVerificationUncheckedCreateWithoutUserInput> | BetterAuthVerificationCreateWithoutUserInput[] | BetterAuthVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthVerificationCreateOrConnectWithoutUserInput | BetterAuthVerificationCreateOrConnectWithoutUserInput[]
    upsert?: BetterAuthVerificationUpsertWithWhereUniqueWithoutUserInput | BetterAuthVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetterAuthVerificationCreateManyUserInputEnvelope
    set?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    disconnect?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    delete?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    connect?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    update?: BetterAuthVerificationUpdateWithWhereUniqueWithoutUserInput | BetterAuthVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetterAuthVerificationUpdateManyWithWhereWithoutUserInput | BetterAuthVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetterAuthVerificationScalarWhereInput | BetterAuthVerificationScalarWhereInput[]
  }

  export type BetterAuthSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetterAuthSessionCreateWithoutUserInput, BetterAuthSessionUncheckedCreateWithoutUserInput> | BetterAuthSessionCreateWithoutUserInput[] | BetterAuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthSessionCreateOrConnectWithoutUserInput | BetterAuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: BetterAuthSessionUpsertWithWhereUniqueWithoutUserInput | BetterAuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetterAuthSessionCreateManyUserInputEnvelope
    set?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    disconnect?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    delete?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    connect?: BetterAuthSessionWhereUniqueInput | BetterAuthSessionWhereUniqueInput[]
    update?: BetterAuthSessionUpdateWithWhereUniqueWithoutUserInput | BetterAuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetterAuthSessionUpdateManyWithWhereWithoutUserInput | BetterAuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetterAuthSessionScalarWhereInput | BetterAuthSessionScalarWhereInput[]
  }

  export type BetterAuthAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetterAuthAccountCreateWithoutUserInput, BetterAuthAccountUncheckedCreateWithoutUserInput> | BetterAuthAccountCreateWithoutUserInput[] | BetterAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthAccountCreateOrConnectWithoutUserInput | BetterAuthAccountCreateOrConnectWithoutUserInput[]
    upsert?: BetterAuthAccountUpsertWithWhereUniqueWithoutUserInput | BetterAuthAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetterAuthAccountCreateManyUserInputEnvelope
    set?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    disconnect?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    delete?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    connect?: BetterAuthAccountWhereUniqueInput | BetterAuthAccountWhereUniqueInput[]
    update?: BetterAuthAccountUpdateWithWhereUniqueWithoutUserInput | BetterAuthAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetterAuthAccountUpdateManyWithWhereWithoutUserInput | BetterAuthAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetterAuthAccountScalarWhereInput | BetterAuthAccountScalarWhereInput[]
  }

  export type BetterAuthVerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BetterAuthVerificationCreateWithoutUserInput, BetterAuthVerificationUncheckedCreateWithoutUserInput> | BetterAuthVerificationCreateWithoutUserInput[] | BetterAuthVerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BetterAuthVerificationCreateOrConnectWithoutUserInput | BetterAuthVerificationCreateOrConnectWithoutUserInput[]
    upsert?: BetterAuthVerificationUpsertWithWhereUniqueWithoutUserInput | BetterAuthVerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BetterAuthVerificationCreateManyUserInputEnvelope
    set?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    disconnect?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    delete?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    connect?: BetterAuthVerificationWhereUniqueInput | BetterAuthVerificationWhereUniqueInput[]
    update?: BetterAuthVerificationUpdateWithWhereUniqueWithoutUserInput | BetterAuthVerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BetterAuthVerificationUpdateManyWithWhereWithoutUserInput | BetterAuthVerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BetterAuthVerificationScalarWhereInput | BetterAuthVerificationScalarWhereInput[]
  }

  export type BetterAuthUserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<BetterAuthUserCreateWithoutSessionsInput, BetterAuthUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BetterAuthUserCreateOrConnectWithoutSessionsInput
    connect?: BetterAuthUserWhereUniqueInput
  }

  export type BetterAuthUserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<BetterAuthUserCreateWithoutSessionsInput, BetterAuthUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BetterAuthUserCreateOrConnectWithoutSessionsInput
    upsert?: BetterAuthUserUpsertWithoutSessionsInput
    connect?: BetterAuthUserWhereUniqueInput
    update?: XOR<XOR<BetterAuthUserUpdateToOneWithWhereWithoutSessionsInput, BetterAuthUserUpdateWithoutSessionsInput>, BetterAuthUserUncheckedUpdateWithoutSessionsInput>
  }

  export type BetterAuthUserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<BetterAuthUserCreateWithoutAccountsInput, BetterAuthUserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: BetterAuthUserCreateOrConnectWithoutAccountsInput
    connect?: BetterAuthUserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BetterAuthUserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<BetterAuthUserCreateWithoutAccountsInput, BetterAuthUserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: BetterAuthUserCreateOrConnectWithoutAccountsInput
    upsert?: BetterAuthUserUpsertWithoutAccountsInput
    connect?: BetterAuthUserWhereUniqueInput
    update?: XOR<XOR<BetterAuthUserUpdateToOneWithWhereWithoutAccountsInput, BetterAuthUserUpdateWithoutAccountsInput>, BetterAuthUserUncheckedUpdateWithoutAccountsInput>
  }

  export type BetterAuthUserCreateNestedOneWithoutVerificationsInput = {
    create?: XOR<BetterAuthUserCreateWithoutVerificationsInput, BetterAuthUserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: BetterAuthUserCreateOrConnectWithoutVerificationsInput
    connect?: BetterAuthUserWhereUniqueInput
  }

  export type BetterAuthUserUpdateOneWithoutVerificationsNestedInput = {
    create?: XOR<BetterAuthUserCreateWithoutVerificationsInput, BetterAuthUserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: BetterAuthUserCreateOrConnectWithoutVerificationsInput
    upsert?: BetterAuthUserUpsertWithoutVerificationsInput
    disconnect?: BetterAuthUserWhereInput | boolean
    delete?: BetterAuthUserWhereInput | boolean
    connect?: BetterAuthUserWhereUniqueInput
    update?: XOR<XOR<BetterAuthUserUpdateToOneWithWhereWithoutVerificationsInput, BetterAuthUserUpdateWithoutVerificationsInput>, BetterAuthUserUncheckedUpdateWithoutVerificationsInput>
  }

  export type DepartmentCreateNestedManyWithoutFacultyInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type IkohzaCreateNestedManyWithoutFacultyInput = {
    create?: XOR<IkohzaCreateWithoutFacultyInput, IkohzaUncheckedCreateWithoutFacultyInput> | IkohzaCreateWithoutFacultyInput[] | IkohzaUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: IkohzaCreateOrConnectWithoutFacultyInput | IkohzaCreateOrConnectWithoutFacultyInput[]
    createMany?: IkohzaCreateManyFacultyInputEnvelope
    connect?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutFacultyRelationInput = {
    create?: XOR<UserCreateWithoutFacultyRelationInput, UserUncheckedCreateWithoutFacultyRelationInput> | UserCreateWithoutFacultyRelationInput[] | UserUncheckedCreateWithoutFacultyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacultyRelationInput | UserCreateOrConnectWithoutFacultyRelationInput[]
    createMany?: UserCreateManyFacultyRelationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type IkohzaUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<IkohzaCreateWithoutFacultyInput, IkohzaUncheckedCreateWithoutFacultyInput> | IkohzaCreateWithoutFacultyInput[] | IkohzaUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: IkohzaCreateOrConnectWithoutFacultyInput | IkohzaCreateOrConnectWithoutFacultyInput[]
    createMany?: IkohzaCreateManyFacultyInputEnvelope
    connect?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutFacultyRelationInput = {
    create?: XOR<UserCreateWithoutFacultyRelationInput, UserUncheckedCreateWithoutFacultyRelationInput> | UserCreateWithoutFacultyRelationInput[] | UserUncheckedCreateWithoutFacultyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacultyRelationInput | UserCreateOrConnectWithoutFacultyRelationInput[]
    createMany?: UserCreateManyFacultyRelationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutFacultyInput | DepartmentUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutFacultyInput | DepartmentUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutFacultyInput | DepartmentUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type IkohzaUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<IkohzaCreateWithoutFacultyInput, IkohzaUncheckedCreateWithoutFacultyInput> | IkohzaCreateWithoutFacultyInput[] | IkohzaUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: IkohzaCreateOrConnectWithoutFacultyInput | IkohzaCreateOrConnectWithoutFacultyInput[]
    upsert?: IkohzaUpsertWithWhereUniqueWithoutFacultyInput | IkohzaUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: IkohzaCreateManyFacultyInputEnvelope
    set?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    disconnect?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    delete?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    connect?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    update?: IkohzaUpdateWithWhereUniqueWithoutFacultyInput | IkohzaUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: IkohzaUpdateManyWithWhereWithoutFacultyInput | IkohzaUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: IkohzaScalarWhereInput | IkohzaScalarWhereInput[]
  }

  export type UserUpdateManyWithoutFacultyRelationNestedInput = {
    create?: XOR<UserCreateWithoutFacultyRelationInput, UserUncheckedCreateWithoutFacultyRelationInput> | UserCreateWithoutFacultyRelationInput[] | UserUncheckedCreateWithoutFacultyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacultyRelationInput | UserCreateOrConnectWithoutFacultyRelationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFacultyRelationInput | UserUpsertWithWhereUniqueWithoutFacultyRelationInput[]
    createMany?: UserCreateManyFacultyRelationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFacultyRelationInput | UserUpdateWithWhereUniqueWithoutFacultyRelationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFacultyRelationInput | UserUpdateManyWithWhereWithoutFacultyRelationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput> | DepartmentCreateWithoutFacultyInput[] | DepartmentUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacultyInput | DepartmentCreateOrConnectWithoutFacultyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutFacultyInput | DepartmentUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: DepartmentCreateManyFacultyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutFacultyInput | DepartmentUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutFacultyInput | DepartmentUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type IkohzaUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<IkohzaCreateWithoutFacultyInput, IkohzaUncheckedCreateWithoutFacultyInput> | IkohzaCreateWithoutFacultyInput[] | IkohzaUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: IkohzaCreateOrConnectWithoutFacultyInput | IkohzaCreateOrConnectWithoutFacultyInput[]
    upsert?: IkohzaUpsertWithWhereUniqueWithoutFacultyInput | IkohzaUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: IkohzaCreateManyFacultyInputEnvelope
    set?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    disconnect?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    delete?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    connect?: IkohzaWhereUniqueInput | IkohzaWhereUniqueInput[]
    update?: IkohzaUpdateWithWhereUniqueWithoutFacultyInput | IkohzaUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: IkohzaUpdateManyWithWhereWithoutFacultyInput | IkohzaUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: IkohzaScalarWhereInput | IkohzaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutFacultyRelationNestedInput = {
    create?: XOR<UserCreateWithoutFacultyRelationInput, UserUncheckedCreateWithoutFacultyRelationInput> | UserCreateWithoutFacultyRelationInput[] | UserUncheckedCreateWithoutFacultyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFacultyRelationInput | UserCreateOrConnectWithoutFacultyRelationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFacultyRelationInput | UserUpsertWithWhereUniqueWithoutFacultyRelationInput[]
    createMany?: UserCreateManyFacultyRelationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFacultyRelationInput | UserUpdateWithWhereUniqueWithoutFacultyRelationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFacultyRelationInput | UserUpdateManyWithWhereWithoutFacultyRelationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentsInput
    connect?: FacultyWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutDepartmentRelationInput = {
    create?: XOR<UserCreateWithoutDepartmentRelationInput, UserUncheckedCreateWithoutDepartmentRelationInput> | UserCreateWithoutDepartmentRelationInput[] | UserUncheckedCreateWithoutDepartmentRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentRelationInput | UserCreateOrConnectWithoutDepartmentRelationInput[]
    createMany?: UserCreateManyDepartmentRelationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentRelationInput = {
    create?: XOR<UserCreateWithoutDepartmentRelationInput, UserUncheckedCreateWithoutDepartmentRelationInput> | UserCreateWithoutDepartmentRelationInput[] | UserUncheckedCreateWithoutDepartmentRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentRelationInput | UserCreateOrConnectWithoutDepartmentRelationInput[]
    createMany?: UserCreateManyDepartmentRelationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FacultyUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutDepartmentsInput
    upsert?: FacultyUpsertWithoutDepartmentsInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutDepartmentsInput, FacultyUpdateWithoutDepartmentsInput>, FacultyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type UserUpdateManyWithoutDepartmentRelationNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentRelationInput, UserUncheckedCreateWithoutDepartmentRelationInput> | UserCreateWithoutDepartmentRelationInput[] | UserUncheckedCreateWithoutDepartmentRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentRelationInput | UserCreateOrConnectWithoutDepartmentRelationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentRelationInput | UserUpsertWithWhereUniqueWithoutDepartmentRelationInput[]
    createMany?: UserCreateManyDepartmentRelationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentRelationInput | UserUpdateWithWhereUniqueWithoutDepartmentRelationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentRelationInput | UserUpdateManyWithWhereWithoutDepartmentRelationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentRelationNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentRelationInput, UserUncheckedCreateWithoutDepartmentRelationInput> | UserCreateWithoutDepartmentRelationInput[] | UserUncheckedCreateWithoutDepartmentRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentRelationInput | UserCreateOrConnectWithoutDepartmentRelationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentRelationInput | UserUpsertWithWhereUniqueWithoutDepartmentRelationInput[]
    createMany?: UserCreateManyDepartmentRelationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentRelationInput | UserUpdateWithWhereUniqueWithoutDepartmentRelationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentRelationInput | UserUpdateManyWithWhereWithoutDepartmentRelationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutIkohzasInput = {
    create?: XOR<FacultyCreateWithoutIkohzasInput, FacultyUncheckedCreateWithoutIkohzasInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutIkohzasInput
    connect?: FacultyWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutIkohzaInput = {
    create?: XOR<UserCreateWithoutIkohzaInput, UserUncheckedCreateWithoutIkohzaInput> | UserCreateWithoutIkohzaInput[] | UserUncheckedCreateWithoutIkohzaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIkohzaInput | UserCreateOrConnectWithoutIkohzaInput[]
    createMany?: UserCreateManyIkohzaInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutIkohzaInput = {
    create?: XOR<UserCreateWithoutIkohzaInput, UserUncheckedCreateWithoutIkohzaInput> | UserCreateWithoutIkohzaInput[] | UserUncheckedCreateWithoutIkohzaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIkohzaInput | UserCreateOrConnectWithoutIkohzaInput[]
    createMany?: UserCreateManyIkohzaInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FacultyUpdateOneRequiredWithoutIkohzasNestedInput = {
    create?: XOR<FacultyCreateWithoutIkohzasInput, FacultyUncheckedCreateWithoutIkohzasInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutIkohzasInput
    upsert?: FacultyUpsertWithoutIkohzasInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutIkohzasInput, FacultyUpdateWithoutIkohzasInput>, FacultyUncheckedUpdateWithoutIkohzasInput>
  }

  export type UserUpdateManyWithoutIkohzaNestedInput = {
    create?: XOR<UserCreateWithoutIkohzaInput, UserUncheckedCreateWithoutIkohzaInput> | UserCreateWithoutIkohzaInput[] | UserUncheckedCreateWithoutIkohzaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIkohzaInput | UserCreateOrConnectWithoutIkohzaInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutIkohzaInput | UserUpsertWithWhereUniqueWithoutIkohzaInput[]
    createMany?: UserCreateManyIkohzaInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutIkohzaInput | UserUpdateWithWhereUniqueWithoutIkohzaInput[]
    updateMany?: UserUpdateManyWithWhereWithoutIkohzaInput | UserUpdateManyWithWhereWithoutIkohzaInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutIkohzaNestedInput = {
    create?: XOR<UserCreateWithoutIkohzaInput, UserUncheckedCreateWithoutIkohzaInput> | UserCreateWithoutIkohzaInput[] | UserUncheckedCreateWithoutIkohzaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutIkohzaInput | UserCreateOrConnectWithoutIkohzaInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutIkohzaInput | UserUpsertWithWhereUniqueWithoutIkohzaInput[]
    createMany?: UserCreateManyIkohzaInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutIkohzaInput | UserUpdateWithWhereUniqueWithoutIkohzaInput[]
    updateMany?: UserUpdateManyWithWhereWithoutIkohzaInput | UserUpdateManyWithWhereWithoutIkohzaInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CompanyBranchCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCompanyRelationInput = {
    create?: XOR<UserCreateWithoutCompanyRelationInput, UserUncheckedCreateWithoutCompanyRelationInput> | UserCreateWithoutCompanyRelationInput[] | UserUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyRelationInput | UserCreateOrConnectWithoutCompanyRelationInput[]
    createMany?: UserCreateManyCompanyRelationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingRequestCreateNestedManyWithoutCompanyRelationInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyRelationInput, BookingRequestUncheckedCreateWithoutCompanyRelationInput> | BookingRequestCreateWithoutCompanyRelationInput[] | BookingRequestUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyRelationInput | BookingRequestCreateOrConnectWithoutCompanyRelationInput[]
    createMany?: BookingRequestCreateManyCompanyRelationInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type CompanyBranchUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyRelationInput = {
    create?: XOR<UserCreateWithoutCompanyRelationInput, UserUncheckedCreateWithoutCompanyRelationInput> | UserCreateWithoutCompanyRelationInput[] | UserUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyRelationInput | UserCreateOrConnectWithoutCompanyRelationInput[]
    createMany?: UserCreateManyCompanyRelationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingRequestUncheckedCreateNestedManyWithoutCompanyRelationInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyRelationInput, BookingRequestUncheckedCreateWithoutCompanyRelationInput> | BookingRequestCreateWithoutCompanyRelationInput[] | BookingRequestUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyRelationInput | BookingRequestCreateOrConnectWithoutCompanyRelationInput[]
    createMany?: BookingRequestCreateManyCompanyRelationInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type CompanyBranchUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput | CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    set?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    disconnect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    delete?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    update?: CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput | CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyBranchUpdateManyWithWhereWithoutCompanyInput | CompanyBranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCompanyRelationNestedInput = {
    create?: XOR<UserCreateWithoutCompanyRelationInput, UserUncheckedCreateWithoutCompanyRelationInput> | UserCreateWithoutCompanyRelationInput[] | UserUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyRelationInput | UserCreateOrConnectWithoutCompanyRelationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyRelationInput | UserUpsertWithWhereUniqueWithoutCompanyRelationInput[]
    createMany?: UserCreateManyCompanyRelationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyRelationInput | UserUpdateWithWhereUniqueWithoutCompanyRelationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyRelationInput | UserUpdateManyWithWhereWithoutCompanyRelationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingRequestUpdateManyWithoutCompanyRelationNestedInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyRelationInput, BookingRequestUncheckedCreateWithoutCompanyRelationInput> | BookingRequestCreateWithoutCompanyRelationInput[] | BookingRequestUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyRelationInput | BookingRequestCreateOrConnectWithoutCompanyRelationInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutCompanyRelationInput | BookingRequestUpsertWithWhereUniqueWithoutCompanyRelationInput[]
    createMany?: BookingRequestCreateManyCompanyRelationInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutCompanyRelationInput | BookingRequestUpdateWithWhereUniqueWithoutCompanyRelationInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutCompanyRelationInput | BookingRequestUpdateManyWithWhereWithoutCompanyRelationInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type CompanyBranchUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput> | CompanyBranchCreateWithoutCompanyInput[] | CompanyBranchUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutCompanyInput | CompanyBranchCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput | CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyBranchCreateManyCompanyInputEnvelope
    set?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    disconnect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    delete?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    connect?: CompanyBranchWhereUniqueInput | CompanyBranchWhereUniqueInput[]
    update?: CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput | CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyBranchUpdateManyWithWhereWithoutCompanyInput | CompanyBranchUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyRelationNestedInput = {
    create?: XOR<UserCreateWithoutCompanyRelationInput, UserUncheckedCreateWithoutCompanyRelationInput> | UserCreateWithoutCompanyRelationInput[] | UserUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyRelationInput | UserCreateOrConnectWithoutCompanyRelationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyRelationInput | UserUpsertWithWhereUniqueWithoutCompanyRelationInput[]
    createMany?: UserCreateManyCompanyRelationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyRelationInput | UserUpdateWithWhereUniqueWithoutCompanyRelationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyRelationInput | UserUpdateManyWithWhereWithoutCompanyRelationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingRequestUncheckedUpdateManyWithoutCompanyRelationNestedInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyRelationInput, BookingRequestUncheckedCreateWithoutCompanyRelationInput> | BookingRequestCreateWithoutCompanyRelationInput[] | BookingRequestUncheckedCreateWithoutCompanyRelationInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyRelationInput | BookingRequestCreateOrConnectWithoutCompanyRelationInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutCompanyRelationInput | BookingRequestUpsertWithWhereUniqueWithoutCompanyRelationInput[]
    createMany?: BookingRequestCreateManyCompanyRelationInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutCompanyRelationInput | BookingRequestUpdateWithWhereUniqueWithoutCompanyRelationInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutCompanyRelationInput | BookingRequestUpdateManyWithWhereWithoutCompanyRelationInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutBranchesInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCompanyBranchInput = {
    create?: XOR<UserCreateWithoutCompanyBranchInput, UserUncheckedCreateWithoutCompanyBranchInput> | UserCreateWithoutCompanyBranchInput[] | UserUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyBranchInput | UserCreateOrConnectWithoutCompanyBranchInput[]
    createMany?: UserCreateManyCompanyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingRequestCreateNestedManyWithoutCompanyBranchInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyBranchInput, BookingRequestUncheckedCreateWithoutCompanyBranchInput> | BookingRequestCreateWithoutCompanyBranchInput[] | BookingRequestUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyBranchInput | BookingRequestCreateOrConnectWithoutCompanyBranchInput[]
    createMany?: BookingRequestCreateManyCompanyBranchInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyBranchInput = {
    create?: XOR<UserCreateWithoutCompanyBranchInput, UserUncheckedCreateWithoutCompanyBranchInput> | UserCreateWithoutCompanyBranchInput[] | UserUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyBranchInput | UserCreateOrConnectWithoutCompanyBranchInput[]
    createMany?: UserCreateManyCompanyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingRequestUncheckedCreateNestedManyWithoutCompanyBranchInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyBranchInput, BookingRequestUncheckedCreateWithoutCompanyBranchInput> | BookingRequestCreateWithoutCompanyBranchInput[] | BookingRequestUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyBranchInput | BookingRequestCreateOrConnectWithoutCompanyBranchInput[]
    createMany?: BookingRequestCreateManyCompanyBranchInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBranchesInput
    upsert?: CompanyUpsertWithoutBranchesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBranchesInput, CompanyUpdateWithoutBranchesInput>, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type UserUpdateManyWithoutCompanyBranchNestedInput = {
    create?: XOR<UserCreateWithoutCompanyBranchInput, UserUncheckedCreateWithoutCompanyBranchInput> | UserCreateWithoutCompanyBranchInput[] | UserUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyBranchInput | UserCreateOrConnectWithoutCompanyBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyBranchInput | UserUpsertWithWhereUniqueWithoutCompanyBranchInput[]
    createMany?: UserCreateManyCompanyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyBranchInput | UserUpdateWithWhereUniqueWithoutCompanyBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyBranchInput | UserUpdateManyWithWhereWithoutCompanyBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingRequestUpdateManyWithoutCompanyBranchNestedInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyBranchInput, BookingRequestUncheckedCreateWithoutCompanyBranchInput> | BookingRequestCreateWithoutCompanyBranchInput[] | BookingRequestUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyBranchInput | BookingRequestCreateOrConnectWithoutCompanyBranchInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutCompanyBranchInput | BookingRequestUpsertWithWhereUniqueWithoutCompanyBranchInput[]
    createMany?: BookingRequestCreateManyCompanyBranchInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutCompanyBranchInput | BookingRequestUpdateWithWhereUniqueWithoutCompanyBranchInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutCompanyBranchInput | BookingRequestUpdateManyWithWhereWithoutCompanyBranchInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyBranchNestedInput = {
    create?: XOR<UserCreateWithoutCompanyBranchInput, UserUncheckedCreateWithoutCompanyBranchInput> | UserCreateWithoutCompanyBranchInput[] | UserUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyBranchInput | UserCreateOrConnectWithoutCompanyBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyBranchInput | UserUpsertWithWhereUniqueWithoutCompanyBranchInput[]
    createMany?: UserCreateManyCompanyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyBranchInput | UserUpdateWithWhereUniqueWithoutCompanyBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyBranchInput | UserUpdateManyWithWhereWithoutCompanyBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingRequestUncheckedUpdateManyWithoutCompanyBranchNestedInput = {
    create?: XOR<BookingRequestCreateWithoutCompanyBranchInput, BookingRequestUncheckedCreateWithoutCompanyBranchInput> | BookingRequestCreateWithoutCompanyBranchInput[] | BookingRequestUncheckedCreateWithoutCompanyBranchInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutCompanyBranchInput | BookingRequestCreateOrConnectWithoutCompanyBranchInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutCompanyBranchInput | BookingRequestUpsertWithWhereUniqueWithoutCompanyBranchInput[]
    createMany?: BookingRequestCreateManyCompanyBranchInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutCompanyBranchInput | BookingRequestUpdateWithWhereUniqueWithoutCompanyBranchInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutCompanyBranchInput | BookingRequestUpdateManyWithWhereWithoutCompanyBranchInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutUsersInput = {
    create?: XOR<FacultyCreateWithoutUsersInput, FacultyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutUsersInput
    connect?: FacultyWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type IkohzaCreateNestedOneWithoutUsersInput = {
    create?: XOR<IkohzaCreateWithoutUsersInput, IkohzaUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IkohzaCreateOrConnectWithoutUsersInput
    connect?: IkohzaWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyBranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyBranchCreateWithoutUsersInput, CompanyBranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutUsersInput
    connect?: CompanyBranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedUsersInput = {
    create?: XOR<UserCreateWithoutApprovedUsersInput, UserUncheckedCreateWithoutApprovedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<UserCreateWithoutApprovedByUserInput, UserUncheckedCreateWithoutApprovedByUserInput> | UserCreateWithoutApprovedByUserInput[] | UserUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutApprovedByUserInput | UserCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: UserCreateManyApprovedByUserInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuthProviderCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BookingRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingRequestCreateWithoutUserInput, BookingRequestUncheckedCreateWithoutUserInput> | BookingRequestCreateWithoutUserInput[] | BookingRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutUserInput | BookingRequestCreateOrConnectWithoutUserInput[]
    createMany?: BookingRequestCreateManyUserInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type BookingRequestCreateNestedManyWithoutReviewedByUserInput = {
    create?: XOR<BookingRequestCreateWithoutReviewedByUserInput, BookingRequestUncheckedCreateWithoutReviewedByUserInput> | BookingRequestCreateWithoutReviewedByUserInput[] | BookingRequestUncheckedCreateWithoutReviewedByUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutReviewedByUserInput | BookingRequestCreateOrConnectWithoutReviewedByUserInput[]
    createMany?: BookingRequestCreateManyReviewedByUserInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type ServiceFormCreateNestedManyWithoutGeneratedByUserInput = {
    create?: XOR<ServiceFormCreateWithoutGeneratedByUserInput, ServiceFormUncheckedCreateWithoutGeneratedByUserInput> | ServiceFormCreateWithoutGeneratedByUserInput[] | ServiceFormUncheckedCreateWithoutGeneratedByUserInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutGeneratedByUserInput | ServiceFormCreateOrConnectWithoutGeneratedByUserInput[]
    createMany?: ServiceFormCreateManyGeneratedByUserInputEnvelope
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUploadedByUserInput = {
    create?: XOR<InvoiceCreateWithoutUploadedByUserInput, InvoiceUncheckedCreateWithoutUploadedByUserInput> | InvoiceCreateWithoutUploadedByUserInput[] | InvoiceUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUploadedByUserInput | InvoiceCreateOrConnectWithoutUploadedByUserInput[]
    createMany?: InvoiceCreateManyUploadedByUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutVerifiedByUserInput = {
    create?: XOR<PaymentCreateWithoutVerifiedByUserInput, PaymentUncheckedCreateWithoutVerifiedByUserInput> | PaymentCreateWithoutVerifiedByUserInput[] | PaymentUncheckedCreateWithoutVerifiedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVerifiedByUserInput | PaymentCreateOrConnectWithoutVerifiedByUserInput[]
    createMany?: PaymentCreateManyVerifiedByUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AnalysisResultCreateNestedManyWithoutUploadedByUserInput = {
    create?: XOR<AnalysisResultCreateWithoutUploadedByUserInput, AnalysisResultUncheckedCreateWithoutUploadedByUserInput> | AnalysisResultCreateWithoutUploadedByUserInput[] | AnalysisResultUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutUploadedByUserInput | AnalysisResultCreateOrConnectWithoutUploadedByUserInput[]
    createMany?: AnalysisResultCreateManyUploadedByUserInputEnvelope
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SampleTrackingCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<SampleTrackingCreateWithoutUpdatedByUserInput, SampleTrackingUncheckedCreateWithoutUpdatedByUserInput> | SampleTrackingCreateWithoutUpdatedByUserInput[] | SampleTrackingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutUpdatedByUserInput | SampleTrackingCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: SampleTrackingCreateManyUpdatedByUserInputEnvelope
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
  }

  export type SampleModificationCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<SampleModificationCreateWithoutCreatedByUserInput, SampleModificationUncheckedCreateWithoutCreatedByUserInput> | SampleModificationCreateWithoutCreatedByUserInput[] | SampleModificationUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutCreatedByUserInput | SampleModificationCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: SampleModificationCreateManyCreatedByUserInputEnvelope
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
  }

  export type SampleModificationCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<SampleModificationCreateWithoutApprovedByUserInput, SampleModificationUncheckedCreateWithoutApprovedByUserInput> | SampleModificationCreateWithoutApprovedByUserInput[] | SampleModificationUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutApprovedByUserInput | SampleModificationCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: SampleModificationCreateManyApprovedByUserInputEnvelope
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUploadedByUserInput = {
    create?: XOR<PaymentCreateWithoutUploadedByUserInput, PaymentUncheckedCreateWithoutUploadedByUserInput> | PaymentCreateWithoutUploadedByUserInput[] | PaymentUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUploadedByUserInput | PaymentCreateOrConnectWithoutUploadedByUserInput[]
    createMany?: PaymentCreateManyUploadedByUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<UserCreateWithoutApprovedByUserInput, UserUncheckedCreateWithoutApprovedByUserInput> | UserCreateWithoutApprovedByUserInput[] | UserUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutApprovedByUserInput | UserCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: UserCreateManyApprovedByUserInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AuthProviderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BookingRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingRequestCreateWithoutUserInput, BookingRequestUncheckedCreateWithoutUserInput> | BookingRequestCreateWithoutUserInput[] | BookingRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutUserInput | BookingRequestCreateOrConnectWithoutUserInput[]
    createMany?: BookingRequestCreateManyUserInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput = {
    create?: XOR<BookingRequestCreateWithoutReviewedByUserInput, BookingRequestUncheckedCreateWithoutReviewedByUserInput> | BookingRequestCreateWithoutReviewedByUserInput[] | BookingRequestUncheckedCreateWithoutReviewedByUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutReviewedByUserInput | BookingRequestCreateOrConnectWithoutReviewedByUserInput[]
    createMany?: BookingRequestCreateManyReviewedByUserInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput = {
    create?: XOR<ServiceFormCreateWithoutGeneratedByUserInput, ServiceFormUncheckedCreateWithoutGeneratedByUserInput> | ServiceFormCreateWithoutGeneratedByUserInput[] | ServiceFormUncheckedCreateWithoutGeneratedByUserInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutGeneratedByUserInput | ServiceFormCreateOrConnectWithoutGeneratedByUserInput[]
    createMany?: ServiceFormCreateManyGeneratedByUserInputEnvelope
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput = {
    create?: XOR<InvoiceCreateWithoutUploadedByUserInput, InvoiceUncheckedCreateWithoutUploadedByUserInput> | InvoiceCreateWithoutUploadedByUserInput[] | InvoiceUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUploadedByUserInput | InvoiceCreateOrConnectWithoutUploadedByUserInput[]
    createMany?: InvoiceCreateManyUploadedByUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput = {
    create?: XOR<PaymentCreateWithoutVerifiedByUserInput, PaymentUncheckedCreateWithoutVerifiedByUserInput> | PaymentCreateWithoutVerifiedByUserInput[] | PaymentUncheckedCreateWithoutVerifiedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVerifiedByUserInput | PaymentCreateOrConnectWithoutVerifiedByUserInput[]
    createMany?: PaymentCreateManyVerifiedByUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput = {
    create?: XOR<AnalysisResultCreateWithoutUploadedByUserInput, AnalysisResultUncheckedCreateWithoutUploadedByUserInput> | AnalysisResultCreateWithoutUploadedByUserInput[] | AnalysisResultUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutUploadedByUserInput | AnalysisResultCreateOrConnectWithoutUploadedByUserInput[]
    createMany?: AnalysisResultCreateManyUploadedByUserInputEnvelope
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<SampleTrackingCreateWithoutUpdatedByUserInput, SampleTrackingUncheckedCreateWithoutUpdatedByUserInput> | SampleTrackingCreateWithoutUpdatedByUserInput[] | SampleTrackingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutUpdatedByUserInput | SampleTrackingCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: SampleTrackingCreateManyUpdatedByUserInputEnvelope
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
  }

  export type SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<SampleModificationCreateWithoutCreatedByUserInput, SampleModificationUncheckedCreateWithoutCreatedByUserInput> | SampleModificationCreateWithoutCreatedByUserInput[] | SampleModificationUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutCreatedByUserInput | SampleModificationCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: SampleModificationCreateManyCreatedByUserInputEnvelope
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
  }

  export type SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<SampleModificationCreateWithoutApprovedByUserInput, SampleModificationUncheckedCreateWithoutApprovedByUserInput> | SampleModificationCreateWithoutApprovedByUserInput[] | SampleModificationUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutApprovedByUserInput | SampleModificationCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: SampleModificationCreateManyApprovedByUserInputEnvelope
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput = {
    create?: XOR<PaymentCreateWithoutUploadedByUserInput, PaymentUncheckedCreateWithoutUploadedByUserInput> | PaymentCreateWithoutUploadedByUserInput[] | PaymentUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUploadedByUserInput | PaymentCreateOrConnectWithoutUploadedByUserInput[]
    createMany?: PaymentCreateManyUploadedByUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type Enumuser_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.user_type_enum
  }

  export type Enumuser_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.user_status_enum
  }

  export type Enumacademic_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.academic_type_enum
  }

  export type NullableEnumUTMFieldUpdateOperationsInput = {
    set?: $Enums.UTM | null
  }

  export type FacultyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<FacultyCreateWithoutUsersInput, FacultyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutUsersInput
    upsert?: FacultyUpsertWithoutUsersInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutUsersInput, FacultyUpdateWithoutUsersInput>, FacultyUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type IkohzaUpdateOneWithoutUsersNestedInput = {
    create?: XOR<IkohzaCreateWithoutUsersInput, IkohzaUncheckedCreateWithoutUsersInput>
    connectOrCreate?: IkohzaCreateOrConnectWithoutUsersInput
    upsert?: IkohzaUpsertWithoutUsersInput
    disconnect?: IkohzaWhereInput | boolean
    delete?: IkohzaWhereInput | boolean
    connect?: IkohzaWhereUniqueInput
    update?: XOR<XOR<IkohzaUpdateToOneWithWhereWithoutUsersInput, IkohzaUpdateWithoutUsersInput>, IkohzaUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyBranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyBranchCreateWithoutUsersInput, CompanyBranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutUsersInput
    upsert?: CompanyBranchUpsertWithoutUsersInput
    disconnect?: CompanyBranchWhereInput | boolean
    delete?: CompanyBranchWhereInput | boolean
    connect?: CompanyBranchWhereUniqueInput
    update?: XOR<XOR<CompanyBranchUpdateToOneWithWhereWithoutUsersInput, CompanyBranchUpdateWithoutUsersInput>, CompanyBranchUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutApprovedUsersNestedInput = {
    create?: XOR<UserCreateWithoutApprovedUsersInput, UserUncheckedCreateWithoutApprovedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedUsersInput
    upsert?: UserUpsertWithoutApprovedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedUsersInput, UserUpdateWithoutApprovedUsersInput>, UserUncheckedUpdateWithoutApprovedUsersInput>
  }

  export type UserUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<UserCreateWithoutApprovedByUserInput, UserUncheckedCreateWithoutApprovedByUserInput> | UserCreateWithoutApprovedByUserInput[] | UserUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutApprovedByUserInput | UserCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutApprovedByUserInput | UserUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: UserCreateManyApprovedByUserInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutApprovedByUserInput | UserUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: UserUpdateManyWithWhereWithoutApprovedByUserInput | UserUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuthProviderUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    upsert?: AuthProviderUpsertWithWhereUniqueWithoutUserInput | AuthProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    set?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    disconnect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    delete?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    update?: AuthProviderUpdateWithWhereUniqueWithoutUserInput | AuthProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthProviderUpdateManyWithWhereWithoutUserInput | AuthProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BookingRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingRequestCreateWithoutUserInput, BookingRequestUncheckedCreateWithoutUserInput> | BookingRequestCreateWithoutUserInput[] | BookingRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutUserInput | BookingRequestCreateOrConnectWithoutUserInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutUserInput | BookingRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingRequestCreateManyUserInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutUserInput | BookingRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutUserInput | BookingRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type BookingRequestUpdateManyWithoutReviewedByUserNestedInput = {
    create?: XOR<BookingRequestCreateWithoutReviewedByUserInput, BookingRequestUncheckedCreateWithoutReviewedByUserInput> | BookingRequestCreateWithoutReviewedByUserInput[] | BookingRequestUncheckedCreateWithoutReviewedByUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutReviewedByUserInput | BookingRequestCreateOrConnectWithoutReviewedByUserInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutReviewedByUserInput | BookingRequestUpsertWithWhereUniqueWithoutReviewedByUserInput[]
    createMany?: BookingRequestCreateManyReviewedByUserInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutReviewedByUserInput | BookingRequestUpdateWithWhereUniqueWithoutReviewedByUserInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutReviewedByUserInput | BookingRequestUpdateManyWithWhereWithoutReviewedByUserInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type ServiceFormUpdateManyWithoutGeneratedByUserNestedInput = {
    create?: XOR<ServiceFormCreateWithoutGeneratedByUserInput, ServiceFormUncheckedCreateWithoutGeneratedByUserInput> | ServiceFormCreateWithoutGeneratedByUserInput[] | ServiceFormUncheckedCreateWithoutGeneratedByUserInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutGeneratedByUserInput | ServiceFormCreateOrConnectWithoutGeneratedByUserInput[]
    upsert?: ServiceFormUpsertWithWhereUniqueWithoutGeneratedByUserInput | ServiceFormUpsertWithWhereUniqueWithoutGeneratedByUserInput[]
    createMany?: ServiceFormCreateManyGeneratedByUserInputEnvelope
    set?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    disconnect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    delete?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    update?: ServiceFormUpdateWithWhereUniqueWithoutGeneratedByUserInput | ServiceFormUpdateWithWhereUniqueWithoutGeneratedByUserInput[]
    updateMany?: ServiceFormUpdateManyWithWhereWithoutGeneratedByUserInput | ServiceFormUpdateManyWithWhereWithoutGeneratedByUserInput[]
    deleteMany?: ServiceFormScalarWhereInput | ServiceFormScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUploadedByUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUploadedByUserInput, InvoiceUncheckedCreateWithoutUploadedByUserInput> | InvoiceCreateWithoutUploadedByUserInput[] | InvoiceUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUploadedByUserInput | InvoiceCreateOrConnectWithoutUploadedByUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUploadedByUserInput | InvoiceUpsertWithWhereUniqueWithoutUploadedByUserInput[]
    createMany?: InvoiceCreateManyUploadedByUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUploadedByUserInput | InvoiceUpdateWithWhereUniqueWithoutUploadedByUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUploadedByUserInput | InvoiceUpdateManyWithWhereWithoutUploadedByUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutVerifiedByUserNestedInput = {
    create?: XOR<PaymentCreateWithoutVerifiedByUserInput, PaymentUncheckedCreateWithoutVerifiedByUserInput> | PaymentCreateWithoutVerifiedByUserInput[] | PaymentUncheckedCreateWithoutVerifiedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVerifiedByUserInput | PaymentCreateOrConnectWithoutVerifiedByUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutVerifiedByUserInput | PaymentUpsertWithWhereUniqueWithoutVerifiedByUserInput[]
    createMany?: PaymentCreateManyVerifiedByUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutVerifiedByUserInput | PaymentUpdateWithWhereUniqueWithoutVerifiedByUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutVerifiedByUserInput | PaymentUpdateManyWithWhereWithoutVerifiedByUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AnalysisResultUpdateManyWithoutUploadedByUserNestedInput = {
    create?: XOR<AnalysisResultCreateWithoutUploadedByUserInput, AnalysisResultUncheckedCreateWithoutUploadedByUserInput> | AnalysisResultCreateWithoutUploadedByUserInput[] | AnalysisResultUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutUploadedByUserInput | AnalysisResultCreateOrConnectWithoutUploadedByUserInput[]
    upsert?: AnalysisResultUpsertWithWhereUniqueWithoutUploadedByUserInput | AnalysisResultUpsertWithWhereUniqueWithoutUploadedByUserInput[]
    createMany?: AnalysisResultCreateManyUploadedByUserInputEnvelope
    set?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    disconnect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    delete?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    update?: AnalysisResultUpdateWithWhereUniqueWithoutUploadedByUserInput | AnalysisResultUpdateWithWhereUniqueWithoutUploadedByUserInput[]
    updateMany?: AnalysisResultUpdateManyWithWhereWithoutUploadedByUserInput | AnalysisResultUpdateManyWithWhereWithoutUploadedByUserInput[]
    deleteMany?: AnalysisResultScalarWhereInput | AnalysisResultScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<SampleTrackingCreateWithoutUpdatedByUserInput, SampleTrackingUncheckedCreateWithoutUpdatedByUserInput> | SampleTrackingCreateWithoutUpdatedByUserInput[] | SampleTrackingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutUpdatedByUserInput | SampleTrackingCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: SampleTrackingUpsertWithWhereUniqueWithoutUpdatedByUserInput | SampleTrackingUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: SampleTrackingCreateManyUpdatedByUserInputEnvelope
    set?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    disconnect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    delete?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    update?: SampleTrackingUpdateWithWhereUniqueWithoutUpdatedByUserInput | SampleTrackingUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: SampleTrackingUpdateManyWithWhereWithoutUpdatedByUserInput | SampleTrackingUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: SampleTrackingScalarWhereInput | SampleTrackingScalarWhereInput[]
  }

  export type SampleModificationUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<SampleModificationCreateWithoutCreatedByUserInput, SampleModificationUncheckedCreateWithoutCreatedByUserInput> | SampleModificationCreateWithoutCreatedByUserInput[] | SampleModificationUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutCreatedByUserInput | SampleModificationCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: SampleModificationUpsertWithWhereUniqueWithoutCreatedByUserInput | SampleModificationUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: SampleModificationCreateManyCreatedByUserInputEnvelope
    set?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    disconnect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    delete?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    update?: SampleModificationUpdateWithWhereUniqueWithoutCreatedByUserInput | SampleModificationUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: SampleModificationUpdateManyWithWhereWithoutCreatedByUserInput | SampleModificationUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
  }

  export type SampleModificationUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<SampleModificationCreateWithoutApprovedByUserInput, SampleModificationUncheckedCreateWithoutApprovedByUserInput> | SampleModificationCreateWithoutApprovedByUserInput[] | SampleModificationUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutApprovedByUserInput | SampleModificationCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: SampleModificationUpsertWithWhereUniqueWithoutApprovedByUserInput | SampleModificationUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: SampleModificationCreateManyApprovedByUserInputEnvelope
    set?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    disconnect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    delete?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    update?: SampleModificationUpdateWithWhereUniqueWithoutApprovedByUserInput | SampleModificationUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: SampleModificationUpdateManyWithWhereWithoutApprovedByUserInput | SampleModificationUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUploadedByUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUploadedByUserInput, PaymentUncheckedCreateWithoutUploadedByUserInput> | PaymentCreateWithoutUploadedByUserInput[] | PaymentUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUploadedByUserInput | PaymentCreateOrConnectWithoutUploadedByUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUploadedByUserInput | PaymentUpsertWithWhereUniqueWithoutUploadedByUserInput[]
    createMany?: PaymentCreateManyUploadedByUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUploadedByUserInput | PaymentUpdateWithWhereUniqueWithoutUploadedByUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUploadedByUserInput | PaymentUpdateManyWithWhereWithoutUploadedByUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<UserCreateWithoutApprovedByUserInput, UserUncheckedCreateWithoutApprovedByUserInput> | UserCreateWithoutApprovedByUserInput[] | UserUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutApprovedByUserInput | UserCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutApprovedByUserInput | UserUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: UserCreateManyApprovedByUserInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutApprovedByUserInput | UserUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: UserUpdateManyWithWhereWithoutApprovedByUserInput | UserUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AuthProviderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    upsert?: AuthProviderUpsertWithWhereUniqueWithoutUserInput | AuthProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    set?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    disconnect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    delete?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    update?: AuthProviderUpdateWithWhereUniqueWithoutUserInput | AuthProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthProviderUpdateManyWithWhereWithoutUserInput | AuthProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BookingRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingRequestCreateWithoutUserInput, BookingRequestUncheckedCreateWithoutUserInput> | BookingRequestCreateWithoutUserInput[] | BookingRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutUserInput | BookingRequestCreateOrConnectWithoutUserInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutUserInput | BookingRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingRequestCreateManyUserInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutUserInput | BookingRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutUserInput | BookingRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput = {
    create?: XOR<BookingRequestCreateWithoutReviewedByUserInput, BookingRequestUncheckedCreateWithoutReviewedByUserInput> | BookingRequestCreateWithoutReviewedByUserInput[] | BookingRequestUncheckedCreateWithoutReviewedByUserInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutReviewedByUserInput | BookingRequestCreateOrConnectWithoutReviewedByUserInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutReviewedByUserInput | BookingRequestUpsertWithWhereUniqueWithoutReviewedByUserInput[]
    createMany?: BookingRequestCreateManyReviewedByUserInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutReviewedByUserInput | BookingRequestUpdateWithWhereUniqueWithoutReviewedByUserInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutReviewedByUserInput | BookingRequestUpdateManyWithWhereWithoutReviewedByUserInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput = {
    create?: XOR<ServiceFormCreateWithoutGeneratedByUserInput, ServiceFormUncheckedCreateWithoutGeneratedByUserInput> | ServiceFormCreateWithoutGeneratedByUserInput[] | ServiceFormUncheckedCreateWithoutGeneratedByUserInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutGeneratedByUserInput | ServiceFormCreateOrConnectWithoutGeneratedByUserInput[]
    upsert?: ServiceFormUpsertWithWhereUniqueWithoutGeneratedByUserInput | ServiceFormUpsertWithWhereUniqueWithoutGeneratedByUserInput[]
    createMany?: ServiceFormCreateManyGeneratedByUserInputEnvelope
    set?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    disconnect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    delete?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    update?: ServiceFormUpdateWithWhereUniqueWithoutGeneratedByUserInput | ServiceFormUpdateWithWhereUniqueWithoutGeneratedByUserInput[]
    updateMany?: ServiceFormUpdateManyWithWhereWithoutGeneratedByUserInput | ServiceFormUpdateManyWithWhereWithoutGeneratedByUserInput[]
    deleteMany?: ServiceFormScalarWhereInput | ServiceFormScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUploadedByUserInput, InvoiceUncheckedCreateWithoutUploadedByUserInput> | InvoiceCreateWithoutUploadedByUserInput[] | InvoiceUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUploadedByUserInput | InvoiceCreateOrConnectWithoutUploadedByUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUploadedByUserInput | InvoiceUpsertWithWhereUniqueWithoutUploadedByUserInput[]
    createMany?: InvoiceCreateManyUploadedByUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUploadedByUserInput | InvoiceUpdateWithWhereUniqueWithoutUploadedByUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUploadedByUserInput | InvoiceUpdateManyWithWhereWithoutUploadedByUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput = {
    create?: XOR<PaymentCreateWithoutVerifiedByUserInput, PaymentUncheckedCreateWithoutVerifiedByUserInput> | PaymentCreateWithoutVerifiedByUserInput[] | PaymentUncheckedCreateWithoutVerifiedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutVerifiedByUserInput | PaymentCreateOrConnectWithoutVerifiedByUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutVerifiedByUserInput | PaymentUpsertWithWhereUniqueWithoutVerifiedByUserInput[]
    createMany?: PaymentCreateManyVerifiedByUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutVerifiedByUserInput | PaymentUpdateWithWhereUniqueWithoutVerifiedByUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutVerifiedByUserInput | PaymentUpdateManyWithWhereWithoutVerifiedByUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput = {
    create?: XOR<AnalysisResultCreateWithoutUploadedByUserInput, AnalysisResultUncheckedCreateWithoutUploadedByUserInput> | AnalysisResultCreateWithoutUploadedByUserInput[] | AnalysisResultUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutUploadedByUserInput | AnalysisResultCreateOrConnectWithoutUploadedByUserInput[]
    upsert?: AnalysisResultUpsertWithWhereUniqueWithoutUploadedByUserInput | AnalysisResultUpsertWithWhereUniqueWithoutUploadedByUserInput[]
    createMany?: AnalysisResultCreateManyUploadedByUserInputEnvelope
    set?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    disconnect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    delete?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    update?: AnalysisResultUpdateWithWhereUniqueWithoutUploadedByUserInput | AnalysisResultUpdateWithWhereUniqueWithoutUploadedByUserInput[]
    updateMany?: AnalysisResultUpdateManyWithWhereWithoutUploadedByUserInput | AnalysisResultUpdateManyWithWhereWithoutUploadedByUserInput[]
    deleteMany?: AnalysisResultScalarWhereInput | AnalysisResultScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<SampleTrackingCreateWithoutUpdatedByUserInput, SampleTrackingUncheckedCreateWithoutUpdatedByUserInput> | SampleTrackingCreateWithoutUpdatedByUserInput[] | SampleTrackingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutUpdatedByUserInput | SampleTrackingCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: SampleTrackingUpsertWithWhereUniqueWithoutUpdatedByUserInput | SampleTrackingUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: SampleTrackingCreateManyUpdatedByUserInputEnvelope
    set?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    disconnect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    delete?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    update?: SampleTrackingUpdateWithWhereUniqueWithoutUpdatedByUserInput | SampleTrackingUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: SampleTrackingUpdateManyWithWhereWithoutUpdatedByUserInput | SampleTrackingUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: SampleTrackingScalarWhereInput | SampleTrackingScalarWhereInput[]
  }

  export type SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<SampleModificationCreateWithoutCreatedByUserInput, SampleModificationUncheckedCreateWithoutCreatedByUserInput> | SampleModificationCreateWithoutCreatedByUserInput[] | SampleModificationUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutCreatedByUserInput | SampleModificationCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: SampleModificationUpsertWithWhereUniqueWithoutCreatedByUserInput | SampleModificationUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: SampleModificationCreateManyCreatedByUserInputEnvelope
    set?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    disconnect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    delete?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    update?: SampleModificationUpdateWithWhereUniqueWithoutCreatedByUserInput | SampleModificationUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: SampleModificationUpdateManyWithWhereWithoutCreatedByUserInput | SampleModificationUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
  }

  export type SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<SampleModificationCreateWithoutApprovedByUserInput, SampleModificationUncheckedCreateWithoutApprovedByUserInput> | SampleModificationCreateWithoutApprovedByUserInput[] | SampleModificationUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutApprovedByUserInput | SampleModificationCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: SampleModificationUpsertWithWhereUniqueWithoutApprovedByUserInput | SampleModificationUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: SampleModificationCreateManyApprovedByUserInputEnvelope
    set?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    disconnect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    delete?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    update?: SampleModificationUpdateWithWhereUniqueWithoutApprovedByUserInput | SampleModificationUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: SampleModificationUpdateManyWithWhereWithoutApprovedByUserInput | SampleModificationUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUploadedByUserInput, PaymentUncheckedCreateWithoutUploadedByUserInput> | PaymentCreateWithoutUploadedByUserInput[] | PaymentUncheckedCreateWithoutUploadedByUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUploadedByUserInput | PaymentCreateOrConnectWithoutUploadedByUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUploadedByUserInput | PaymentUpsertWithWhereUniqueWithoutUploadedByUserInput[]
    createMany?: PaymentCreateManyUploadedByUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUploadedByUserInput | PaymentUpdateWithWhereUniqueWithoutUploadedByUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUploadedByUserInput | PaymentUpdateManyWithWhereWithoutUploadedByUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuthProvidersInput = {
    create?: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthProvidersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthProvidersNestedInput = {
    create?: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthProvidersInput
    upsert?: UserUpsertWithoutAuthProvidersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthProvidersInput, UserUpdateWithoutAuthProvidersInput>, UserUncheckedUpdateWithoutAuthProvidersInput>
  }

  export type ServicePricingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePricingCreateWithoutServiceInput, ServicePricingUncheckedCreateWithoutServiceInput> | ServicePricingCreateWithoutServiceInput[] | ServicePricingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingCreateOrConnectWithoutServiceInput | ServicePricingCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePricingCreateManyServiceInputEnvelope
    connect?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
  }

  export type BookingServiceItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceItemCreateWithoutServiceInput, BookingServiceItemUncheckedCreateWithoutServiceInput> | BookingServiceItemCreateWithoutServiceInput[] | BookingServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutServiceInput | BookingServiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceItemCreateManyServiceInputEnvelope
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
  }

  export type ServiceAddOnMappingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutServiceInput, ServiceAddOnMappingUncheckedCreateWithoutServiceInput> | ServiceAddOnMappingCreateWithoutServiceInput[] | ServiceAddOnMappingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutServiceInput | ServiceAddOnMappingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceAddOnMappingCreateManyServiceInputEnvelope
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
  }

  export type ServicePricingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePricingCreateWithoutServiceInput, ServicePricingUncheckedCreateWithoutServiceInput> | ServicePricingCreateWithoutServiceInput[] | ServicePricingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingCreateOrConnectWithoutServiceInput | ServicePricingCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePricingCreateManyServiceInputEnvelope
    connect?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
  }

  export type BookingServiceItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceItemCreateWithoutServiceInput, BookingServiceItemUncheckedCreateWithoutServiceInput> | BookingServiceItemCreateWithoutServiceInput[] | BookingServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutServiceInput | BookingServiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceItemCreateManyServiceInputEnvelope
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
  }

  export type ServiceAddOnMappingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutServiceInput, ServiceAddOnMappingUncheckedCreateWithoutServiceInput> | ServiceAddOnMappingCreateWithoutServiceInput[] | ServiceAddOnMappingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutServiceInput | ServiceAddOnMappingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceAddOnMappingCreateManyServiceInputEnvelope
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
  }

  export type Enumservice_category_enumFieldUpdateOperationsInput = {
    set?: $Enums.service_category_enum
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ServicePricingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePricingCreateWithoutServiceInput, ServicePricingUncheckedCreateWithoutServiceInput> | ServicePricingCreateWithoutServiceInput[] | ServicePricingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingCreateOrConnectWithoutServiceInput | ServicePricingCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePricingUpsertWithWhereUniqueWithoutServiceInput | ServicePricingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePricingCreateManyServiceInputEnvelope
    set?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    disconnect?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    delete?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    connect?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    update?: ServicePricingUpdateWithWhereUniqueWithoutServiceInput | ServicePricingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePricingUpdateManyWithWhereWithoutServiceInput | ServicePricingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePricingScalarWhereInput | ServicePricingScalarWhereInput[]
  }

  export type BookingServiceItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutServiceInput, BookingServiceItemUncheckedCreateWithoutServiceInput> | BookingServiceItemCreateWithoutServiceInput[] | BookingServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutServiceInput | BookingServiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceItemUpsertWithWhereUniqueWithoutServiceInput | BookingServiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceItemCreateManyServiceInputEnvelope
    set?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    disconnect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    delete?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    update?: BookingServiceItemUpdateWithWhereUniqueWithoutServiceInput | BookingServiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceItemUpdateManyWithWhereWithoutServiceInput | BookingServiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceItemScalarWhereInput | BookingServiceItemScalarWhereInput[]
  }

  export type ServiceAddOnMappingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutServiceInput, ServiceAddOnMappingUncheckedCreateWithoutServiceInput> | ServiceAddOnMappingCreateWithoutServiceInput[] | ServiceAddOnMappingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutServiceInput | ServiceAddOnMappingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceAddOnMappingUpsertWithWhereUniqueWithoutServiceInput | ServiceAddOnMappingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceAddOnMappingCreateManyServiceInputEnvelope
    set?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    disconnect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    delete?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    update?: ServiceAddOnMappingUpdateWithWhereUniqueWithoutServiceInput | ServiceAddOnMappingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceAddOnMappingUpdateManyWithWhereWithoutServiceInput | ServiceAddOnMappingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceAddOnMappingScalarWhereInput | ServiceAddOnMappingScalarWhereInput[]
  }

  export type ServicePricingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePricingCreateWithoutServiceInput, ServicePricingUncheckedCreateWithoutServiceInput> | ServicePricingCreateWithoutServiceInput[] | ServicePricingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingCreateOrConnectWithoutServiceInput | ServicePricingCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePricingUpsertWithWhereUniqueWithoutServiceInput | ServicePricingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePricingCreateManyServiceInputEnvelope
    set?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    disconnect?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    delete?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    connect?: ServicePricingWhereUniqueInput | ServicePricingWhereUniqueInput[]
    update?: ServicePricingUpdateWithWhereUniqueWithoutServiceInput | ServicePricingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePricingUpdateManyWithWhereWithoutServiceInput | ServicePricingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePricingScalarWhereInput | ServicePricingScalarWhereInput[]
  }

  export type BookingServiceItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutServiceInput, BookingServiceItemUncheckedCreateWithoutServiceInput> | BookingServiceItemCreateWithoutServiceInput[] | BookingServiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutServiceInput | BookingServiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceItemUpsertWithWhereUniqueWithoutServiceInput | BookingServiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceItemCreateManyServiceInputEnvelope
    set?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    disconnect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    delete?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    update?: BookingServiceItemUpdateWithWhereUniqueWithoutServiceInput | BookingServiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceItemUpdateManyWithWhereWithoutServiceInput | BookingServiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceItemScalarWhereInput | BookingServiceItemScalarWhereInput[]
  }

  export type ServiceAddOnMappingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutServiceInput, ServiceAddOnMappingUncheckedCreateWithoutServiceInput> | ServiceAddOnMappingCreateWithoutServiceInput[] | ServiceAddOnMappingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutServiceInput | ServiceAddOnMappingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceAddOnMappingUpsertWithWhereUniqueWithoutServiceInput | ServiceAddOnMappingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceAddOnMappingCreateManyServiceInputEnvelope
    set?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    disconnect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    delete?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    update?: ServiceAddOnMappingUpdateWithWhereUniqueWithoutServiceInput | ServiceAddOnMappingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceAddOnMappingUpdateManyWithWhereWithoutServiceInput | ServiceAddOnMappingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceAddOnMappingScalarWhereInput | ServiceAddOnMappingScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutPricingInput = {
    create?: XOR<ServiceCreateWithoutPricingInput, ServiceUncheckedCreateWithoutPricingInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPricingInput
    connect?: ServiceWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ServiceUpdateOneRequiredWithoutPricingNestedInput = {
    create?: XOR<ServiceCreateWithoutPricingInput, ServiceUncheckedCreateWithoutPricingInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPricingInput
    upsert?: ServiceUpsertWithoutPricingInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPricingInput, ServiceUpdateWithoutPricingInput>, ServiceUncheckedUpdateWithoutPricingInput>
  }

  export type UserCreateNestedOneWithoutBookingRequestsInput = {
    create?: XOR<UserCreateWithoutBookingRequestsInput, UserUncheckedCreateWithoutBookingRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedBookingsInput = {
    create?: XOR<UserCreateWithoutApprovedBookingsInput, UserUncheckedCreateWithoutApprovedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutBookingsInput = {
    create?: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBookingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyBranchCreateNestedOneWithoutBookingsInput = {
    create?: XOR<CompanyBranchCreateWithoutBookingsInput, CompanyBranchUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutBookingsInput
    connect?: CompanyBranchWhereUniqueInput
  }

  export type BookingServiceItemCreateNestedManyWithoutBookingRequestInput = {
    create?: XOR<BookingServiceItemCreateWithoutBookingRequestInput, BookingServiceItemUncheckedCreateWithoutBookingRequestInput> | BookingServiceItemCreateWithoutBookingRequestInput[] | BookingServiceItemUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutBookingRequestInput | BookingServiceItemCreateOrConnectWithoutBookingRequestInput[]
    createMany?: BookingServiceItemCreateManyBookingRequestInputEnvelope
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
  }

  export type WorkspaceBookingCreateNestedManyWithoutBookingRequestInput = {
    create?: XOR<WorkspaceBookingCreateWithoutBookingRequestInput, WorkspaceBookingUncheckedCreateWithoutBookingRequestInput> | WorkspaceBookingCreateWithoutBookingRequestInput[] | WorkspaceBookingUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutBookingRequestInput | WorkspaceBookingCreateOrConnectWithoutBookingRequestInput[]
    createMany?: WorkspaceBookingCreateManyBookingRequestInputEnvelope
    connect?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
  }

  export type ServiceFormCreateNestedManyWithoutBookingRequestInput = {
    create?: XOR<ServiceFormCreateWithoutBookingRequestInput, ServiceFormUncheckedCreateWithoutBookingRequestInput> | ServiceFormCreateWithoutBookingRequestInput[] | ServiceFormUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutBookingRequestInput | ServiceFormCreateOrConnectWithoutBookingRequestInput[]
    createMany?: ServiceFormCreateManyBookingRequestInputEnvelope
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
  }

  export type BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput = {
    create?: XOR<BookingServiceItemCreateWithoutBookingRequestInput, BookingServiceItemUncheckedCreateWithoutBookingRequestInput> | BookingServiceItemCreateWithoutBookingRequestInput[] | BookingServiceItemUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutBookingRequestInput | BookingServiceItemCreateOrConnectWithoutBookingRequestInput[]
    createMany?: BookingServiceItemCreateManyBookingRequestInputEnvelope
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
  }

  export type WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput = {
    create?: XOR<WorkspaceBookingCreateWithoutBookingRequestInput, WorkspaceBookingUncheckedCreateWithoutBookingRequestInput> | WorkspaceBookingCreateWithoutBookingRequestInput[] | WorkspaceBookingUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutBookingRequestInput | WorkspaceBookingCreateOrConnectWithoutBookingRequestInput[]
    createMany?: WorkspaceBookingCreateManyBookingRequestInputEnvelope
    connect?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
  }

  export type ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput = {
    create?: XOR<ServiceFormCreateWithoutBookingRequestInput, ServiceFormUncheckedCreateWithoutBookingRequestInput> | ServiceFormCreateWithoutBookingRequestInput[] | ServiceFormUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutBookingRequestInput | ServiceFormCreateOrConnectWithoutBookingRequestInput[]
    createMany?: ServiceFormCreateManyBookingRequestInputEnvelope
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
  }

  export type Enumbooking_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.booking_status_enum
  }

  export type UserUpdateOneRequiredWithoutBookingRequestsNestedInput = {
    create?: XOR<UserCreateWithoutBookingRequestsInput, UserUncheckedCreateWithoutBookingRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingRequestsInput
    upsert?: UserUpsertWithoutBookingRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingRequestsInput, UserUpdateWithoutBookingRequestsInput>, UserUncheckedUpdateWithoutBookingRequestsInput>
  }

  export type UserUpdateOneWithoutApprovedBookingsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedBookingsInput, UserUncheckedCreateWithoutApprovedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedBookingsInput
    upsert?: UserUpsertWithoutApprovedBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedBookingsInput, UserUpdateWithoutApprovedBookingsInput>, UserUncheckedUpdateWithoutApprovedBookingsInput>
  }

  export type CompanyUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBookingsInput
    upsert?: CompanyUpsertWithoutBookingsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBookingsInput, CompanyUpdateWithoutBookingsInput>, CompanyUncheckedUpdateWithoutBookingsInput>
  }

  export type CompanyBranchUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<CompanyBranchCreateWithoutBookingsInput, CompanyBranchUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CompanyBranchCreateOrConnectWithoutBookingsInput
    upsert?: CompanyBranchUpsertWithoutBookingsInput
    disconnect?: CompanyBranchWhereInput | boolean
    delete?: CompanyBranchWhereInput | boolean
    connect?: CompanyBranchWhereUniqueInput
    update?: XOR<XOR<CompanyBranchUpdateToOneWithWhereWithoutBookingsInput, CompanyBranchUpdateWithoutBookingsInput>, CompanyBranchUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingServiceItemUpdateManyWithoutBookingRequestNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutBookingRequestInput, BookingServiceItemUncheckedCreateWithoutBookingRequestInput> | BookingServiceItemCreateWithoutBookingRequestInput[] | BookingServiceItemUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutBookingRequestInput | BookingServiceItemCreateOrConnectWithoutBookingRequestInput[]
    upsert?: BookingServiceItemUpsertWithWhereUniqueWithoutBookingRequestInput | BookingServiceItemUpsertWithWhereUniqueWithoutBookingRequestInput[]
    createMany?: BookingServiceItemCreateManyBookingRequestInputEnvelope
    set?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    disconnect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    delete?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    update?: BookingServiceItemUpdateWithWhereUniqueWithoutBookingRequestInput | BookingServiceItemUpdateWithWhereUniqueWithoutBookingRequestInput[]
    updateMany?: BookingServiceItemUpdateManyWithWhereWithoutBookingRequestInput | BookingServiceItemUpdateManyWithWhereWithoutBookingRequestInput[]
    deleteMany?: BookingServiceItemScalarWhereInput | BookingServiceItemScalarWhereInput[]
  }

  export type WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput = {
    create?: XOR<WorkspaceBookingCreateWithoutBookingRequestInput, WorkspaceBookingUncheckedCreateWithoutBookingRequestInput> | WorkspaceBookingCreateWithoutBookingRequestInput[] | WorkspaceBookingUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutBookingRequestInput | WorkspaceBookingCreateOrConnectWithoutBookingRequestInput[]
    upsert?: WorkspaceBookingUpsertWithWhereUniqueWithoutBookingRequestInput | WorkspaceBookingUpsertWithWhereUniqueWithoutBookingRequestInput[]
    createMany?: WorkspaceBookingCreateManyBookingRequestInputEnvelope
    set?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    disconnect?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    delete?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    connect?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    update?: WorkspaceBookingUpdateWithWhereUniqueWithoutBookingRequestInput | WorkspaceBookingUpdateWithWhereUniqueWithoutBookingRequestInput[]
    updateMany?: WorkspaceBookingUpdateManyWithWhereWithoutBookingRequestInput | WorkspaceBookingUpdateManyWithWhereWithoutBookingRequestInput[]
    deleteMany?: WorkspaceBookingScalarWhereInput | WorkspaceBookingScalarWhereInput[]
  }

  export type ServiceFormUpdateManyWithoutBookingRequestNestedInput = {
    create?: XOR<ServiceFormCreateWithoutBookingRequestInput, ServiceFormUncheckedCreateWithoutBookingRequestInput> | ServiceFormCreateWithoutBookingRequestInput[] | ServiceFormUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutBookingRequestInput | ServiceFormCreateOrConnectWithoutBookingRequestInput[]
    upsert?: ServiceFormUpsertWithWhereUniqueWithoutBookingRequestInput | ServiceFormUpsertWithWhereUniqueWithoutBookingRequestInput[]
    createMany?: ServiceFormCreateManyBookingRequestInputEnvelope
    set?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    disconnect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    delete?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    update?: ServiceFormUpdateWithWhereUniqueWithoutBookingRequestInput | ServiceFormUpdateWithWhereUniqueWithoutBookingRequestInput[]
    updateMany?: ServiceFormUpdateManyWithWhereWithoutBookingRequestInput | ServiceFormUpdateManyWithWhereWithoutBookingRequestInput[]
    deleteMany?: ServiceFormScalarWhereInput | ServiceFormScalarWhereInput[]
  }

  export type BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutBookingRequestInput, BookingServiceItemUncheckedCreateWithoutBookingRequestInput> | BookingServiceItemCreateWithoutBookingRequestInput[] | BookingServiceItemUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutBookingRequestInput | BookingServiceItemCreateOrConnectWithoutBookingRequestInput[]
    upsert?: BookingServiceItemUpsertWithWhereUniqueWithoutBookingRequestInput | BookingServiceItemUpsertWithWhereUniqueWithoutBookingRequestInput[]
    createMany?: BookingServiceItemCreateManyBookingRequestInputEnvelope
    set?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    disconnect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    delete?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    connect?: BookingServiceItemWhereUniqueInput | BookingServiceItemWhereUniqueInput[]
    update?: BookingServiceItemUpdateWithWhereUniqueWithoutBookingRequestInput | BookingServiceItemUpdateWithWhereUniqueWithoutBookingRequestInput[]
    updateMany?: BookingServiceItemUpdateManyWithWhereWithoutBookingRequestInput | BookingServiceItemUpdateManyWithWhereWithoutBookingRequestInput[]
    deleteMany?: BookingServiceItemScalarWhereInput | BookingServiceItemScalarWhereInput[]
  }

  export type WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput = {
    create?: XOR<WorkspaceBookingCreateWithoutBookingRequestInput, WorkspaceBookingUncheckedCreateWithoutBookingRequestInput> | WorkspaceBookingCreateWithoutBookingRequestInput[] | WorkspaceBookingUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutBookingRequestInput | WorkspaceBookingCreateOrConnectWithoutBookingRequestInput[]
    upsert?: WorkspaceBookingUpsertWithWhereUniqueWithoutBookingRequestInput | WorkspaceBookingUpsertWithWhereUniqueWithoutBookingRequestInput[]
    createMany?: WorkspaceBookingCreateManyBookingRequestInputEnvelope
    set?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    disconnect?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    delete?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    connect?: WorkspaceBookingWhereUniqueInput | WorkspaceBookingWhereUniqueInput[]
    update?: WorkspaceBookingUpdateWithWhereUniqueWithoutBookingRequestInput | WorkspaceBookingUpdateWithWhereUniqueWithoutBookingRequestInput[]
    updateMany?: WorkspaceBookingUpdateManyWithWhereWithoutBookingRequestInput | WorkspaceBookingUpdateManyWithWhereWithoutBookingRequestInput[]
    deleteMany?: WorkspaceBookingScalarWhereInput | WorkspaceBookingScalarWhereInput[]
  }

  export type ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput = {
    create?: XOR<ServiceFormCreateWithoutBookingRequestInput, ServiceFormUncheckedCreateWithoutBookingRequestInput> | ServiceFormCreateWithoutBookingRequestInput[] | ServiceFormUncheckedCreateWithoutBookingRequestInput[]
    connectOrCreate?: ServiceFormCreateOrConnectWithoutBookingRequestInput | ServiceFormCreateOrConnectWithoutBookingRequestInput[]
    upsert?: ServiceFormUpsertWithWhereUniqueWithoutBookingRequestInput | ServiceFormUpsertWithWhereUniqueWithoutBookingRequestInput[]
    createMany?: ServiceFormCreateManyBookingRequestInputEnvelope
    set?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    disconnect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    delete?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    connect?: ServiceFormWhereUniqueInput | ServiceFormWhereUniqueInput[]
    update?: ServiceFormUpdateWithWhereUniqueWithoutBookingRequestInput | ServiceFormUpdateWithWhereUniqueWithoutBookingRequestInput[]
    updateMany?: ServiceFormUpdateManyWithWhereWithoutBookingRequestInput | ServiceFormUpdateManyWithWhereWithoutBookingRequestInput[]
    deleteMany?: ServiceFormScalarWhereInput | ServiceFormScalarWhereInput[]
  }

  export type BookingRequestCreateNestedOneWithoutServiceItemsInput = {
    create?: XOR<BookingRequestCreateWithoutServiceItemsInput, BookingRequestUncheckedCreateWithoutServiceItemsInput>
    connectOrCreate?: BookingRequestCreateOrConnectWithoutServiceItemsInput
    connect?: BookingRequestWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingItemsInput = {
    create?: XOR<ServiceCreateWithoutBookingItemsInput, ServiceUncheckedCreateWithoutBookingItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutBookedItemInput, SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput> | SampleEquipmentUsageCreateWithoutBookedItemInput[] | SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput | SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput[]
    createMany?: SampleEquipmentUsageCreateManyBookedItemInputEnvelope
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
  }

  export type SampleModificationCreateNestedManyWithoutBookingServiceItemInput = {
    create?: XOR<SampleModificationCreateWithoutBookingServiceItemInput, SampleModificationUncheckedCreateWithoutBookingServiceItemInput> | SampleModificationCreateWithoutBookingServiceItemInput[] | SampleModificationUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutBookingServiceItemInput | SampleModificationCreateOrConnectWithoutBookingServiceItemInput[]
    createMany?: SampleModificationCreateManyBookingServiceItemInputEnvelope
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
  }

  export type SampleTrackingCreateNestedManyWithoutBookingServiceItemInput = {
    create?: XOR<SampleTrackingCreateWithoutBookingServiceItemInput, SampleTrackingUncheckedCreateWithoutBookingServiceItemInput> | SampleTrackingCreateWithoutBookingServiceItemInput[] | SampleTrackingUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutBookingServiceItemInput | SampleTrackingCreateOrConnectWithoutBookingServiceItemInput[]
    createMany?: SampleTrackingCreateManyBookingServiceItemInputEnvelope
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
  }

  export type ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput = {
    create?: XOR<ServiceAddOnCreateWithoutBookingServiceItemInput, ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput> | ServiceAddOnCreateWithoutBookingServiceItemInput[] | ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput | ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput[]
    createMany?: ServiceAddOnCreateManyBookingServiceItemInputEnvelope
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
  }

  export type SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutBookedItemInput, SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput> | SampleEquipmentUsageCreateWithoutBookedItemInput[] | SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput | SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput[]
    createMany?: SampleEquipmentUsageCreateManyBookedItemInputEnvelope
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
  }

  export type SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput = {
    create?: XOR<SampleModificationCreateWithoutBookingServiceItemInput, SampleModificationUncheckedCreateWithoutBookingServiceItemInput> | SampleModificationCreateWithoutBookingServiceItemInput[] | SampleModificationUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutBookingServiceItemInput | SampleModificationCreateOrConnectWithoutBookingServiceItemInput[]
    createMany?: SampleModificationCreateManyBookingServiceItemInputEnvelope
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
  }

  export type SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput = {
    create?: XOR<SampleTrackingCreateWithoutBookingServiceItemInput, SampleTrackingUncheckedCreateWithoutBookingServiceItemInput> | SampleTrackingCreateWithoutBookingServiceItemInput[] | SampleTrackingUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutBookingServiceItemInput | SampleTrackingCreateOrConnectWithoutBookingServiceItemInput[]
    createMany?: SampleTrackingCreateManyBookingServiceItemInputEnvelope
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
  }

  export type ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput = {
    create?: XOR<ServiceAddOnCreateWithoutBookingServiceItemInput, ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput> | ServiceAddOnCreateWithoutBookingServiceItemInput[] | ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput | ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput[]
    createMany?: ServiceAddOnCreateManyBookingServiceItemInputEnvelope
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput = {
    create?: XOR<BookingRequestCreateWithoutServiceItemsInput, BookingRequestUncheckedCreateWithoutServiceItemsInput>
    connectOrCreate?: BookingRequestCreateOrConnectWithoutServiceItemsInput
    upsert?: BookingRequestUpsertWithoutServiceItemsInput
    connect?: BookingRequestWhereUniqueInput
    update?: XOR<XOR<BookingRequestUpdateToOneWithWhereWithoutServiceItemsInput, BookingRequestUpdateWithoutServiceItemsInput>, BookingRequestUncheckedUpdateWithoutServiceItemsInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingItemsInput, ServiceUncheckedCreateWithoutBookingItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingItemsInput
    upsert?: ServiceUpsertWithoutBookingItemsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingItemsInput, ServiceUpdateWithoutBookingItemsInput>, ServiceUncheckedUpdateWithoutBookingItemsInput>
  }

  export type SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutBookedItemInput, SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput> | SampleEquipmentUsageCreateWithoutBookedItemInput[] | SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput | SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput[]
    upsert?: SampleEquipmentUsageUpsertWithWhereUniqueWithoutBookedItemInput | SampleEquipmentUsageUpsertWithWhereUniqueWithoutBookedItemInput[]
    createMany?: SampleEquipmentUsageCreateManyBookedItemInputEnvelope
    set?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    disconnect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    delete?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    update?: SampleEquipmentUsageUpdateWithWhereUniqueWithoutBookedItemInput | SampleEquipmentUsageUpdateWithWhereUniqueWithoutBookedItemInput[]
    updateMany?: SampleEquipmentUsageUpdateManyWithWhereWithoutBookedItemInput | SampleEquipmentUsageUpdateManyWithWhereWithoutBookedItemInput[]
    deleteMany?: SampleEquipmentUsageScalarWhereInput | SampleEquipmentUsageScalarWhereInput[]
  }

  export type SampleModificationUpdateManyWithoutBookingServiceItemNestedInput = {
    create?: XOR<SampleModificationCreateWithoutBookingServiceItemInput, SampleModificationUncheckedCreateWithoutBookingServiceItemInput> | SampleModificationCreateWithoutBookingServiceItemInput[] | SampleModificationUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutBookingServiceItemInput | SampleModificationCreateOrConnectWithoutBookingServiceItemInput[]
    upsert?: SampleModificationUpsertWithWhereUniqueWithoutBookingServiceItemInput | SampleModificationUpsertWithWhereUniqueWithoutBookingServiceItemInput[]
    createMany?: SampleModificationCreateManyBookingServiceItemInputEnvelope
    set?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    disconnect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    delete?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    update?: SampleModificationUpdateWithWhereUniqueWithoutBookingServiceItemInput | SampleModificationUpdateWithWhereUniqueWithoutBookingServiceItemInput[]
    updateMany?: SampleModificationUpdateManyWithWhereWithoutBookingServiceItemInput | SampleModificationUpdateManyWithWhereWithoutBookingServiceItemInput[]
    deleteMany?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
  }

  export type SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput = {
    create?: XOR<SampleTrackingCreateWithoutBookingServiceItemInput, SampleTrackingUncheckedCreateWithoutBookingServiceItemInput> | SampleTrackingCreateWithoutBookingServiceItemInput[] | SampleTrackingUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutBookingServiceItemInput | SampleTrackingCreateOrConnectWithoutBookingServiceItemInput[]
    upsert?: SampleTrackingUpsertWithWhereUniqueWithoutBookingServiceItemInput | SampleTrackingUpsertWithWhereUniqueWithoutBookingServiceItemInput[]
    createMany?: SampleTrackingCreateManyBookingServiceItemInputEnvelope
    set?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    disconnect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    delete?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    update?: SampleTrackingUpdateWithWhereUniqueWithoutBookingServiceItemInput | SampleTrackingUpdateWithWhereUniqueWithoutBookingServiceItemInput[]
    updateMany?: SampleTrackingUpdateManyWithWhereWithoutBookingServiceItemInput | SampleTrackingUpdateManyWithWhereWithoutBookingServiceItemInput[]
    deleteMany?: SampleTrackingScalarWhereInput | SampleTrackingScalarWhereInput[]
  }

  export type ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput = {
    create?: XOR<ServiceAddOnCreateWithoutBookingServiceItemInput, ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput> | ServiceAddOnCreateWithoutBookingServiceItemInput[] | ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput | ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput[]
    upsert?: ServiceAddOnUpsertWithWhereUniqueWithoutBookingServiceItemInput | ServiceAddOnUpsertWithWhereUniqueWithoutBookingServiceItemInput[]
    createMany?: ServiceAddOnCreateManyBookingServiceItemInputEnvelope
    set?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    disconnect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    delete?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    update?: ServiceAddOnUpdateWithWhereUniqueWithoutBookingServiceItemInput | ServiceAddOnUpdateWithWhereUniqueWithoutBookingServiceItemInput[]
    updateMany?: ServiceAddOnUpdateManyWithWhereWithoutBookingServiceItemInput | ServiceAddOnUpdateManyWithWhereWithoutBookingServiceItemInput[]
    deleteMany?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
  }

  export type SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutBookedItemInput, SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput> | SampleEquipmentUsageCreateWithoutBookedItemInput[] | SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput | SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput[]
    upsert?: SampleEquipmentUsageUpsertWithWhereUniqueWithoutBookedItemInput | SampleEquipmentUsageUpsertWithWhereUniqueWithoutBookedItemInput[]
    createMany?: SampleEquipmentUsageCreateManyBookedItemInputEnvelope
    set?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    disconnect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    delete?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    update?: SampleEquipmentUsageUpdateWithWhereUniqueWithoutBookedItemInput | SampleEquipmentUsageUpdateWithWhereUniqueWithoutBookedItemInput[]
    updateMany?: SampleEquipmentUsageUpdateManyWithWhereWithoutBookedItemInput | SampleEquipmentUsageUpdateManyWithWhereWithoutBookedItemInput[]
    deleteMany?: SampleEquipmentUsageScalarWhereInput | SampleEquipmentUsageScalarWhereInput[]
  }

  export type SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput = {
    create?: XOR<SampleModificationCreateWithoutBookingServiceItemInput, SampleModificationUncheckedCreateWithoutBookingServiceItemInput> | SampleModificationCreateWithoutBookingServiceItemInput[] | SampleModificationUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleModificationCreateOrConnectWithoutBookingServiceItemInput | SampleModificationCreateOrConnectWithoutBookingServiceItemInput[]
    upsert?: SampleModificationUpsertWithWhereUniqueWithoutBookingServiceItemInput | SampleModificationUpsertWithWhereUniqueWithoutBookingServiceItemInput[]
    createMany?: SampleModificationCreateManyBookingServiceItemInputEnvelope
    set?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    disconnect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    delete?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    connect?: SampleModificationWhereUniqueInput | SampleModificationWhereUniqueInput[]
    update?: SampleModificationUpdateWithWhereUniqueWithoutBookingServiceItemInput | SampleModificationUpdateWithWhereUniqueWithoutBookingServiceItemInput[]
    updateMany?: SampleModificationUpdateManyWithWhereWithoutBookingServiceItemInput | SampleModificationUpdateManyWithWhereWithoutBookingServiceItemInput[]
    deleteMany?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
  }

  export type SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput = {
    create?: XOR<SampleTrackingCreateWithoutBookingServiceItemInput, SampleTrackingUncheckedCreateWithoutBookingServiceItemInput> | SampleTrackingCreateWithoutBookingServiceItemInput[] | SampleTrackingUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutBookingServiceItemInput | SampleTrackingCreateOrConnectWithoutBookingServiceItemInput[]
    upsert?: SampleTrackingUpsertWithWhereUniqueWithoutBookingServiceItemInput | SampleTrackingUpsertWithWhereUniqueWithoutBookingServiceItemInput[]
    createMany?: SampleTrackingCreateManyBookingServiceItemInputEnvelope
    set?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    disconnect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    delete?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    connect?: SampleTrackingWhereUniqueInput | SampleTrackingWhereUniqueInput[]
    update?: SampleTrackingUpdateWithWhereUniqueWithoutBookingServiceItemInput | SampleTrackingUpdateWithWhereUniqueWithoutBookingServiceItemInput[]
    updateMany?: SampleTrackingUpdateManyWithWhereWithoutBookingServiceItemInput | SampleTrackingUpdateManyWithWhereWithoutBookingServiceItemInput[]
    deleteMany?: SampleTrackingScalarWhereInput | SampleTrackingScalarWhereInput[]
  }

  export type ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput = {
    create?: XOR<ServiceAddOnCreateWithoutBookingServiceItemInput, ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput> | ServiceAddOnCreateWithoutBookingServiceItemInput[] | ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput | ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput[]
    upsert?: ServiceAddOnUpsertWithWhereUniqueWithoutBookingServiceItemInput | ServiceAddOnUpsertWithWhereUniqueWithoutBookingServiceItemInput[]
    createMany?: ServiceAddOnCreateManyBookingServiceItemInputEnvelope
    set?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    disconnect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    delete?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    update?: ServiceAddOnUpdateWithWhereUniqueWithoutBookingServiceItemInput | ServiceAddOnUpdateWithWhereUniqueWithoutBookingServiceItemInput[]
    updateMany?: ServiceAddOnUpdateManyWithWhereWithoutBookingServiceItemInput | ServiceAddOnUpdateManyWithWhereWithoutBookingServiceItemInput[]
    deleteMany?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
  }

  export type BookingServiceItemCreateNestedOneWithoutModificationsInput = {
    create?: XOR<BookingServiceItemCreateWithoutModificationsInput, BookingServiceItemUncheckedCreateWithoutModificationsInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutModificationsInput
    connect?: BookingServiceItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedModificationsInput = {
    create?: XOR<UserCreateWithoutCreatedModificationsInput, UserUncheckedCreateWithoutCreatedModificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedModificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedModificationsInput = {
    create?: XOR<UserCreateWithoutApprovedModificationsInput, UserUncheckedCreateWithoutApprovedModificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedModificationsInput
    connect?: UserWhereUniqueInput
  }

  export type Enummodification_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.modification_status_enum
  }

  export type BookingServiceItemUpdateOneRequiredWithoutModificationsNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutModificationsInput, BookingServiceItemUncheckedCreateWithoutModificationsInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutModificationsInput
    upsert?: BookingServiceItemUpsertWithoutModificationsInput
    connect?: BookingServiceItemWhereUniqueInput
    update?: XOR<XOR<BookingServiceItemUpdateToOneWithWhereWithoutModificationsInput, BookingServiceItemUpdateWithoutModificationsInput>, BookingServiceItemUncheckedUpdateWithoutModificationsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedModificationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedModificationsInput, UserUncheckedCreateWithoutCreatedModificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedModificationsInput
    upsert?: UserUpsertWithoutCreatedModificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedModificationsInput, UserUpdateWithoutCreatedModificationsInput>, UserUncheckedUpdateWithoutCreatedModificationsInput>
  }

  export type UserUpdateOneWithoutApprovedModificationsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedModificationsInput, UserUncheckedCreateWithoutApprovedModificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedModificationsInput
    upsert?: UserUpsertWithoutApprovedModificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedModificationsInput, UserUpdateWithoutApprovedModificationsInput>, UserUncheckedUpdateWithoutApprovedModificationsInput>
  }

  export type BookingRequestCreateNestedOneWithoutServiceFormsInput = {
    create?: XOR<BookingRequestCreateWithoutServiceFormsInput, BookingRequestUncheckedCreateWithoutServiceFormsInput>
    connectOrCreate?: BookingRequestCreateOrConnectWithoutServiceFormsInput
    connect?: BookingRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceFormsInput = {
    create?: XOR<UserCreateWithoutServiceFormsInput, UserUncheckedCreateWithoutServiceFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceFormsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutServiceFormInput = {
    create?: XOR<InvoiceCreateWithoutServiceFormInput, InvoiceUncheckedCreateWithoutServiceFormInput> | InvoiceCreateWithoutServiceFormInput[] | InvoiceUncheckedCreateWithoutServiceFormInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutServiceFormInput | InvoiceCreateOrConnectWithoutServiceFormInput[]
    createMany?: InvoiceCreateManyServiceFormInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutServiceFormInput = {
    create?: XOR<InvoiceCreateWithoutServiceFormInput, InvoiceUncheckedCreateWithoutServiceFormInput> | InvoiceCreateWithoutServiceFormInput[] | InvoiceUncheckedCreateWithoutServiceFormInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutServiceFormInput | InvoiceCreateOrConnectWithoutServiceFormInput[]
    createMany?: InvoiceCreateManyServiceFormInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type Enumform_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.form_status_enum
  }

  export type BookingRequestUpdateOneRequiredWithoutServiceFormsNestedInput = {
    create?: XOR<BookingRequestCreateWithoutServiceFormsInput, BookingRequestUncheckedCreateWithoutServiceFormsInput>
    connectOrCreate?: BookingRequestCreateOrConnectWithoutServiceFormsInput
    upsert?: BookingRequestUpsertWithoutServiceFormsInput
    connect?: BookingRequestWhereUniqueInput
    update?: XOR<XOR<BookingRequestUpdateToOneWithWhereWithoutServiceFormsInput, BookingRequestUpdateWithoutServiceFormsInput>, BookingRequestUncheckedUpdateWithoutServiceFormsInput>
  }

  export type UserUpdateOneRequiredWithoutServiceFormsNestedInput = {
    create?: XOR<UserCreateWithoutServiceFormsInput, UserUncheckedCreateWithoutServiceFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceFormsInput
    upsert?: UserUpsertWithoutServiceFormsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceFormsInput, UserUpdateWithoutServiceFormsInput>, UserUncheckedUpdateWithoutServiceFormsInput>
  }

  export type InvoiceUpdateManyWithoutServiceFormNestedInput = {
    create?: XOR<InvoiceCreateWithoutServiceFormInput, InvoiceUncheckedCreateWithoutServiceFormInput> | InvoiceCreateWithoutServiceFormInput[] | InvoiceUncheckedCreateWithoutServiceFormInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutServiceFormInput | InvoiceCreateOrConnectWithoutServiceFormInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutServiceFormInput | InvoiceUpsertWithWhereUniqueWithoutServiceFormInput[]
    createMany?: InvoiceCreateManyServiceFormInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutServiceFormInput | InvoiceUpdateWithWhereUniqueWithoutServiceFormInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutServiceFormInput | InvoiceUpdateManyWithWhereWithoutServiceFormInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutServiceFormNestedInput = {
    create?: XOR<InvoiceCreateWithoutServiceFormInput, InvoiceUncheckedCreateWithoutServiceFormInput> | InvoiceCreateWithoutServiceFormInput[] | InvoiceUncheckedCreateWithoutServiceFormInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutServiceFormInput | InvoiceCreateOrConnectWithoutServiceFormInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutServiceFormInput | InvoiceUpsertWithWhereUniqueWithoutServiceFormInput[]
    createMany?: InvoiceCreateManyServiceFormInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutServiceFormInput | InvoiceUpdateWithWhereUniqueWithoutServiceFormInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutServiceFormInput | InvoiceUpdateManyWithWhereWithoutServiceFormInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ServiceFormCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ServiceFormCreateWithoutInvoicesInput, ServiceFormUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutInvoicesInput
    connect?: ServiceFormWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedInvoicesInput = {
    create?: XOR<UserCreateWithoutUploadedInvoicesInput, UserUncheckedCreateWithoutUploadedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type Enuminvoice_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.invoice_status_enum
  }

  export type ServiceFormUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ServiceFormCreateWithoutInvoicesInput, ServiceFormUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ServiceFormCreateOrConnectWithoutInvoicesInput
    upsert?: ServiceFormUpsertWithoutInvoicesInput
    connect?: ServiceFormWhereUniqueInput
    update?: XOR<XOR<ServiceFormUpdateToOneWithWhereWithoutInvoicesInput, ServiceFormUpdateWithoutInvoicesInput>, ServiceFormUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedInvoicesInput, UserUncheckedCreateWithoutUploadedInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedInvoicesInput
    upsert?: UserUpsertWithoutUploadedInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedInvoicesInput, UserUpdateWithoutUploadedInvoicesInput>, UserUncheckedUpdateWithoutUploadedInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedPaymentsInput = {
    create?: XOR<UserCreateWithoutUploadedPaymentsInput, UserUncheckedCreateWithoutUploadedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVerifiedPaymentsInput = {
    create?: XOR<UserCreateWithoutVerifiedPaymentsInput, UserUncheckedCreateWithoutVerifiedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type Enumpayment_method_enumFieldUpdateOperationsInput = {
    set?: $Enums.payment_method_enum
  }

  export type Enumpayment_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.payment_status_enum
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedPaymentsInput, UserUncheckedCreateWithoutUploadedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedPaymentsInput
    upsert?: UserUpsertWithoutUploadedPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedPaymentsInput, UserUpdateWithoutUploadedPaymentsInput>, UserUncheckedUpdateWithoutUploadedPaymentsInput>
  }

  export type UserUpdateOneWithoutVerifiedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutVerifiedPaymentsInput, UserUncheckedCreateWithoutVerifiedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerifiedPaymentsInput
    upsert?: UserUpsertWithoutVerifiedPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerifiedPaymentsInput, UserUpdateWithoutVerifiedPaymentsInput>, UserUncheckedUpdateWithoutVerifiedPaymentsInput>
  }

  export type BookingServiceItemCreateNestedOneWithoutSampleTrackingInput = {
    create?: XOR<BookingServiceItemCreateWithoutSampleTrackingInput, BookingServiceItemUncheckedCreateWithoutSampleTrackingInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutSampleTrackingInput
    connect?: BookingServiceItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSampleTrackingInput = {
    create?: XOR<UserCreateWithoutSampleTrackingInput, UserUncheckedCreateWithoutSampleTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSampleTrackingInput
    connect?: UserWhereUniqueInput
  }

  export type AnalysisResultCreateNestedManyWithoutSampleTrackingInput = {
    create?: XOR<AnalysisResultCreateWithoutSampleTrackingInput, AnalysisResultUncheckedCreateWithoutSampleTrackingInput> | AnalysisResultCreateWithoutSampleTrackingInput[] | AnalysisResultUncheckedCreateWithoutSampleTrackingInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutSampleTrackingInput | AnalysisResultCreateOrConnectWithoutSampleTrackingInput[]
    createMany?: AnalysisResultCreateManySampleTrackingInputEnvelope
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
  }

  export type AnalysisResultUncheckedCreateNestedManyWithoutSampleTrackingInput = {
    create?: XOR<AnalysisResultCreateWithoutSampleTrackingInput, AnalysisResultUncheckedCreateWithoutSampleTrackingInput> | AnalysisResultCreateWithoutSampleTrackingInput[] | AnalysisResultUncheckedCreateWithoutSampleTrackingInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutSampleTrackingInput | AnalysisResultCreateOrConnectWithoutSampleTrackingInput[]
    createMany?: AnalysisResultCreateManySampleTrackingInputEnvelope
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
  }

  export type Enumsample_status_enumFieldUpdateOperationsInput = {
    set?: $Enums.sample_status_enum
  }

  export type BookingServiceItemUpdateOneRequiredWithoutSampleTrackingNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutSampleTrackingInput, BookingServiceItemUncheckedCreateWithoutSampleTrackingInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutSampleTrackingInput
    upsert?: BookingServiceItemUpsertWithoutSampleTrackingInput
    connect?: BookingServiceItemWhereUniqueInput
    update?: XOR<XOR<BookingServiceItemUpdateToOneWithWhereWithoutSampleTrackingInput, BookingServiceItemUpdateWithoutSampleTrackingInput>, BookingServiceItemUncheckedUpdateWithoutSampleTrackingInput>
  }

  export type UserUpdateOneWithoutSampleTrackingNestedInput = {
    create?: XOR<UserCreateWithoutSampleTrackingInput, UserUncheckedCreateWithoutSampleTrackingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSampleTrackingInput
    upsert?: UserUpsertWithoutSampleTrackingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSampleTrackingInput, UserUpdateWithoutSampleTrackingInput>, UserUncheckedUpdateWithoutSampleTrackingInput>
  }

  export type AnalysisResultUpdateManyWithoutSampleTrackingNestedInput = {
    create?: XOR<AnalysisResultCreateWithoutSampleTrackingInput, AnalysisResultUncheckedCreateWithoutSampleTrackingInput> | AnalysisResultCreateWithoutSampleTrackingInput[] | AnalysisResultUncheckedCreateWithoutSampleTrackingInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutSampleTrackingInput | AnalysisResultCreateOrConnectWithoutSampleTrackingInput[]
    upsert?: AnalysisResultUpsertWithWhereUniqueWithoutSampleTrackingInput | AnalysisResultUpsertWithWhereUniqueWithoutSampleTrackingInput[]
    createMany?: AnalysisResultCreateManySampleTrackingInputEnvelope
    set?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    disconnect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    delete?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    update?: AnalysisResultUpdateWithWhereUniqueWithoutSampleTrackingInput | AnalysisResultUpdateWithWhereUniqueWithoutSampleTrackingInput[]
    updateMany?: AnalysisResultUpdateManyWithWhereWithoutSampleTrackingInput | AnalysisResultUpdateManyWithWhereWithoutSampleTrackingInput[]
    deleteMany?: AnalysisResultScalarWhereInput | AnalysisResultScalarWhereInput[]
  }

  export type AnalysisResultUncheckedUpdateManyWithoutSampleTrackingNestedInput = {
    create?: XOR<AnalysisResultCreateWithoutSampleTrackingInput, AnalysisResultUncheckedCreateWithoutSampleTrackingInput> | AnalysisResultCreateWithoutSampleTrackingInput[] | AnalysisResultUncheckedCreateWithoutSampleTrackingInput[]
    connectOrCreate?: AnalysisResultCreateOrConnectWithoutSampleTrackingInput | AnalysisResultCreateOrConnectWithoutSampleTrackingInput[]
    upsert?: AnalysisResultUpsertWithWhereUniqueWithoutSampleTrackingInput | AnalysisResultUpsertWithWhereUniqueWithoutSampleTrackingInput[]
    createMany?: AnalysisResultCreateManySampleTrackingInputEnvelope
    set?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    disconnect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    delete?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    connect?: AnalysisResultWhereUniqueInput | AnalysisResultWhereUniqueInput[]
    update?: AnalysisResultUpdateWithWhereUniqueWithoutSampleTrackingInput | AnalysisResultUpdateWithWhereUniqueWithoutSampleTrackingInput[]
    updateMany?: AnalysisResultUpdateManyWithWhereWithoutSampleTrackingInput | AnalysisResultUpdateManyWithWhereWithoutSampleTrackingInput[]
    deleteMany?: AnalysisResultScalarWhereInput | AnalysisResultScalarWhereInput[]
  }

  export type BookingRequestCreateNestedOneWithoutWorkspaceBookingsInput = {
    create?: XOR<BookingRequestCreateWithoutWorkspaceBookingsInput, BookingRequestUncheckedCreateWithoutWorkspaceBookingsInput>
    connectOrCreate?: BookingRequestCreateOrConnectWithoutWorkspaceBookingsInput
    connect?: BookingRequestWhereUniqueInput
  }

  export type WorkspaceEquipmentUsageCreateNestedManyWithoutWorkspaceBookingInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput> | WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyWorkspaceBookingInputEnvelope
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
  }

  export type ServiceAddOnCreateNestedManyWithoutWorkspaceBookingInput = {
    create?: XOR<ServiceAddOnCreateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput> | ServiceAddOnCreateWithoutWorkspaceBookingInput[] | ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput | ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput[]
    createMany?: ServiceAddOnCreateManyWorkspaceBookingInputEnvelope
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
  }

  export type WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutWorkspaceBookingInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput> | WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyWorkspaceBookingInputEnvelope
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
  }

  export type ServiceAddOnUncheckedCreateNestedManyWithoutWorkspaceBookingInput = {
    create?: XOR<ServiceAddOnCreateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput> | ServiceAddOnCreateWithoutWorkspaceBookingInput[] | ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput | ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput[]
    createMany?: ServiceAddOnCreateManyWorkspaceBookingInputEnvelope
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
  }

  export type BookingRequestUpdateOneRequiredWithoutWorkspaceBookingsNestedInput = {
    create?: XOR<BookingRequestCreateWithoutWorkspaceBookingsInput, BookingRequestUncheckedCreateWithoutWorkspaceBookingsInput>
    connectOrCreate?: BookingRequestCreateOrConnectWithoutWorkspaceBookingsInput
    upsert?: BookingRequestUpsertWithoutWorkspaceBookingsInput
    connect?: BookingRequestWhereUniqueInput
    update?: XOR<XOR<BookingRequestUpdateToOneWithWhereWithoutWorkspaceBookingsInput, BookingRequestUpdateWithoutWorkspaceBookingsInput>, BookingRequestUncheckedUpdateWithoutWorkspaceBookingsInput>
  }

  export type WorkspaceEquipmentUsageUpdateManyWithoutWorkspaceBookingNestedInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput> | WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput[]
    upsert?: WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutWorkspaceBookingInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyWorkspaceBookingInputEnvelope
    set?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    disconnect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    delete?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    update?: WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutWorkspaceBookingInput[]
    updateMany?: WorkspaceEquipmentUsageUpdateManyWithWhereWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageUpdateManyWithWhereWithoutWorkspaceBookingInput[]
    deleteMany?: WorkspaceEquipmentUsageScalarWhereInput | WorkspaceEquipmentUsageScalarWhereInput[]
  }

  export type ServiceAddOnUpdateManyWithoutWorkspaceBookingNestedInput = {
    create?: XOR<ServiceAddOnCreateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput> | ServiceAddOnCreateWithoutWorkspaceBookingInput[] | ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput | ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput[]
    upsert?: ServiceAddOnUpsertWithWhereUniqueWithoutWorkspaceBookingInput | ServiceAddOnUpsertWithWhereUniqueWithoutWorkspaceBookingInput[]
    createMany?: ServiceAddOnCreateManyWorkspaceBookingInputEnvelope
    set?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    disconnect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    delete?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    update?: ServiceAddOnUpdateWithWhereUniqueWithoutWorkspaceBookingInput | ServiceAddOnUpdateWithWhereUniqueWithoutWorkspaceBookingInput[]
    updateMany?: ServiceAddOnUpdateManyWithWhereWithoutWorkspaceBookingInput | ServiceAddOnUpdateManyWithWhereWithoutWorkspaceBookingInput[]
    deleteMany?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateManyWithoutWorkspaceBookingNestedInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput> | WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput[]
    upsert?: WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutWorkspaceBookingInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyWorkspaceBookingInputEnvelope
    set?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    disconnect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    delete?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    update?: WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutWorkspaceBookingInput[]
    updateMany?: WorkspaceEquipmentUsageUpdateManyWithWhereWithoutWorkspaceBookingInput | WorkspaceEquipmentUsageUpdateManyWithWhereWithoutWorkspaceBookingInput[]
    deleteMany?: WorkspaceEquipmentUsageScalarWhereInput | WorkspaceEquipmentUsageScalarWhereInput[]
  }

  export type ServiceAddOnUncheckedUpdateManyWithoutWorkspaceBookingNestedInput = {
    create?: XOR<ServiceAddOnCreateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput> | ServiceAddOnCreateWithoutWorkspaceBookingInput[] | ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput | ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput[]
    upsert?: ServiceAddOnUpsertWithWhereUniqueWithoutWorkspaceBookingInput | ServiceAddOnUpsertWithWhereUniqueWithoutWorkspaceBookingInput[]
    createMany?: ServiceAddOnCreateManyWorkspaceBookingInputEnvelope
    set?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    disconnect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    delete?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    update?: ServiceAddOnUpdateWithWhereUniqueWithoutWorkspaceBookingInput | ServiceAddOnUpdateWithWhereUniqueWithoutWorkspaceBookingInput[]
    updateMany?: ServiceAddOnUpdateManyWithWhereWithoutWorkspaceBookingInput | ServiceAddOnUpdateManyWithWhereWithoutWorkspaceBookingInput[]
    deleteMany?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
  }

  export type WorkspaceEquipmentUsageCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput> | WorkspaceEquipmentUsageCreateWithoutEquipmentInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput | WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyEquipmentInputEnvelope
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
  }

  export type SampleEquipmentUsageCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutEquipmentInput, SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput> | SampleEquipmentUsageCreateWithoutEquipmentInput[] | SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput | SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    createMany?: SampleEquipmentUsageCreateManyEquipmentInputEnvelope
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
  }

  export type WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput> | WorkspaceEquipmentUsageCreateWithoutEquipmentInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput | WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyEquipmentInputEnvelope
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
  }

  export type SampleEquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutEquipmentInput, SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput> | SampleEquipmentUsageCreateWithoutEquipmentInput[] | SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput | SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    createMany?: SampleEquipmentUsageCreateManyEquipmentInputEnvelope
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
  }

  export type WorkspaceEquipmentUsageUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput> | WorkspaceEquipmentUsageCreateWithoutEquipmentInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput | WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    upsert?: WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput | WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyEquipmentInputEnvelope
    set?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    disconnect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    delete?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    update?: WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput | WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: WorkspaceEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput | WorkspaceEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: WorkspaceEquipmentUsageScalarWhereInput | WorkspaceEquipmentUsageScalarWhereInput[]
  }

  export type SampleEquipmentUsageUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutEquipmentInput, SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput> | SampleEquipmentUsageCreateWithoutEquipmentInput[] | SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput | SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    upsert?: SampleEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput | SampleEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: SampleEquipmentUsageCreateManyEquipmentInputEnvelope
    set?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    disconnect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    delete?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    update?: SampleEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput | SampleEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: SampleEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput | SampleEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: SampleEquipmentUsageScalarWhereInput | SampleEquipmentUsageScalarWhereInput[]
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<WorkspaceEquipmentUsageCreateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput> | WorkspaceEquipmentUsageCreateWithoutEquipmentInput[] | WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput | WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    upsert?: WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput | WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: WorkspaceEquipmentUsageCreateManyEquipmentInputEnvelope
    set?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    disconnect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    delete?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    connect?: WorkspaceEquipmentUsageWhereUniqueInput | WorkspaceEquipmentUsageWhereUniqueInput[]
    update?: WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput | WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: WorkspaceEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput | WorkspaceEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: WorkspaceEquipmentUsageScalarWhereInput | WorkspaceEquipmentUsageScalarWhereInput[]
  }

  export type SampleEquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<SampleEquipmentUsageCreateWithoutEquipmentInput, SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput> | SampleEquipmentUsageCreateWithoutEquipmentInput[] | SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput | SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput[]
    upsert?: SampleEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput | SampleEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: SampleEquipmentUsageCreateManyEquipmentInputEnvelope
    set?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    disconnect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    delete?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    connect?: SampleEquipmentUsageWhereUniqueInput | SampleEquipmentUsageWhereUniqueInput[]
    update?: SampleEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput | SampleEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: SampleEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput | SampleEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: SampleEquipmentUsageScalarWhereInput | SampleEquipmentUsageScalarWhereInput[]
  }

  export type WorkspaceBookingCreateNestedOneWithoutEquipmentUsagesInput = {
    create?: XOR<WorkspaceBookingCreateWithoutEquipmentUsagesInput, WorkspaceBookingUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutEquipmentUsagesInput
    connect?: WorkspaceBookingWhereUniqueInput
  }

  export type LabEquipmentCreateNestedOneWithoutWorkspaceUsagesInput = {
    create?: XOR<LabEquipmentCreateWithoutWorkspaceUsagesInput, LabEquipmentUncheckedCreateWithoutWorkspaceUsagesInput>
    connectOrCreate?: LabEquipmentCreateOrConnectWithoutWorkspaceUsagesInput
    connect?: LabEquipmentWhereUniqueInput
  }

  export type WorkspaceBookingUpdateOneRequiredWithoutEquipmentUsagesNestedInput = {
    create?: XOR<WorkspaceBookingCreateWithoutEquipmentUsagesInput, WorkspaceBookingUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutEquipmentUsagesInput
    upsert?: WorkspaceBookingUpsertWithoutEquipmentUsagesInput
    connect?: WorkspaceBookingWhereUniqueInput
    update?: XOR<XOR<WorkspaceBookingUpdateToOneWithWhereWithoutEquipmentUsagesInput, WorkspaceBookingUpdateWithoutEquipmentUsagesInput>, WorkspaceBookingUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type LabEquipmentUpdateOneRequiredWithoutWorkspaceUsagesNestedInput = {
    create?: XOR<LabEquipmentCreateWithoutWorkspaceUsagesInput, LabEquipmentUncheckedCreateWithoutWorkspaceUsagesInput>
    connectOrCreate?: LabEquipmentCreateOrConnectWithoutWorkspaceUsagesInput
    upsert?: LabEquipmentUpsertWithoutWorkspaceUsagesInput
    connect?: LabEquipmentWhereUniqueInput
    update?: XOR<XOR<LabEquipmentUpdateToOneWithWhereWithoutWorkspaceUsagesInput, LabEquipmentUpdateWithoutWorkspaceUsagesInput>, LabEquipmentUncheckedUpdateWithoutWorkspaceUsagesInput>
  }

  export type BookingServiceItemCreateNestedOneWithoutEquipmentUsagesInput = {
    create?: XOR<BookingServiceItemCreateWithoutEquipmentUsagesInput, BookingServiceItemUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutEquipmentUsagesInput
    connect?: BookingServiceItemWhereUniqueInput
  }

  export type LabEquipmentCreateNestedOneWithoutSampleUsagesInput = {
    create?: XOR<LabEquipmentCreateWithoutSampleUsagesInput, LabEquipmentUncheckedCreateWithoutSampleUsagesInput>
    connectOrCreate?: LabEquipmentCreateOrConnectWithoutSampleUsagesInput
    connect?: LabEquipmentWhereUniqueInput
  }

  export type BookingServiceItemUpdateOneRequiredWithoutEquipmentUsagesNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutEquipmentUsagesInput, BookingServiceItemUncheckedCreateWithoutEquipmentUsagesInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutEquipmentUsagesInput
    upsert?: BookingServiceItemUpsertWithoutEquipmentUsagesInput
    connect?: BookingServiceItemWhereUniqueInput
    update?: XOR<XOR<BookingServiceItemUpdateToOneWithWhereWithoutEquipmentUsagesInput, BookingServiceItemUpdateWithoutEquipmentUsagesInput>, BookingServiceItemUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type LabEquipmentUpdateOneRequiredWithoutSampleUsagesNestedInput = {
    create?: XOR<LabEquipmentCreateWithoutSampleUsagesInput, LabEquipmentUncheckedCreateWithoutSampleUsagesInput>
    connectOrCreate?: LabEquipmentCreateOrConnectWithoutSampleUsagesInput
    upsert?: LabEquipmentUpsertWithoutSampleUsagesInput
    connect?: LabEquipmentWhereUniqueInput
    update?: XOR<XOR<LabEquipmentUpdateToOneWithWhereWithoutSampleUsagesInput, LabEquipmentUpdateWithoutSampleUsagesInput>, LabEquipmentUncheckedUpdateWithoutSampleUsagesInput>
  }

  export type SampleTrackingCreateNestedOneWithoutAnalysisResultsInput = {
    create?: XOR<SampleTrackingCreateWithoutAnalysisResultsInput, SampleTrackingUncheckedCreateWithoutAnalysisResultsInput>
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutAnalysisResultsInput
    connect?: SampleTrackingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedResultsInput = {
    create?: XOR<UserCreateWithoutUploadedResultsInput, UserUncheckedCreateWithoutUploadedResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedResultsInput
    connect?: UserWhereUniqueInput
  }

  export type SampleTrackingUpdateOneRequiredWithoutAnalysisResultsNestedInput = {
    create?: XOR<SampleTrackingCreateWithoutAnalysisResultsInput, SampleTrackingUncheckedCreateWithoutAnalysisResultsInput>
    connectOrCreate?: SampleTrackingCreateOrConnectWithoutAnalysisResultsInput
    upsert?: SampleTrackingUpsertWithoutAnalysisResultsInput
    connect?: SampleTrackingWhereUniqueInput
    update?: XOR<XOR<SampleTrackingUpdateToOneWithWhereWithoutAnalysisResultsInput, SampleTrackingUpdateWithoutAnalysisResultsInput>, SampleTrackingUncheckedUpdateWithoutAnalysisResultsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedResultsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedResultsInput, UserUncheckedCreateWithoutUploadedResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedResultsInput
    upsert?: UserUpsertWithoutUploadedResultsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedResultsInput, UserUpdateWithoutUploadedResultsInput>, UserUncheckedUpdateWithoutUploadedResultsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type Enumnotification_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.notification_type_enum
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ServiceAddOnMappingCreateNestedManyWithoutAddOnCatalogInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnMappingCreateWithoutAddOnCatalogInput[] | ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnMappingCreateManyAddOnCatalogInputEnvelope
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
  }

  export type ServiceAddOnCreateNestedManyWithoutAddOnCatalogInput = {
    create?: XOR<ServiceAddOnCreateWithoutAddOnCatalogInput, ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnCreateWithoutAddOnCatalogInput[] | ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnCreateManyAddOnCatalogInputEnvelope
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
  }

  export type ServiceAddOnMappingUncheckedCreateNestedManyWithoutAddOnCatalogInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnMappingCreateWithoutAddOnCatalogInput[] | ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnMappingCreateManyAddOnCatalogInputEnvelope
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
  }

  export type ServiceAddOnUncheckedCreateNestedManyWithoutAddOnCatalogInput = {
    create?: XOR<ServiceAddOnCreateWithoutAddOnCatalogInput, ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnCreateWithoutAddOnCatalogInput[] | ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnCreateManyAddOnCatalogInputEnvelope
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
  }

  export type ServiceAddOnMappingUpdateManyWithoutAddOnCatalogNestedInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnMappingCreateWithoutAddOnCatalogInput[] | ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput[]
    upsert?: ServiceAddOnMappingUpsertWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnMappingUpsertWithWhereUniqueWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnMappingCreateManyAddOnCatalogInputEnvelope
    set?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    disconnect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    delete?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    update?: ServiceAddOnMappingUpdateWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnMappingUpdateWithWhereUniqueWithoutAddOnCatalogInput[]
    updateMany?: ServiceAddOnMappingUpdateManyWithWhereWithoutAddOnCatalogInput | ServiceAddOnMappingUpdateManyWithWhereWithoutAddOnCatalogInput[]
    deleteMany?: ServiceAddOnMappingScalarWhereInput | ServiceAddOnMappingScalarWhereInput[]
  }

  export type ServiceAddOnUpdateManyWithoutAddOnCatalogNestedInput = {
    create?: XOR<ServiceAddOnCreateWithoutAddOnCatalogInput, ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnCreateWithoutAddOnCatalogInput[] | ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput[]
    upsert?: ServiceAddOnUpsertWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnUpsertWithWhereUniqueWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnCreateManyAddOnCatalogInputEnvelope
    set?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    disconnect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    delete?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    update?: ServiceAddOnUpdateWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnUpdateWithWhereUniqueWithoutAddOnCatalogInput[]
    updateMany?: ServiceAddOnUpdateManyWithWhereWithoutAddOnCatalogInput | ServiceAddOnUpdateManyWithWhereWithoutAddOnCatalogInput[]
    deleteMany?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
  }

  export type ServiceAddOnMappingUncheckedUpdateManyWithoutAddOnCatalogNestedInput = {
    create?: XOR<ServiceAddOnMappingCreateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnMappingCreateWithoutAddOnCatalogInput[] | ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput[]
    upsert?: ServiceAddOnMappingUpsertWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnMappingUpsertWithWhereUniqueWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnMappingCreateManyAddOnCatalogInputEnvelope
    set?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    disconnect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    delete?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    connect?: ServiceAddOnMappingWhereUniqueInput | ServiceAddOnMappingWhereUniqueInput[]
    update?: ServiceAddOnMappingUpdateWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnMappingUpdateWithWhereUniqueWithoutAddOnCatalogInput[]
    updateMany?: ServiceAddOnMappingUpdateManyWithWhereWithoutAddOnCatalogInput | ServiceAddOnMappingUpdateManyWithWhereWithoutAddOnCatalogInput[]
    deleteMany?: ServiceAddOnMappingScalarWhereInput | ServiceAddOnMappingScalarWhereInput[]
  }

  export type ServiceAddOnUncheckedUpdateManyWithoutAddOnCatalogNestedInput = {
    create?: XOR<ServiceAddOnCreateWithoutAddOnCatalogInput, ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput> | ServiceAddOnCreateWithoutAddOnCatalogInput[] | ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput[]
    connectOrCreate?: ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput | ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput[]
    upsert?: ServiceAddOnUpsertWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnUpsertWithWhereUniqueWithoutAddOnCatalogInput[]
    createMany?: ServiceAddOnCreateManyAddOnCatalogInputEnvelope
    set?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    disconnect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    delete?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    connect?: ServiceAddOnWhereUniqueInput | ServiceAddOnWhereUniqueInput[]
    update?: ServiceAddOnUpdateWithWhereUniqueWithoutAddOnCatalogInput | ServiceAddOnUpdateWithWhereUniqueWithoutAddOnCatalogInput[]
    updateMany?: ServiceAddOnUpdateManyWithWhereWithoutAddOnCatalogInput | ServiceAddOnUpdateManyWithWhereWithoutAddOnCatalogInput[]
    deleteMany?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutAddOnMappingsInput = {
    create?: XOR<ServiceCreateWithoutAddOnMappingsInput, ServiceUncheckedCreateWithoutAddOnMappingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAddOnMappingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type GlobalAddOnCatalogCreateNestedOneWithoutServiceMappingsInput = {
    create?: XOR<GlobalAddOnCatalogCreateWithoutServiceMappingsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceMappingsInput>
    connectOrCreate?: GlobalAddOnCatalogCreateOrConnectWithoutServiceMappingsInput
    connect?: GlobalAddOnCatalogWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutAddOnMappingsNestedInput = {
    create?: XOR<ServiceCreateWithoutAddOnMappingsInput, ServiceUncheckedCreateWithoutAddOnMappingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAddOnMappingsInput
    upsert?: ServiceUpsertWithoutAddOnMappingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAddOnMappingsInput, ServiceUpdateWithoutAddOnMappingsInput>, ServiceUncheckedUpdateWithoutAddOnMappingsInput>
  }

  export type GlobalAddOnCatalogUpdateOneRequiredWithoutServiceMappingsNestedInput = {
    create?: XOR<GlobalAddOnCatalogCreateWithoutServiceMappingsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceMappingsInput>
    connectOrCreate?: GlobalAddOnCatalogCreateOrConnectWithoutServiceMappingsInput
    upsert?: GlobalAddOnCatalogUpsertWithoutServiceMappingsInput
    connect?: GlobalAddOnCatalogWhereUniqueInput
    update?: XOR<XOR<GlobalAddOnCatalogUpdateToOneWithWhereWithoutServiceMappingsInput, GlobalAddOnCatalogUpdateWithoutServiceMappingsInput>, GlobalAddOnCatalogUncheckedUpdateWithoutServiceMappingsInput>
  }

  export type BookingServiceItemCreateNestedOneWithoutServiceAddOnsInput = {
    create?: XOR<BookingServiceItemCreateWithoutServiceAddOnsInput, BookingServiceItemUncheckedCreateWithoutServiceAddOnsInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutServiceAddOnsInput
    connect?: BookingServiceItemWhereUniqueInput
  }

  export type WorkspaceBookingCreateNestedOneWithoutServiceAddOnsInput = {
    create?: XOR<WorkspaceBookingCreateWithoutServiceAddOnsInput, WorkspaceBookingUncheckedCreateWithoutServiceAddOnsInput>
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutServiceAddOnsInput
    connect?: WorkspaceBookingWhereUniqueInput
  }

  export type GlobalAddOnCatalogCreateNestedOneWithoutServiceAddOnsInput = {
    create?: XOR<GlobalAddOnCatalogCreateWithoutServiceAddOnsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceAddOnsInput>
    connectOrCreate?: GlobalAddOnCatalogCreateOrConnectWithoutServiceAddOnsInput
    connect?: GlobalAddOnCatalogWhereUniqueInput
  }

  export type BookingServiceItemUpdateOneWithoutServiceAddOnsNestedInput = {
    create?: XOR<BookingServiceItemCreateWithoutServiceAddOnsInput, BookingServiceItemUncheckedCreateWithoutServiceAddOnsInput>
    connectOrCreate?: BookingServiceItemCreateOrConnectWithoutServiceAddOnsInput
    upsert?: BookingServiceItemUpsertWithoutServiceAddOnsInput
    disconnect?: BookingServiceItemWhereInput | boolean
    delete?: BookingServiceItemWhereInput | boolean
    connect?: BookingServiceItemWhereUniqueInput
    update?: XOR<XOR<BookingServiceItemUpdateToOneWithWhereWithoutServiceAddOnsInput, BookingServiceItemUpdateWithoutServiceAddOnsInput>, BookingServiceItemUncheckedUpdateWithoutServiceAddOnsInput>
  }

  export type WorkspaceBookingUpdateOneWithoutServiceAddOnsNestedInput = {
    create?: XOR<WorkspaceBookingCreateWithoutServiceAddOnsInput, WorkspaceBookingUncheckedCreateWithoutServiceAddOnsInput>
    connectOrCreate?: WorkspaceBookingCreateOrConnectWithoutServiceAddOnsInput
    upsert?: WorkspaceBookingUpsertWithoutServiceAddOnsInput
    disconnect?: WorkspaceBookingWhereInput | boolean
    delete?: WorkspaceBookingWhereInput | boolean
    connect?: WorkspaceBookingWhereUniqueInput
    update?: XOR<XOR<WorkspaceBookingUpdateToOneWithWhereWithoutServiceAddOnsInput, WorkspaceBookingUpdateWithoutServiceAddOnsInput>, WorkspaceBookingUncheckedUpdateWithoutServiceAddOnsInput>
  }

  export type GlobalAddOnCatalogUpdateOneRequiredWithoutServiceAddOnsNestedInput = {
    create?: XOR<GlobalAddOnCatalogCreateWithoutServiceAddOnsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceAddOnsInput>
    connectOrCreate?: GlobalAddOnCatalogCreateOrConnectWithoutServiceAddOnsInput
    upsert?: GlobalAddOnCatalogUpsertWithoutServiceAddOnsInput
    connect?: GlobalAddOnCatalogWhereUniqueInput
    update?: XOR<XOR<GlobalAddOnCatalogUpdateToOneWithWhereWithoutServiceAddOnsInput, GlobalAddOnCatalogUpdateWithoutServiceAddOnsInput>, GlobalAddOnCatalogUncheckedUpdateWithoutServiceAddOnsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.user_type_enum | Enumuser_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_type_enumFilter<$PrismaModel> | $Enums.user_type_enum
  }

  export type NestedEnumuser_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status_enum | Enumuser_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_status_enumFilter<$PrismaModel> | $Enums.user_status_enum
  }

  export type NestedEnumacademic_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.academic_type_enum | Enumacademic_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumacademic_type_enumFilter<$PrismaModel> | $Enums.academic_type_enum
  }

  export type NestedEnumUTMNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UTM | EnumUTMFieldRefInput<$PrismaModel> | null
    in?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUTMNullableFilter<$PrismaModel> | $Enums.UTM | null
  }

  export type NestedEnumuser_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_type_enum | Enumuser_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_type_enum[] | ListEnumuser_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.user_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_type_enumFilter<$PrismaModel>
    _max?: NestedEnumuser_type_enumFilter<$PrismaModel>
  }

  export type NestedEnumuser_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_status_enum | Enumuser_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_status_enum[] | ListEnumuser_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.user_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_status_enumFilter<$PrismaModel>
    _max?: NestedEnumuser_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumacademic_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.academic_type_enum | Enumacademic_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.academic_type_enum[] | ListEnumacademic_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumacademic_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.academic_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumacademic_type_enumFilter<$PrismaModel>
    _max?: NestedEnumacademic_type_enumFilter<$PrismaModel>
  }

  export type NestedEnumUTMNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UTM | EnumUTMFieldRefInput<$PrismaModel> | null
    in?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UTM[] | ListEnumUTMFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUTMNullableWithAggregatesFilter<$PrismaModel> | $Enums.UTM | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUTMNullableFilter<$PrismaModel>
    _max?: NestedEnumUTMNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumservice_category_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.service_category_enum | Enumservice_category_enumFieldRefInput<$PrismaModel>
    in?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumservice_category_enumFilter<$PrismaModel> | $Enums.service_category_enum
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumservice_category_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.service_category_enum | Enumservice_category_enumFieldRefInput<$PrismaModel>
    in?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.service_category_enum[] | ListEnumservice_category_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumservice_category_enumWithAggregatesFilter<$PrismaModel> | $Enums.service_category_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumservice_category_enumFilter<$PrismaModel>
    _max?: NestedEnumservice_category_enumFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumbooking_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.booking_status_enum | Enumbooking_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumbooking_status_enumFilter<$PrismaModel> | $Enums.booking_status_enum
  }

  export type NestedEnumbooking_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.booking_status_enum | Enumbooking_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.booking_status_enum[] | ListEnumbooking_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumbooking_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.booking_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbooking_status_enumFilter<$PrismaModel>
    _max?: NestedEnumbooking_status_enumFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnummodification_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.modification_status_enum | Enummodification_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnummodification_status_enumFilter<$PrismaModel> | $Enums.modification_status_enum
  }

  export type NestedEnummodification_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.modification_status_enum | Enummodification_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.modification_status_enum[] | ListEnummodification_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnummodification_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.modification_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummodification_status_enumFilter<$PrismaModel>
    _max?: NestedEnummodification_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumform_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.form_status_enum | Enumform_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumform_status_enumFilter<$PrismaModel> | $Enums.form_status_enum
  }

  export type NestedEnumform_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.form_status_enum | Enumform_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.form_status_enum[] | ListEnumform_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumform_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.form_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumform_status_enumFilter<$PrismaModel>
    _max?: NestedEnumform_status_enumFilter<$PrismaModel>
  }

  export type NestedEnuminvoice_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumFilter<$PrismaModel> | $Enums.invoice_status_enum
  }

  export type NestedEnuminvoice_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoice_status_enum | Enuminvoice_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.invoice_status_enum[] | ListEnuminvoice_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnuminvoice_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.invoice_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
    _max?: NestedEnuminvoice_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumpayment_method_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumFilter<$PrismaModel> | $Enums.payment_method_enum
  }

  export type NestedEnumpayment_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumFilter<$PrismaModel> | $Enums.payment_status_enum
  }

  export type NestedEnumpayment_method_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_method_enum | Enumpayment_method_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_method_enum[] | ListEnumpayment_method_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_method_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_method_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_method_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_method_enumFilter<$PrismaModel>
  }

  export type NestedEnumpayment_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status_enum | Enumpayment_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.payment_status_enum[] | ListEnumpayment_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumpayment_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.payment_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayment_status_enumFilter<$PrismaModel>
    _max?: NestedEnumpayment_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumsample_status_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.sample_status_enum | Enumsample_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsample_status_enumFilter<$PrismaModel> | $Enums.sample_status_enum
  }

  export type NestedEnumsample_status_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sample_status_enum | Enumsample_status_enumFieldRefInput<$PrismaModel>
    in?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.sample_status_enum[] | ListEnumsample_status_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumsample_status_enumWithAggregatesFilter<$PrismaModel> | $Enums.sample_status_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsample_status_enumFilter<$PrismaModel>
    _max?: NestedEnumsample_status_enumFilter<$PrismaModel>
  }

  export type NestedEnumnotification_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type_enum | Enumnotification_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_type_enumFilter<$PrismaModel> | $Enums.notification_type_enum
  }

  export type NestedEnumnotification_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type_enum | Enumnotification_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type_enum[] | ListEnumnotification_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.notification_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotification_type_enumFilter<$PrismaModel>
    _max?: NestedEnumnotification_type_enumFilter<$PrismaModel>
  }

  export type BetterAuthSessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthSessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthSessionCreateOrConnectWithoutUserInput = {
    where: BetterAuthSessionWhereUniqueInput
    create: XOR<BetterAuthSessionCreateWithoutUserInput, BetterAuthSessionUncheckedCreateWithoutUserInput>
  }

  export type BetterAuthSessionCreateManyUserInputEnvelope = {
    data: BetterAuthSessionCreateManyUserInput | BetterAuthSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BetterAuthAccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthAccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthAccountCreateOrConnectWithoutUserInput = {
    where: BetterAuthAccountWhereUniqueInput
    create: XOR<BetterAuthAccountCreateWithoutUserInput, BetterAuthAccountUncheckedCreateWithoutUserInput>
  }

  export type BetterAuthAccountCreateManyUserInputEnvelope = {
    data: BetterAuthAccountCreateManyUserInput | BetterAuthAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BetterAuthVerificationCreateWithoutUserInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthVerificationCreateOrConnectWithoutUserInput = {
    where: BetterAuthVerificationWhereUniqueInput
    create: XOR<BetterAuthVerificationCreateWithoutUserInput, BetterAuthVerificationUncheckedCreateWithoutUserInput>
  }

  export type BetterAuthVerificationCreateManyUserInputEnvelope = {
    data: BetterAuthVerificationCreateManyUserInput | BetterAuthVerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BetterAuthSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: BetterAuthSessionWhereUniqueInput
    update: XOR<BetterAuthSessionUpdateWithoutUserInput, BetterAuthSessionUncheckedUpdateWithoutUserInput>
    create: XOR<BetterAuthSessionCreateWithoutUserInput, BetterAuthSessionUncheckedCreateWithoutUserInput>
  }

  export type BetterAuthSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: BetterAuthSessionWhereUniqueInput
    data: XOR<BetterAuthSessionUpdateWithoutUserInput, BetterAuthSessionUncheckedUpdateWithoutUserInput>
  }

  export type BetterAuthSessionUpdateManyWithWhereWithoutUserInput = {
    where: BetterAuthSessionScalarWhereInput
    data: XOR<BetterAuthSessionUpdateManyMutationInput, BetterAuthSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type BetterAuthSessionScalarWhereInput = {
    AND?: BetterAuthSessionScalarWhereInput | BetterAuthSessionScalarWhereInput[]
    OR?: BetterAuthSessionScalarWhereInput[]
    NOT?: BetterAuthSessionScalarWhereInput | BetterAuthSessionScalarWhereInput[]
    id?: UuidFilter<"BetterAuthSession"> | string
    expiresAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    token?: StringFilter<"BetterAuthSession"> | string
    ipAddress?: StringNullableFilter<"BetterAuthSession"> | string | null
    userAgent?: StringNullableFilter<"BetterAuthSession"> | string | null
    userId?: UuidFilter<"BetterAuthSession"> | string
    createdAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthSession"> | Date | string
  }

  export type BetterAuthAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: BetterAuthAccountWhereUniqueInput
    update: XOR<BetterAuthAccountUpdateWithoutUserInput, BetterAuthAccountUncheckedUpdateWithoutUserInput>
    create: XOR<BetterAuthAccountCreateWithoutUserInput, BetterAuthAccountUncheckedCreateWithoutUserInput>
  }

  export type BetterAuthAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: BetterAuthAccountWhereUniqueInput
    data: XOR<BetterAuthAccountUpdateWithoutUserInput, BetterAuthAccountUncheckedUpdateWithoutUserInput>
  }

  export type BetterAuthAccountUpdateManyWithWhereWithoutUserInput = {
    where: BetterAuthAccountScalarWhereInput
    data: XOR<BetterAuthAccountUpdateManyMutationInput, BetterAuthAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type BetterAuthAccountScalarWhereInput = {
    AND?: BetterAuthAccountScalarWhereInput | BetterAuthAccountScalarWhereInput[]
    OR?: BetterAuthAccountScalarWhereInput[]
    NOT?: BetterAuthAccountScalarWhereInput | BetterAuthAccountScalarWhereInput[]
    id?: UuidFilter<"BetterAuthAccount"> | string
    accountId?: StringFilter<"BetterAuthAccount"> | string
    providerId?: StringFilter<"BetterAuthAccount"> | string
    userId?: UuidFilter<"BetterAuthAccount"> | string
    accessToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    idToken?: StringNullableFilter<"BetterAuthAccount"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"BetterAuthAccount"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"BetterAuthAccount"> | Date | string | null
    scope?: StringNullableFilter<"BetterAuthAccount"> | string | null
    password?: StringNullableFilter<"BetterAuthAccount"> | string | null
    createdAt?: DateTimeFilter<"BetterAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthAccount"> | Date | string
  }

  export type BetterAuthVerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: BetterAuthVerificationWhereUniqueInput
    update: XOR<BetterAuthVerificationUpdateWithoutUserInput, BetterAuthVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<BetterAuthVerificationCreateWithoutUserInput, BetterAuthVerificationUncheckedCreateWithoutUserInput>
  }

  export type BetterAuthVerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: BetterAuthVerificationWhereUniqueInput
    data: XOR<BetterAuthVerificationUpdateWithoutUserInput, BetterAuthVerificationUncheckedUpdateWithoutUserInput>
  }

  export type BetterAuthVerificationUpdateManyWithWhereWithoutUserInput = {
    where: BetterAuthVerificationScalarWhereInput
    data: XOR<BetterAuthVerificationUpdateManyMutationInput, BetterAuthVerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type BetterAuthVerificationScalarWhereInput = {
    AND?: BetterAuthVerificationScalarWhereInput | BetterAuthVerificationScalarWhereInput[]
    OR?: BetterAuthVerificationScalarWhereInput[]
    NOT?: BetterAuthVerificationScalarWhereInput | BetterAuthVerificationScalarWhereInput[]
    id?: UuidFilter<"BetterAuthVerification"> | string
    identifier?: StringFilter<"BetterAuthVerification"> | string
    value?: StringFilter<"BetterAuthVerification"> | string
    expiresAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    createdAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    updatedAt?: DateTimeFilter<"BetterAuthVerification"> | Date | string
    userId?: UuidNullableFilter<"BetterAuthVerification"> | string | null
  }

  export type BetterAuthUserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: BetterAuthAccountCreateNestedManyWithoutUserInput
    verifications?: BetterAuthVerificationCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: BetterAuthAccountUncheckedCreateNestedManyWithoutUserInput
    verifications?: BetterAuthVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserCreateOrConnectWithoutSessionsInput = {
    where: BetterAuthUserWhereUniqueInput
    create: XOR<BetterAuthUserCreateWithoutSessionsInput, BetterAuthUserUncheckedCreateWithoutSessionsInput>
  }

  export type BetterAuthUserUpsertWithoutSessionsInput = {
    update: XOR<BetterAuthUserUpdateWithoutSessionsInput, BetterAuthUserUncheckedUpdateWithoutSessionsInput>
    create: XOR<BetterAuthUserCreateWithoutSessionsInput, BetterAuthUserUncheckedCreateWithoutSessionsInput>
    where?: BetterAuthUserWhereInput
  }

  export type BetterAuthUserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: BetterAuthUserWhereInput
    data: XOR<BetterAuthUserUpdateWithoutSessionsInput, BetterAuthUserUncheckedUpdateWithoutSessionsInput>
  }

  export type BetterAuthUserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: BetterAuthAccountUpdateManyWithoutUserNestedInput
    verifications?: BetterAuthVerificationUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: BetterAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    verifications?: BetterAuthVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: BetterAuthSessionCreateNestedManyWithoutUserInput
    verifications?: BetterAuthVerificationCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: BetterAuthSessionUncheckedCreateNestedManyWithoutUserInput
    verifications?: BetterAuthVerificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserCreateOrConnectWithoutAccountsInput = {
    where: BetterAuthUserWhereUniqueInput
    create: XOR<BetterAuthUserCreateWithoutAccountsInput, BetterAuthUserUncheckedCreateWithoutAccountsInput>
  }

  export type BetterAuthUserUpsertWithoutAccountsInput = {
    update: XOR<BetterAuthUserUpdateWithoutAccountsInput, BetterAuthUserUncheckedUpdateWithoutAccountsInput>
    create: XOR<BetterAuthUserCreateWithoutAccountsInput, BetterAuthUserUncheckedCreateWithoutAccountsInput>
    where?: BetterAuthUserWhereInput
  }

  export type BetterAuthUserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: BetterAuthUserWhereInput
    data: XOR<BetterAuthUserUpdateWithoutAccountsInput, BetterAuthUserUncheckedUpdateWithoutAccountsInput>
  }

  export type BetterAuthUserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BetterAuthSessionUpdateManyWithoutUserNestedInput
    verifications?: BetterAuthVerificationUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BetterAuthSessionUncheckedUpdateManyWithoutUserNestedInput
    verifications?: BetterAuthVerificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserCreateWithoutVerificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: BetterAuthSessionCreateNestedManyWithoutUserInput
    accounts?: BetterAuthAccountCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserUncheckedCreateWithoutVerificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: BetterAuthSessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: BetterAuthAccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type BetterAuthUserCreateOrConnectWithoutVerificationsInput = {
    where: BetterAuthUserWhereUniqueInput
    create: XOR<BetterAuthUserCreateWithoutVerificationsInput, BetterAuthUserUncheckedCreateWithoutVerificationsInput>
  }

  export type BetterAuthUserUpsertWithoutVerificationsInput = {
    update: XOR<BetterAuthUserUpdateWithoutVerificationsInput, BetterAuthUserUncheckedUpdateWithoutVerificationsInput>
    create: XOR<BetterAuthUserCreateWithoutVerificationsInput, BetterAuthUserUncheckedCreateWithoutVerificationsInput>
    where?: BetterAuthUserWhereInput
  }

  export type BetterAuthUserUpdateToOneWithWhereWithoutVerificationsInput = {
    where?: BetterAuthUserWhereInput
    data: XOR<BetterAuthUserUpdateWithoutVerificationsInput, BetterAuthUserUncheckedUpdateWithoutVerificationsInput>
  }

  export type BetterAuthUserUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BetterAuthSessionUpdateManyWithoutUserNestedInput
    accounts?: BetterAuthAccountUpdateManyWithoutUserNestedInput
  }

  export type BetterAuthUserUncheckedUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: BetterAuthSessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: BetterAuthAccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DepartmentCreateWithoutFacultyInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentRelationInput
  }

  export type DepartmentUncheckedCreateWithoutFacultyInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentRelationInput
  }

  export type DepartmentCreateOrConnectWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
  }

  export type DepartmentCreateManyFacultyInputEnvelope = {
    data: DepartmentCreateManyFacultyInput | DepartmentCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type IkohzaCreateWithoutFacultyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutIkohzaInput
  }

  export type IkohzaUncheckedCreateWithoutFacultyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutIkohzaInput
  }

  export type IkohzaCreateOrConnectWithoutFacultyInput = {
    where: IkohzaWhereUniqueInput
    create: XOR<IkohzaCreateWithoutFacultyInput, IkohzaUncheckedCreateWithoutFacultyInput>
  }

  export type IkohzaCreateManyFacultyInputEnvelope = {
    data: IkohzaCreateManyFacultyInput | IkohzaCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFacultyRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutFacultyRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutFacultyRelationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFacultyRelationInput, UserUncheckedCreateWithoutFacultyRelationInput>
  }

  export type UserCreateManyFacultyRelationInputEnvelope = {
    data: UserCreateManyFacultyRelationInput | UserCreateManyFacultyRelationInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
    create: XOR<DepartmentCreateWithoutFacultyInput, DepartmentUncheckedCreateWithoutFacultyInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutFacultyInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutFacultyInput, DepartmentUncheckedUpdateWithoutFacultyInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutFacultyInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutFacultyInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: UuidFilter<"Department"> | string
    facultyId?: UuidFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type IkohzaUpsertWithWhereUniqueWithoutFacultyInput = {
    where: IkohzaWhereUniqueInput
    update: XOR<IkohzaUpdateWithoutFacultyInput, IkohzaUncheckedUpdateWithoutFacultyInput>
    create: XOR<IkohzaCreateWithoutFacultyInput, IkohzaUncheckedCreateWithoutFacultyInput>
  }

  export type IkohzaUpdateWithWhereUniqueWithoutFacultyInput = {
    where: IkohzaWhereUniqueInput
    data: XOR<IkohzaUpdateWithoutFacultyInput, IkohzaUncheckedUpdateWithoutFacultyInput>
  }

  export type IkohzaUpdateManyWithWhereWithoutFacultyInput = {
    where: IkohzaScalarWhereInput
    data: XOR<IkohzaUpdateManyMutationInput, IkohzaUncheckedUpdateManyWithoutFacultyInput>
  }

  export type IkohzaScalarWhereInput = {
    AND?: IkohzaScalarWhereInput | IkohzaScalarWhereInput[]
    OR?: IkohzaScalarWhereInput[]
    NOT?: IkohzaScalarWhereInput | IkohzaScalarWhereInput[]
    id?: UuidFilter<"Ikohza"> | string
    facultyId?: UuidFilter<"Ikohza"> | string
    code?: StringFilter<"Ikohza"> | string
    name?: StringFilter<"Ikohza"> | string
    description?: StringNullableFilter<"Ikohza"> | string | null
    isActive?: BoolFilter<"Ikohza"> | boolean
    leaderName?: StringNullableFilter<"Ikohza"> | string | null
    createdAt?: DateTimeFilter<"Ikohza"> | Date | string
    updatedAt?: DateTimeFilter<"Ikohza"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutFacultyRelationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFacultyRelationInput, UserUncheckedUpdateWithoutFacultyRelationInput>
    create: XOR<UserCreateWithoutFacultyRelationInput, UserUncheckedCreateWithoutFacultyRelationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFacultyRelationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFacultyRelationInput, UserUncheckedUpdateWithoutFacultyRelationInput>
  }

  export type UserUpdateManyWithWhereWithoutFacultyRelationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFacultyRelationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: UuidFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    userType?: Enumuser_type_enumFilter<"User"> | $Enums.user_type_enum
    status?: Enumuser_status_enumFilter<"User"> | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFilter<"User"> | $Enums.academic_type_enum
    userIdentifier?: StringNullableFilter<"User"> | string | null
    supervisorName?: StringNullableFilter<"User"> | string | null
    facultyId?: UuidNullableFilter<"User"> | string | null
    departmentId?: UuidNullableFilter<"User"> | string | null
    ikohzaId?: UuidNullableFilter<"User"> | string | null
    companyId?: UuidNullableFilter<"User"> | string | null
    companyBranchId?: UuidNullableFilter<"User"> | string | null
    UTM?: EnumUTMNullableFilter<"User"> | $Enums.UTM | null
    address?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    approvedBy?: UuidNullableFilter<"User"> | string | null
  }

  export type FacultyCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ikohzas?: IkohzaCreateNestedManyWithoutFacultyInput
    users?: UserCreateNestedManyWithoutFacultyRelationInput
  }

  export type FacultyUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ikohzas?: IkohzaUncheckedCreateNestedManyWithoutFacultyInput
    users?: UserUncheckedCreateNestedManyWithoutFacultyRelationInput
  }

  export type FacultyCreateOrConnectWithoutDepartmentsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
  }

  export type UserCreateWithoutDepartmentRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutDepartmentRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentRelationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentRelationInput, UserUncheckedCreateWithoutDepartmentRelationInput>
  }

  export type UserCreateManyDepartmentRelationInputEnvelope = {
    data: UserCreateManyDepartmentRelationInput | UserCreateManyDepartmentRelationInput[]
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithoutDepartmentsInput = {
    update: XOR<FacultyUpdateWithoutDepartmentsInput, FacultyUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<FacultyCreateWithoutDepartmentsInput, FacultyUncheckedCreateWithoutDepartmentsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutDepartmentsInput, FacultyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type FacultyUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ikohzas?: IkohzaUpdateManyWithoutFacultyNestedInput
    users?: UserUpdateManyWithoutFacultyRelationNestedInput
  }

  export type FacultyUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ikohzas?: IkohzaUncheckedUpdateManyWithoutFacultyNestedInput
    users?: UserUncheckedUpdateManyWithoutFacultyRelationNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentRelationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentRelationInput, UserUncheckedUpdateWithoutDepartmentRelationInput>
    create: XOR<UserCreateWithoutDepartmentRelationInput, UserUncheckedCreateWithoutDepartmentRelationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentRelationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentRelationInput, UserUncheckedUpdateWithoutDepartmentRelationInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentRelationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentRelationInput>
  }

  export type FacultyCreateWithoutIkohzasInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutFacultyInput
    users?: UserCreateNestedManyWithoutFacultyRelationInput
  }

  export type FacultyUncheckedCreateWithoutIkohzasInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacultyInput
    users?: UserUncheckedCreateNestedManyWithoutFacultyRelationInput
  }

  export type FacultyCreateOrConnectWithoutIkohzasInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutIkohzasInput, FacultyUncheckedCreateWithoutIkohzasInput>
  }

  export type UserCreateWithoutIkohzaInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutIkohzaInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutIkohzaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIkohzaInput, UserUncheckedCreateWithoutIkohzaInput>
  }

  export type UserCreateManyIkohzaInputEnvelope = {
    data: UserCreateManyIkohzaInput | UserCreateManyIkohzaInput[]
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithoutIkohzasInput = {
    update: XOR<FacultyUpdateWithoutIkohzasInput, FacultyUncheckedUpdateWithoutIkohzasInput>
    create: XOR<FacultyCreateWithoutIkohzasInput, FacultyUncheckedCreateWithoutIkohzasInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutIkohzasInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutIkohzasInput, FacultyUncheckedUpdateWithoutIkohzasInput>
  }

  export type FacultyUpdateWithoutIkohzasInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutFacultyNestedInput
    users?: UserUpdateManyWithoutFacultyRelationNestedInput
  }

  export type FacultyUncheckedUpdateWithoutIkohzasInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutFacultyNestedInput
    users?: UserUncheckedUpdateManyWithoutFacultyRelationNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutIkohzaInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutIkohzaInput, UserUncheckedUpdateWithoutIkohzaInput>
    create: XOR<UserCreateWithoutIkohzaInput, UserUncheckedCreateWithoutIkohzaInput>
  }

  export type UserUpdateWithWhereUniqueWithoutIkohzaInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutIkohzaInput, UserUncheckedUpdateWithoutIkohzaInput>
  }

  export type UserUpdateManyWithWhereWithoutIkohzaInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutIkohzaInput>
  }

  export type CompanyBranchCreateWithoutCompanyInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyBranchInput
    bookings?: BookingRequestCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyBranchInput
    bookings?: BookingRequestUncheckedCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchCreateOrConnectWithoutCompanyInput = {
    where: CompanyBranchWhereUniqueInput
    create: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyBranchCreateManyCompanyInputEnvelope = {
    data: CompanyBranchCreateManyCompanyInput | CompanyBranchCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompanyRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutCompanyRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutCompanyRelationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyRelationInput, UserUncheckedCreateWithoutCompanyRelationInput>
  }

  export type UserCreateManyCompanyRelationInputEnvelope = {
    data: UserCreateManyCompanyRelationInput | UserCreateManyCompanyRelationInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestCreateWithoutCompanyRelationInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutCompanyRelationInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyBranchId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutCompanyRelationInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutCompanyRelationInput, BookingRequestUncheckedCreateWithoutCompanyRelationInput>
  }

  export type BookingRequestCreateManyCompanyRelationInputEnvelope = {
    data: BookingRequestCreateManyCompanyRelationInput | BookingRequestCreateManyCompanyRelationInput[]
    skipDuplicates?: boolean
  }

  export type CompanyBranchUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyBranchWhereUniqueInput
    update: XOR<CompanyBranchUpdateWithoutCompanyInput, CompanyBranchUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyBranchCreateWithoutCompanyInput, CompanyBranchUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyBranchUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyBranchWhereUniqueInput
    data: XOR<CompanyBranchUpdateWithoutCompanyInput, CompanyBranchUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyBranchUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyBranchScalarWhereInput
    data: XOR<CompanyBranchUpdateManyMutationInput, CompanyBranchUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyBranchScalarWhereInput = {
    AND?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
    OR?: CompanyBranchScalarWhereInput[]
    NOT?: CompanyBranchScalarWhereInput | CompanyBranchScalarWhereInput[]
    id?: UuidFilter<"CompanyBranch"> | string
    companyId?: UuidFilter<"CompanyBranch"> | string
    name?: StringFilter<"CompanyBranch"> | string
    address?: StringNullableFilter<"CompanyBranch"> | string | null
    city?: StringNullableFilter<"CompanyBranch"> | string | null
    state?: StringNullableFilter<"CompanyBranch"> | string | null
    postcode?: StringNullableFilter<"CompanyBranch"> | string | null
    country?: StringNullableFilter<"CompanyBranch"> | string | null
    phone?: StringNullableFilter<"CompanyBranch"> | string | null
    isActive?: BoolFilter<"CompanyBranch"> | boolean
    createdAt?: DateTimeFilter<"CompanyBranch"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyBranch"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyRelationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyRelationInput, UserUncheckedUpdateWithoutCompanyRelationInput>
    create: XOR<UserCreateWithoutCompanyRelationInput, UserUncheckedCreateWithoutCompanyRelationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyRelationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyRelationInput, UserUncheckedUpdateWithoutCompanyRelationInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyRelationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyRelationInput>
  }

  export type BookingRequestUpsertWithWhereUniqueWithoutCompanyRelationInput = {
    where: BookingRequestWhereUniqueInput
    update: XOR<BookingRequestUpdateWithoutCompanyRelationInput, BookingRequestUncheckedUpdateWithoutCompanyRelationInput>
    create: XOR<BookingRequestCreateWithoutCompanyRelationInput, BookingRequestUncheckedCreateWithoutCompanyRelationInput>
  }

  export type BookingRequestUpdateWithWhereUniqueWithoutCompanyRelationInput = {
    where: BookingRequestWhereUniqueInput
    data: XOR<BookingRequestUpdateWithoutCompanyRelationInput, BookingRequestUncheckedUpdateWithoutCompanyRelationInput>
  }

  export type BookingRequestUpdateManyWithWhereWithoutCompanyRelationInput = {
    where: BookingRequestScalarWhereInput
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyWithoutCompanyRelationInput>
  }

  export type BookingRequestScalarWhereInput = {
    AND?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
    OR?: BookingRequestScalarWhereInput[]
    NOT?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
    id?: UuidFilter<"BookingRequest"> | string
    userId?: UuidFilter<"BookingRequest"> | string
    referenceNumber?: StringFilter<"BookingRequest"> | string
    projectDescription?: StringNullableFilter<"BookingRequest"> | string | null
    preferredStartDate?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    preferredEndDate?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    totalAmount?: DecimalFilter<"BookingRequest"> | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFilter<"BookingRequest"> | $Enums.booking_status_enum
    notes?: StringNullableFilter<"BookingRequest"> | string | null
    createdAt?: DateTimeFilter<"BookingRequest"> | Date | string
    updatedAt?: DateTimeFilter<"BookingRequest"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"BookingRequest"> | Date | string | null
    reviewedBy?: UuidNullableFilter<"BookingRequest"> | string | null
    reviewNotes?: StringNullableFilter<"BookingRequest"> | string | null
    companyId?: UuidNullableFilter<"BookingRequest"> | string | null
    companyBranchId?: UuidNullableFilter<"BookingRequest"> | string | null
  }

  export type CompanyCreateWithoutBranchesInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyRelationInput
    bookings?: BookingRequestCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyUncheckedCreateWithoutBranchesInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyRelationInput
    bookings?: BookingRequestUncheckedCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyCreateOrConnectWithoutBranchesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
  }

  export type UserCreateWithoutCompanyBranchInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutCompanyBranchInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutCompanyBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyBranchInput, UserUncheckedCreateWithoutCompanyBranchInput>
  }

  export type UserCreateManyCompanyBranchInputEnvelope = {
    data: UserCreateManyCompanyBranchInput | UserCreateManyCompanyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestCreateWithoutCompanyBranchInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutCompanyBranchInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutCompanyBranchInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutCompanyBranchInput, BookingRequestUncheckedCreateWithoutCompanyBranchInput>
  }

  export type BookingRequestCreateManyCompanyBranchInputEnvelope = {
    data: BookingRequestCreateManyCompanyBranchInput | BookingRequestCreateManyCompanyBranchInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBranchesInput = {
    update: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
    create: XOR<CompanyCreateWithoutBranchesInput, CompanyUncheckedCreateWithoutBranchesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBranchesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBranchesInput, CompanyUncheckedUpdateWithoutBranchesInput>
  }

  export type CompanyUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyRelationNestedInput
    bookings?: BookingRequestUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyRelationNestedInput
    bookings?: BookingRequestUncheckedUpdateManyWithoutCompanyRelationNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyBranchInput, UserUncheckedUpdateWithoutCompanyBranchInput>
    create: XOR<UserCreateWithoutCompanyBranchInput, UserUncheckedCreateWithoutCompanyBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyBranchInput, UserUncheckedUpdateWithoutCompanyBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyBranchInput>
  }

  export type BookingRequestUpsertWithWhereUniqueWithoutCompanyBranchInput = {
    where: BookingRequestWhereUniqueInput
    update: XOR<BookingRequestUpdateWithoutCompanyBranchInput, BookingRequestUncheckedUpdateWithoutCompanyBranchInput>
    create: XOR<BookingRequestCreateWithoutCompanyBranchInput, BookingRequestUncheckedCreateWithoutCompanyBranchInput>
  }

  export type BookingRequestUpdateWithWhereUniqueWithoutCompanyBranchInput = {
    where: BookingRequestWhereUniqueInput
    data: XOR<BookingRequestUpdateWithoutCompanyBranchInput, BookingRequestUncheckedUpdateWithoutCompanyBranchInput>
  }

  export type BookingRequestUpdateManyWithWhereWithoutCompanyBranchInput = {
    where: BookingRequestScalarWhereInput
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyWithoutCompanyBranchInput>
  }

  export type FacultyCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutFacultyInput
    ikohzas?: IkohzaCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacultyInput
    ikohzas?: IkohzaUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutUsersInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutUsersInput, FacultyUncheckedCreateWithoutUsersInput>
  }

  export type DepartmentCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty: FacultyCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: string
    facultyId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type IkohzaCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    faculty: FacultyCreateNestedOneWithoutIkohzasInput
  }

  export type IkohzaUncheckedCreateWithoutUsersInput = {
    id?: string
    facultyId: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IkohzaCreateOrConnectWithoutUsersInput = {
    where: IkohzaWhereUniqueInput
    create: XOR<IkohzaCreateWithoutUsersInput, IkohzaUncheckedCreateWithoutUsersInput>
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: CompanyBranchCreateNestedManyWithoutCompanyInput
    bookings?: BookingRequestCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: CompanyBranchUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingRequestUncheckedCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type CompanyBranchCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBranchesInput
    bookings?: BookingRequestCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchUncheckedCreateWithoutUsersInput = {
    id?: string
    companyId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingRequestUncheckedCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchCreateOrConnectWithoutUsersInput = {
    where: CompanyBranchWhereUniqueInput
    create: XOR<CompanyBranchCreateWithoutUsersInput, CompanyBranchUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutApprovedUsersInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutApprovedUsersInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutApprovedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedUsersInput, UserUncheckedCreateWithoutApprovedUsersInput>
  }

  export type UserCreateWithoutApprovedByUserInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutApprovedByUserInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutApprovedByUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedByUserInput, UserUncheckedCreateWithoutApprovedByUserInput>
  }

  export type UserCreateManyApprovedByUserInputEnvelope = {
    data: UserCreateManyApprovedByUserInput | UserCreateManyApprovedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthProviderCreateWithoutUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    passwordHash?: string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    passwordHash?: string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderCreateOrConnectWithoutUserInput = {
    where: AuthProviderWhereUniqueInput
    create: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput>
  }

  export type AuthProviderCreateManyUserInputEnvelope = {
    data: AuthProviderCreateManyUserInput | AuthProviderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestCreateWithoutUserInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutUserInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutUserInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutUserInput, BookingRequestUncheckedCreateWithoutUserInput>
  }

  export type BookingRequestCreateManyUserInputEnvelope = {
    data: BookingRequestCreateManyUserInput | BookingRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestCreateWithoutReviewedByUserInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutReviewedByUserInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutReviewedByUserInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutReviewedByUserInput, BookingRequestUncheckedCreateWithoutReviewedByUserInput>
  }

  export type BookingRequestCreateManyReviewedByUserInputEnvelope = {
    data: BookingRequestCreateManyReviewedByUserInput | BookingRequestCreateManyReviewedByUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceFormCreateWithoutGeneratedByUserInput = {
    id?: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceFormsInput
    invoices?: InvoiceCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUncheckedCreateWithoutGeneratedByUserInput = {
    id?: string
    bookingRequestId: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormCreateOrConnectWithoutGeneratedByUserInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutGeneratedByUserInput, ServiceFormUncheckedCreateWithoutGeneratedByUserInput>
  }

  export type ServiceFormCreateManyGeneratedByUserInputEnvelope = {
    data: ServiceFormCreateManyGeneratedByUserInput | ServiceFormCreateManyGeneratedByUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUploadedByUserInput = {
    id?: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceForm: ServiceFormCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUploadedByUserInput = {
    id?: string
    serviceFormId: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUploadedByUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUploadedByUserInput, InvoiceUncheckedCreateWithoutUploadedByUserInput>
  }

  export type InvoiceCreateManyUploadedByUserInputEnvelope = {
    data: InvoiceCreateManyUploadedByUserInput | InvoiceCreateManyUploadedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutVerifiedByUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    uploadedByUser: UserCreateNestedOneWithoutUploadedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutVerifiedByUserInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutVerifiedByUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutVerifiedByUserInput, PaymentUncheckedCreateWithoutVerifiedByUserInput>
  }

  export type PaymentCreateManyVerifiedByUserInputEnvelope = {
    data: PaymentCreateManyVerifiedByUserInput | PaymentCreateManyVerifiedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AnalysisResultCreateWithoutUploadedByUserInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sampleTracking: SampleTrackingCreateNestedOneWithoutAnalysisResultsInput
  }

  export type AnalysisResultUncheckedCreateWithoutUploadedByUserInput = {
    id?: string
    sampleTrackingId: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisResultCreateOrConnectWithoutUploadedByUserInput = {
    where: AnalysisResultWhereUniqueInput
    create: XOR<AnalysisResultCreateWithoutUploadedByUserInput, AnalysisResultUncheckedCreateWithoutUploadedByUserInput>
  }

  export type AnalysisResultCreateManyUploadedByUserInputEnvelope = {
    data: AnalysisResultCreateManyUploadedByUserInput | AnalysisResultCreateManyUploadedByUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.notification_type_enum
    relatedEntityType?: string | null
    relatedEntityId?: string | null
    title: string
    message: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.notification_type_enum
    relatedEntityType?: string | null
    relatedEntityId?: string | null
    title: string
    message: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SampleTrackingCreateWithoutUpdatedByUserInput = {
    id?: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingServiceItem: BookingServiceItemCreateNestedOneWithoutSampleTrackingInput
    analysisResults?: AnalysisResultCreateNestedManyWithoutSampleTrackingInput
  }

  export type SampleTrackingUncheckedCreateWithoutUpdatedByUserInput = {
    id?: string
    bookingServiceItemId: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisResults?: AnalysisResultUncheckedCreateNestedManyWithoutSampleTrackingInput
  }

  export type SampleTrackingCreateOrConnectWithoutUpdatedByUserInput = {
    where: SampleTrackingWhereUniqueInput
    create: XOR<SampleTrackingCreateWithoutUpdatedByUserInput, SampleTrackingUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type SampleTrackingCreateManyUpdatedByUserInputEnvelope = {
    data: SampleTrackingCreateManyUpdatedByUserInput | SampleTrackingCreateManyUpdatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SampleModificationCreateWithoutCreatedByUserInput = {
    id?: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdAt?: Date | string
    approvedAt?: Date | string | null
    bookingServiceItem: BookingServiceItemCreateNestedOneWithoutModificationsInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedModificationsInput
  }

  export type SampleModificationUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type SampleModificationCreateOrConnectWithoutCreatedByUserInput = {
    where: SampleModificationWhereUniqueInput
    create: XOR<SampleModificationCreateWithoutCreatedByUserInput, SampleModificationUncheckedCreateWithoutCreatedByUserInput>
  }

  export type SampleModificationCreateManyCreatedByUserInputEnvelope = {
    data: SampleModificationCreateManyCreatedByUserInput | SampleModificationCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SampleModificationCreateWithoutApprovedByUserInput = {
    id?: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdAt?: Date | string
    approvedAt?: Date | string | null
    bookingServiceItem: BookingServiceItemCreateNestedOneWithoutModificationsInput
    createdByUser: UserCreateNestedOneWithoutCreatedModificationsInput
  }

  export type SampleModificationUncheckedCreateWithoutApprovedByUserInput = {
    id?: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type SampleModificationCreateOrConnectWithoutApprovedByUserInput = {
    where: SampleModificationWhereUniqueInput
    create: XOR<SampleModificationCreateWithoutApprovedByUserInput, SampleModificationUncheckedCreateWithoutApprovedByUserInput>
  }

  export type SampleModificationCreateManyApprovedByUserInputEnvelope = {
    data: SampleModificationCreateManyApprovedByUserInput | SampleModificationCreateManyApprovedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUploadedByUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    verifiedByUser?: UserCreateNestedOneWithoutVerifiedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUploadedByUserInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUploadedByUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUploadedByUserInput, PaymentUncheckedCreateWithoutUploadedByUserInput>
  }

  export type PaymentCreateManyUploadedByUserInputEnvelope = {
    data: PaymentCreateManyUploadedByUserInput | PaymentCreateManyUploadedByUserInput[]
    skipDuplicates?: boolean
  }

  export type FacultyUpsertWithoutUsersInput = {
    update: XOR<FacultyUpdateWithoutUsersInput, FacultyUncheckedUpdateWithoutUsersInput>
    create: XOR<FacultyCreateWithoutUsersInput, FacultyUncheckedCreateWithoutUsersInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutUsersInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutUsersInput, FacultyUncheckedUpdateWithoutUsersInput>
  }

  export type FacultyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutFacultyNestedInput
    ikohzas?: IkohzaUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutFacultyNestedInput
    ikohzas?: IkohzaUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IkohzaUpsertWithoutUsersInput = {
    update: XOR<IkohzaUpdateWithoutUsersInput, IkohzaUncheckedUpdateWithoutUsersInput>
    create: XOR<IkohzaCreateWithoutUsersInput, IkohzaUncheckedCreateWithoutUsersInput>
    where?: IkohzaWhereInput
  }

  export type IkohzaUpdateToOneWithWhereWithoutUsersInput = {
    where?: IkohzaWhereInput
    data: XOR<IkohzaUpdateWithoutUsersInput, IkohzaUncheckedUpdateWithoutUsersInput>
  }

  export type IkohzaUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: FacultyUpdateOneRequiredWithoutIkohzasNestedInput
  }

  export type IkohzaUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: CompanyBranchUpdateManyWithoutCompanyNestedInput
    bookings?: BookingRequestUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: CompanyBranchUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingRequestUncheckedUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyBranchUpsertWithoutUsersInput = {
    update: XOR<CompanyBranchUpdateWithoutUsersInput, CompanyBranchUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyBranchCreateWithoutUsersInput, CompanyBranchUncheckedCreateWithoutUsersInput>
    where?: CompanyBranchWhereInput
  }

  export type CompanyBranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyBranchWhereInput
    data: XOR<CompanyBranchUpdateWithoutUsersInput, CompanyBranchUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyBranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    bookings?: BookingRequestUpdateManyWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingRequestUncheckedUpdateManyWithoutCompanyBranchNestedInput
  }

  export type UserUpsertWithoutApprovedUsersInput = {
    update: XOR<UserUpdateWithoutApprovedUsersInput, UserUncheckedUpdateWithoutApprovedUsersInput>
    create: XOR<UserCreateWithoutApprovedUsersInput, UserUncheckedCreateWithoutApprovedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedUsersInput, UserUncheckedUpdateWithoutApprovedUsersInput>
  }

  export type UserUpdateWithoutApprovedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutApprovedByUserInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutApprovedByUserInput, UserUncheckedUpdateWithoutApprovedByUserInput>
    create: XOR<UserCreateWithoutApprovedByUserInput, UserUncheckedCreateWithoutApprovedByUserInput>
  }

  export type UserUpdateWithWhereUniqueWithoutApprovedByUserInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutApprovedByUserInput, UserUncheckedUpdateWithoutApprovedByUserInput>
  }

  export type UserUpdateManyWithWhereWithoutApprovedByUserInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutApprovedByUserInput>
  }

  export type AuthProviderUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthProviderWhereUniqueInput
    update: XOR<AuthProviderUpdateWithoutUserInput, AuthProviderUncheckedUpdateWithoutUserInput>
    create: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput>
  }

  export type AuthProviderUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthProviderWhereUniqueInput
    data: XOR<AuthProviderUpdateWithoutUserInput, AuthProviderUncheckedUpdateWithoutUserInput>
  }

  export type AuthProviderUpdateManyWithWhereWithoutUserInput = {
    where: AuthProviderScalarWhereInput
    data: XOR<AuthProviderUpdateManyMutationInput, AuthProviderUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthProviderScalarWhereInput = {
    AND?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
    OR?: AuthProviderScalarWhereInput[]
    NOT?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
    id?: UuidFilter<"AuthProvider"> | string
    userId?: UuidFilter<"AuthProvider"> | string
    provider?: StringFilter<"AuthProvider"> | string
    providerAccountId?: StringFilter<"AuthProvider"> | string
    passwordHash?: StringNullableFilter<"AuthProvider"> | string | null
    oauthData?: JsonNullableFilter<"AuthProvider">
    createdAt?: DateTimeFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AuthProvider"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BookingRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingRequestWhereUniqueInput
    update: XOR<BookingRequestUpdateWithoutUserInput, BookingRequestUncheckedUpdateWithoutUserInput>
    create: XOR<BookingRequestCreateWithoutUserInput, BookingRequestUncheckedCreateWithoutUserInput>
  }

  export type BookingRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingRequestWhereUniqueInput
    data: XOR<BookingRequestUpdateWithoutUserInput, BookingRequestUncheckedUpdateWithoutUserInput>
  }

  export type BookingRequestUpdateManyWithWhereWithoutUserInput = {
    where: BookingRequestScalarWhereInput
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingRequestUpsertWithWhereUniqueWithoutReviewedByUserInput = {
    where: BookingRequestWhereUniqueInput
    update: XOR<BookingRequestUpdateWithoutReviewedByUserInput, BookingRequestUncheckedUpdateWithoutReviewedByUserInput>
    create: XOR<BookingRequestCreateWithoutReviewedByUserInput, BookingRequestUncheckedCreateWithoutReviewedByUserInput>
  }

  export type BookingRequestUpdateWithWhereUniqueWithoutReviewedByUserInput = {
    where: BookingRequestWhereUniqueInput
    data: XOR<BookingRequestUpdateWithoutReviewedByUserInput, BookingRequestUncheckedUpdateWithoutReviewedByUserInput>
  }

  export type BookingRequestUpdateManyWithWhereWithoutReviewedByUserInput = {
    where: BookingRequestScalarWhereInput
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyWithoutReviewedByUserInput>
  }

  export type ServiceFormUpsertWithWhereUniqueWithoutGeneratedByUserInput = {
    where: ServiceFormWhereUniqueInput
    update: XOR<ServiceFormUpdateWithoutGeneratedByUserInput, ServiceFormUncheckedUpdateWithoutGeneratedByUserInput>
    create: XOR<ServiceFormCreateWithoutGeneratedByUserInput, ServiceFormUncheckedCreateWithoutGeneratedByUserInput>
  }

  export type ServiceFormUpdateWithWhereUniqueWithoutGeneratedByUserInput = {
    where: ServiceFormWhereUniqueInput
    data: XOR<ServiceFormUpdateWithoutGeneratedByUserInput, ServiceFormUncheckedUpdateWithoutGeneratedByUserInput>
  }

  export type ServiceFormUpdateManyWithWhereWithoutGeneratedByUserInput = {
    where: ServiceFormScalarWhereInput
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyWithoutGeneratedByUserInput>
  }

  export type ServiceFormScalarWhereInput = {
    AND?: ServiceFormScalarWhereInput | ServiceFormScalarWhereInput[]
    OR?: ServiceFormScalarWhereInput[]
    NOT?: ServiceFormScalarWhereInput | ServiceFormScalarWhereInput[]
    id?: UuidFilter<"ServiceForm"> | string
    bookingRequestId?: UuidFilter<"ServiceForm"> | string
    formNumber?: StringFilter<"ServiceForm"> | string
    costCentre?: StringNullableFilter<"ServiceForm"> | string | null
    facilityLab?: StringFilter<"ServiceForm"> | string
    staffPicName?: StringNullableFilter<"ServiceForm"> | string | null
    staffPicEmail?: StringNullableFilter<"ServiceForm"> | string | null
    staffPicPhone?: StringNullableFilter<"ServiceForm"> | string | null
    subtotal?: DecimalFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"ServiceForm"> | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFilter<"ServiceForm"> | Date | string
    status?: Enumform_status_enumFilter<"ServiceForm"> | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFilter<"ServiceForm"> | string
    serviceFormSignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    requiresWorkingAreaAgreement?: BoolFilter<"ServiceForm"> | boolean
    workingAreaAgreementUnsignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    workingAreaAgreementSignedPdfPath?: StringNullableFilter<"ServiceForm"> | string | null
    generatedAt?: DateTimeFilter<"ServiceForm"> | Date | string
    generatedBy?: UuidFilter<"ServiceForm"> | string
    downloadedAt?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedAt?: DateTimeNullableFilter<"ServiceForm"> | Date | string | null
    signedFormsUploadedBy?: UuidNullableFilter<"ServiceForm"> | string | null
    createdAt?: DateTimeFilter<"ServiceForm"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceForm"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUploadedByUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUploadedByUserInput, InvoiceUncheckedUpdateWithoutUploadedByUserInput>
    create: XOR<InvoiceCreateWithoutUploadedByUserInput, InvoiceUncheckedCreateWithoutUploadedByUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUploadedByUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUploadedByUserInput, InvoiceUncheckedUpdateWithoutUploadedByUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUploadedByUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUploadedByUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    serviceFormId?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFilter<"Invoice"> | $Enums.invoice_status_enum
    filePath?: StringFilter<"Invoice"> | string
    uploadedBy?: UuidFilter<"Invoice"> | string
    uploadedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutVerifiedByUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutVerifiedByUserInput, PaymentUncheckedUpdateWithoutVerifiedByUserInput>
    create: XOR<PaymentCreateWithoutVerifiedByUserInput, PaymentUncheckedCreateWithoutVerifiedByUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutVerifiedByUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutVerifiedByUserInput, PaymentUncheckedUpdateWithoutVerifiedByUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutVerifiedByUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutVerifiedByUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    invoiceId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFilter<"Payment"> | $Enums.payment_method_enum
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    receiptFilePath?: StringFilter<"Payment"> | string
    status?: Enumpayment_status_enumFilter<"Payment"> | $Enums.payment_status_enum
    uploadedBy?: UuidFilter<"Payment"> | string
    uploadedAt?: DateTimeFilter<"Payment"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    verifiedBy?: UuidNullableFilter<"Payment"> | string | null
    verificationNotes?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type AnalysisResultUpsertWithWhereUniqueWithoutUploadedByUserInput = {
    where: AnalysisResultWhereUniqueInput
    update: XOR<AnalysisResultUpdateWithoutUploadedByUserInput, AnalysisResultUncheckedUpdateWithoutUploadedByUserInput>
    create: XOR<AnalysisResultCreateWithoutUploadedByUserInput, AnalysisResultUncheckedCreateWithoutUploadedByUserInput>
  }

  export type AnalysisResultUpdateWithWhereUniqueWithoutUploadedByUserInput = {
    where: AnalysisResultWhereUniqueInput
    data: XOR<AnalysisResultUpdateWithoutUploadedByUserInput, AnalysisResultUncheckedUpdateWithoutUploadedByUserInput>
  }

  export type AnalysisResultUpdateManyWithWhereWithoutUploadedByUserInput = {
    where: AnalysisResultScalarWhereInput
    data: XOR<AnalysisResultUpdateManyMutationInput, AnalysisResultUncheckedUpdateManyWithoutUploadedByUserInput>
  }

  export type AnalysisResultScalarWhereInput = {
    AND?: AnalysisResultScalarWhereInput | AnalysisResultScalarWhereInput[]
    OR?: AnalysisResultScalarWhereInput[]
    NOT?: AnalysisResultScalarWhereInput | AnalysisResultScalarWhereInput[]
    id?: UuidFilter<"AnalysisResult"> | string
    sampleTrackingId?: UuidFilter<"AnalysisResult"> | string
    fileName?: StringFilter<"AnalysisResult"> | string
    filePath?: StringFilter<"AnalysisResult"> | string
    fileSize?: IntFilter<"AnalysisResult"> | number
    fileType?: StringFilter<"AnalysisResult"> | string
    description?: StringNullableFilter<"AnalysisResult"> | string | null
    uploadedBy?: UuidFilter<"AnalysisResult"> | string
    uploadedAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    createdAt?: DateTimeFilter<"AnalysisResult"> | Date | string
    updatedAt?: DateTimeFilter<"AnalysisResult"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: Enumnotification_type_enumFilter<"Notification"> | $Enums.notification_type_enum
    relatedEntityType?: StringNullableFilter<"Notification"> | string | null
    relatedEntityId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    emailSent?: BoolFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type SampleTrackingUpsertWithWhereUniqueWithoutUpdatedByUserInput = {
    where: SampleTrackingWhereUniqueInput
    update: XOR<SampleTrackingUpdateWithoutUpdatedByUserInput, SampleTrackingUncheckedUpdateWithoutUpdatedByUserInput>
    create: XOR<SampleTrackingCreateWithoutUpdatedByUserInput, SampleTrackingUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type SampleTrackingUpdateWithWhereUniqueWithoutUpdatedByUserInput = {
    where: SampleTrackingWhereUniqueInput
    data: XOR<SampleTrackingUpdateWithoutUpdatedByUserInput, SampleTrackingUncheckedUpdateWithoutUpdatedByUserInput>
  }

  export type SampleTrackingUpdateManyWithWhereWithoutUpdatedByUserInput = {
    where: SampleTrackingScalarWhereInput
    data: XOR<SampleTrackingUpdateManyMutationInput, SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserInput>
  }

  export type SampleTrackingScalarWhereInput = {
    AND?: SampleTrackingScalarWhereInput | SampleTrackingScalarWhereInput[]
    OR?: SampleTrackingScalarWhereInput[]
    NOT?: SampleTrackingScalarWhereInput | SampleTrackingScalarWhereInput[]
    id?: UuidFilter<"SampleTracking"> | string
    bookingServiceItemId?: UuidFilter<"SampleTracking"> | string
    sampleIdentifier?: StringFilter<"SampleTracking"> | string
    status?: Enumsample_status_enumFilter<"SampleTracking"> | $Enums.sample_status_enum
    receivedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    analysisStartAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    analysisCompleteAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    returnRequestedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"SampleTracking"> | Date | string | null
    notes?: StringNullableFilter<"SampleTracking"> | string | null
    updatedBy?: UuidNullableFilter<"SampleTracking"> | string | null
    createdAt?: DateTimeFilter<"SampleTracking"> | Date | string
    updatedAt?: DateTimeFilter<"SampleTracking"> | Date | string
  }

  export type SampleModificationUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: SampleModificationWhereUniqueInput
    update: XOR<SampleModificationUpdateWithoutCreatedByUserInput, SampleModificationUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<SampleModificationCreateWithoutCreatedByUserInput, SampleModificationUncheckedCreateWithoutCreatedByUserInput>
  }

  export type SampleModificationUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: SampleModificationWhereUniqueInput
    data: XOR<SampleModificationUpdateWithoutCreatedByUserInput, SampleModificationUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type SampleModificationUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: SampleModificationScalarWhereInput
    data: XOR<SampleModificationUpdateManyMutationInput, SampleModificationUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type SampleModificationScalarWhereInput = {
    AND?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
    OR?: SampleModificationScalarWhereInput[]
    NOT?: SampleModificationScalarWhereInput | SampleModificationScalarWhereInput[]
    id?: UuidFilter<"SampleModification"> | string
    bookingServiceItemId?: UuidFilter<"SampleModification"> | string
    originalQuantity?: IntFilter<"SampleModification"> | number
    newQuantity?: IntFilter<"SampleModification"> | number
    originalDurationMonths?: IntFilter<"SampleModification"> | number
    newDurationMonths?: IntFilter<"SampleModification"> | number
    originalTotalPrice?: DecimalFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFilter<"SampleModification"> | Decimal | DecimalJsLike | number | string
    reason?: StringFilter<"SampleModification"> | string
    status?: Enummodification_status_enumFilter<"SampleModification"> | $Enums.modification_status_enum
    createdBy?: UuidFilter<"SampleModification"> | string
    createdAt?: DateTimeFilter<"SampleModification"> | Date | string
    approvedAt?: DateTimeNullableFilter<"SampleModification"> | Date | string | null
    approvedBy?: UuidNullableFilter<"SampleModification"> | string | null
  }

  export type SampleModificationUpsertWithWhereUniqueWithoutApprovedByUserInput = {
    where: SampleModificationWhereUniqueInput
    update: XOR<SampleModificationUpdateWithoutApprovedByUserInput, SampleModificationUncheckedUpdateWithoutApprovedByUserInput>
    create: XOR<SampleModificationCreateWithoutApprovedByUserInput, SampleModificationUncheckedCreateWithoutApprovedByUserInput>
  }

  export type SampleModificationUpdateWithWhereUniqueWithoutApprovedByUserInput = {
    where: SampleModificationWhereUniqueInput
    data: XOR<SampleModificationUpdateWithoutApprovedByUserInput, SampleModificationUncheckedUpdateWithoutApprovedByUserInput>
  }

  export type SampleModificationUpdateManyWithWhereWithoutApprovedByUserInput = {
    where: SampleModificationScalarWhereInput
    data: XOR<SampleModificationUpdateManyMutationInput, SampleModificationUncheckedUpdateManyWithoutApprovedByUserInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutUploadedByUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUploadedByUserInput, PaymentUncheckedUpdateWithoutUploadedByUserInput>
    create: XOR<PaymentCreateWithoutUploadedByUserInput, PaymentUncheckedCreateWithoutUploadedByUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUploadedByUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUploadedByUserInput, PaymentUncheckedUpdateWithoutUploadedByUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUploadedByUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUploadedByUserInput>
  }

  export type UserCreateWithoutAuthProvidersInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutAuthProvidersInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutAuthProvidersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
  }

  export type UserUpsertWithoutAuthProvidersInput = {
    update: XOR<UserUpdateWithoutAuthProvidersInput, UserUncheckedUpdateWithoutAuthProvidersInput>
    create: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthProvidersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthProvidersInput, UserUncheckedUpdateWithoutAuthProvidersInput>
  }

  export type UserUpdateWithoutAuthProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type ServicePricingCreateWithoutServiceInput = {
    id?: string
    userType: $Enums.user_type_enum
    price: Decimal | DecimalJsLike | number | string
    unit: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePricingUncheckedCreateWithoutServiceInput = {
    id?: string
    userType: $Enums.user_type_enum
    price: Decimal | DecimalJsLike | number | string
    unit: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePricingCreateOrConnectWithoutServiceInput = {
    where: ServicePricingWhereUniqueInput
    create: XOR<ServicePricingCreateWithoutServiceInput, ServicePricingUncheckedCreateWithoutServiceInput>
  }

  export type ServicePricingCreateManyServiceInputEnvelope = {
    data: ServicePricingCreateManyServiceInput | ServicePricingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BookingServiceItemCreateWithoutServiceInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceItemsInput
    equipmentUsages?: SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateWithoutServiceInput = {
    id?: string
    bookingRequestId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemCreateOrConnectWithoutServiceInput = {
    where: BookingServiceItemWhereUniqueInput
    create: XOR<BookingServiceItemCreateWithoutServiceInput, BookingServiceItemUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceItemCreateManyServiceInputEnvelope = {
    data: BookingServiceItemCreateManyServiceInput | BookingServiceItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAddOnMappingCreateWithoutServiceInput = {
    id?: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    addOnCatalog: GlobalAddOnCatalogCreateNestedOneWithoutServiceMappingsInput
  }

  export type ServiceAddOnMappingUncheckedCreateWithoutServiceInput = {
    id?: string
    addOnId: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnMappingCreateOrConnectWithoutServiceInput = {
    where: ServiceAddOnMappingWhereUniqueInput
    create: XOR<ServiceAddOnMappingCreateWithoutServiceInput, ServiceAddOnMappingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceAddOnMappingCreateManyServiceInputEnvelope = {
    data: ServiceAddOnMappingCreateManyServiceInput | ServiceAddOnMappingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServicePricingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServicePricingWhereUniqueInput
    update: XOR<ServicePricingUpdateWithoutServiceInput, ServicePricingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServicePricingCreateWithoutServiceInput, ServicePricingUncheckedCreateWithoutServiceInput>
  }

  export type ServicePricingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServicePricingWhereUniqueInput
    data: XOR<ServicePricingUpdateWithoutServiceInput, ServicePricingUncheckedUpdateWithoutServiceInput>
  }

  export type ServicePricingUpdateManyWithWhereWithoutServiceInput = {
    where: ServicePricingScalarWhereInput
    data: XOR<ServicePricingUpdateManyMutationInput, ServicePricingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServicePricingScalarWhereInput = {
    AND?: ServicePricingScalarWhereInput | ServicePricingScalarWhereInput[]
    OR?: ServicePricingScalarWhereInput[]
    NOT?: ServicePricingScalarWhereInput | ServicePricingScalarWhereInput[]
    id?: UuidFilter<"ServicePricing"> | string
    serviceId?: UuidFilter<"ServicePricing"> | string
    userType?: Enumuser_type_enumFilter<"ServicePricing"> | $Enums.user_type_enum
    price?: DecimalFilter<"ServicePricing"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"ServicePricing"> | string
    effectiveFrom?: DateTimeFilter<"ServicePricing"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"ServicePricing"> | Date | string | null
    createdAt?: DateTimeFilter<"ServicePricing"> | Date | string
    updatedAt?: DateTimeFilter<"ServicePricing"> | Date | string
  }

  export type BookingServiceItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceItemWhereUniqueInput
    update: XOR<BookingServiceItemUpdateWithoutServiceInput, BookingServiceItemUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingServiceItemCreateWithoutServiceInput, BookingServiceItemUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceItemWhereUniqueInput
    data: XOR<BookingServiceItemUpdateWithoutServiceInput, BookingServiceItemUncheckedUpdateWithoutServiceInput>
  }

  export type BookingServiceItemUpdateManyWithWhereWithoutServiceInput = {
    where: BookingServiceItemScalarWhereInput
    data: XOR<BookingServiceItemUpdateManyMutationInput, BookingServiceItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type BookingServiceItemScalarWhereInput = {
    AND?: BookingServiceItemScalarWhereInput | BookingServiceItemScalarWhereInput[]
    OR?: BookingServiceItemScalarWhereInput[]
    NOT?: BookingServiceItemScalarWhereInput | BookingServiceItemScalarWhereInput[]
    id?: UuidFilter<"BookingServiceItem"> | string
    bookingRequestId?: UuidFilter<"BookingServiceItem"> | string
    serviceId?: UuidFilter<"BookingServiceItem"> | string
    quantity?: IntFilter<"BookingServiceItem"> | number
    durationMonths?: IntFilter<"BookingServiceItem"> | number
    unitPrice?: DecimalFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string
    sampleName?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleDetails?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleType?: StringNullableFilter<"BookingServiceItem"> | string | null
    sampleHazard?: StringNullableFilter<"BookingServiceItem"> | string | null
    testingMethod?: StringNullableFilter<"BookingServiceItem"> | string | null
    degasConditions?: StringNullableFilter<"BookingServiceItem"> | string | null
    solventSystem?: StringNullableFilter<"BookingServiceItem"> | string | null
    solvents?: StringNullableFilter<"BookingServiceItem"> | string | null
    solventComposition?: StringNullableFilter<"BookingServiceItem"> | string | null
    columnType?: StringNullableFilter<"BookingServiceItem"> | string | null
    flowRate?: DecimalNullableFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    wavelength?: IntNullableFilter<"BookingServiceItem"> | number | null
    expectedRetentionTime?: DecimalNullableFilter<"BookingServiceItem"> | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: StringNullableFilter<"BookingServiceItem"> | string | null
    notes?: StringNullableFilter<"BookingServiceItem"> | string | null
    expectedCompletionDate?: DateTimeNullableFilter<"BookingServiceItem"> | Date | string | null
    actualCompletionDate?: DateTimeNullableFilter<"BookingServiceItem"> | Date | string | null
    turnaroundEstimate?: StringNullableFilter<"BookingServiceItem"> | string | null
    hplcPreparationRequired?: BoolFilter<"BookingServiceItem"> | boolean
    temperatureControlled?: BoolFilter<"BookingServiceItem"> | boolean
    lightSensitive?: BoolFilter<"BookingServiceItem"> | boolean
    hazardousMaterial?: BoolFilter<"BookingServiceItem"> | boolean
    inertAtmosphere?: BoolFilter<"BookingServiceItem"> | boolean
    otherEquipmentRequests?: JsonNullableFilter<"BookingServiceItem">
    createdAt?: DateTimeFilter<"BookingServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"BookingServiceItem"> | Date | string
  }

  export type ServiceAddOnMappingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceAddOnMappingWhereUniqueInput
    update: XOR<ServiceAddOnMappingUpdateWithoutServiceInput, ServiceAddOnMappingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceAddOnMappingCreateWithoutServiceInput, ServiceAddOnMappingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceAddOnMappingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceAddOnMappingWhereUniqueInput
    data: XOR<ServiceAddOnMappingUpdateWithoutServiceInput, ServiceAddOnMappingUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceAddOnMappingUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceAddOnMappingScalarWhereInput
    data: XOR<ServiceAddOnMappingUpdateManyMutationInput, ServiceAddOnMappingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceAddOnMappingScalarWhereInput = {
    AND?: ServiceAddOnMappingScalarWhereInput | ServiceAddOnMappingScalarWhereInput[]
    OR?: ServiceAddOnMappingScalarWhereInput[]
    NOT?: ServiceAddOnMappingScalarWhereInput | ServiceAddOnMappingScalarWhereInput[]
    id?: UuidFilter<"ServiceAddOnMapping"> | string
    serviceId?: UuidFilter<"ServiceAddOnMapping"> | string
    addOnId?: UuidFilter<"ServiceAddOnMapping"> | string
    isEnabled?: BoolFilter<"ServiceAddOnMapping"> | boolean
    customAmount?: DecimalNullableFilter<"ServiceAddOnMapping"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ServiceAddOnMapping"> | Date | string
  }

  export type ServiceCreateWithoutPricingInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingItems?: BookingServiceItemCreateNestedManyWithoutServiceInput
    addOnMappings?: ServiceAddOnMappingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPricingInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingItems?: BookingServiceItemUncheckedCreateNestedManyWithoutServiceInput
    addOnMappings?: ServiceAddOnMappingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPricingInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPricingInput, ServiceUncheckedCreateWithoutPricingInput>
  }

  export type ServiceUpsertWithoutPricingInput = {
    update: XOR<ServiceUpdateWithoutPricingInput, ServiceUncheckedUpdateWithoutPricingInput>
    create: XOR<ServiceCreateWithoutPricingInput, ServiceUncheckedCreateWithoutPricingInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPricingInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPricingInput, ServiceUncheckedUpdateWithoutPricingInput>
  }

  export type ServiceUpdateWithoutPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingItems?: BookingServiceItemUpdateManyWithoutServiceNestedInput
    addOnMappings?: ServiceAddOnMappingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingItems?: BookingServiceItemUncheckedUpdateManyWithoutServiceNestedInput
    addOnMappings?: ServiceAddOnMappingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutBookingRequestsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutBookingRequestsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutBookingRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingRequestsInput, UserUncheckedCreateWithoutBookingRequestsInput>
  }

  export type UserCreateWithoutApprovedBookingsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutApprovedBookingsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutApprovedBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedBookingsInput, UserUncheckedCreateWithoutApprovedBookingsInput>
  }

  export type CompanyCreateWithoutBookingsInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: CompanyBranchCreateNestedManyWithoutCompanyInput
    users?: UserCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    legalName?: string | null
    regNo?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: CompanyBranchUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserUncheckedCreateNestedManyWithoutCompanyRelationInput
  }

  export type CompanyCreateOrConnectWithoutBookingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
  }

  export type CompanyBranchCreateWithoutBookingsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBranchesInput
    users?: UserCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchUncheckedCreateWithoutBookingsInput = {
    id?: string
    companyId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyBranchInput
  }

  export type CompanyBranchCreateOrConnectWithoutBookingsInput = {
    where: CompanyBranchWhereUniqueInput
    create: XOR<CompanyBranchCreateWithoutBookingsInput, CompanyBranchUncheckedCreateWithoutBookingsInput>
  }

  export type BookingServiceItemCreateWithoutBookingRequestInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutBookingItemsInput
    equipmentUsages?: SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateWithoutBookingRequestInput = {
    id?: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemCreateOrConnectWithoutBookingRequestInput = {
    where: BookingServiceItemWhereUniqueInput
    create: XOR<BookingServiceItemCreateWithoutBookingRequestInput, BookingServiceItemUncheckedCreateWithoutBookingRequestInput>
  }

  export type BookingServiceItemCreateManyBookingRequestInputEnvelope = {
    data: BookingServiceItemCreateManyBookingRequestInput | BookingServiceItemCreateManyBookingRequestInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceBookingCreateWithoutBookingRequestInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: WorkspaceEquipmentUsageCreateNestedManyWithoutWorkspaceBookingInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingUncheckedCreateWithoutBookingRequestInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutWorkspaceBookingInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingCreateOrConnectWithoutBookingRequestInput = {
    where: WorkspaceBookingWhereUniqueInput
    create: XOR<WorkspaceBookingCreateWithoutBookingRequestInput, WorkspaceBookingUncheckedCreateWithoutBookingRequestInput>
  }

  export type WorkspaceBookingCreateManyBookingRequestInputEnvelope = {
    data: WorkspaceBookingCreateManyBookingRequestInput | WorkspaceBookingCreateManyBookingRequestInput[]
    skipDuplicates?: boolean
  }

  export type ServiceFormCreateWithoutBookingRequestInput = {
    id?: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedByUser: UserCreateNestedOneWithoutServiceFormsInput
    invoices?: InvoiceCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormUncheckedCreateWithoutBookingRequestInput = {
    id?: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    generatedBy: string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutServiceFormInput
  }

  export type ServiceFormCreateOrConnectWithoutBookingRequestInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutBookingRequestInput, ServiceFormUncheckedCreateWithoutBookingRequestInput>
  }

  export type ServiceFormCreateManyBookingRequestInputEnvelope = {
    data: ServiceFormCreateManyBookingRequestInput | ServiceFormCreateManyBookingRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBookingRequestsInput = {
    update: XOR<UserUpdateWithoutBookingRequestsInput, UserUncheckedUpdateWithoutBookingRequestsInput>
    create: XOR<UserCreateWithoutBookingRequestsInput, UserUncheckedCreateWithoutBookingRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingRequestsInput, UserUncheckedUpdateWithoutBookingRequestsInput>
  }

  export type UserUpdateWithoutBookingRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUpsertWithoutApprovedBookingsInput = {
    update: XOR<UserUpdateWithoutApprovedBookingsInput, UserUncheckedUpdateWithoutApprovedBookingsInput>
    create: XOR<UserCreateWithoutApprovedBookingsInput, UserUncheckedCreateWithoutApprovedBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedBookingsInput, UserUncheckedUpdateWithoutApprovedBookingsInput>
  }

  export type UserUpdateWithoutApprovedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type CompanyUpsertWithoutBookingsInput = {
    update: XOR<CompanyUpdateWithoutBookingsInput, CompanyUncheckedUpdateWithoutBookingsInput>
    create: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBookingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBookingsInput, CompanyUncheckedUpdateWithoutBookingsInput>
  }

  export type CompanyUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: CompanyBranchUpdateManyWithoutCompanyNestedInput
    users?: UserUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: CompanyBranchUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserUncheckedUpdateManyWithoutCompanyRelationNestedInput
  }

  export type CompanyBranchUpsertWithoutBookingsInput = {
    update: XOR<CompanyBranchUpdateWithoutBookingsInput, CompanyBranchUncheckedUpdateWithoutBookingsInput>
    create: XOR<CompanyBranchCreateWithoutBookingsInput, CompanyBranchUncheckedCreateWithoutBookingsInput>
    where?: CompanyBranchWhereInput
  }

  export type CompanyBranchUpdateToOneWithWhereWithoutBookingsInput = {
    where?: CompanyBranchWhereInput
    data: XOR<CompanyBranchUpdateWithoutBookingsInput, CompanyBranchUncheckedUpdateWithoutBookingsInput>
  }

  export type CompanyBranchUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBranchesNestedInput
    users?: UserUpdateManyWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyBranchNestedInput
  }

  export type BookingServiceItemUpsertWithWhereUniqueWithoutBookingRequestInput = {
    where: BookingServiceItemWhereUniqueInput
    update: XOR<BookingServiceItemUpdateWithoutBookingRequestInput, BookingServiceItemUncheckedUpdateWithoutBookingRequestInput>
    create: XOR<BookingServiceItemCreateWithoutBookingRequestInput, BookingServiceItemUncheckedCreateWithoutBookingRequestInput>
  }

  export type BookingServiceItemUpdateWithWhereUniqueWithoutBookingRequestInput = {
    where: BookingServiceItemWhereUniqueInput
    data: XOR<BookingServiceItemUpdateWithoutBookingRequestInput, BookingServiceItemUncheckedUpdateWithoutBookingRequestInput>
  }

  export type BookingServiceItemUpdateManyWithWhereWithoutBookingRequestInput = {
    where: BookingServiceItemScalarWhereInput
    data: XOR<BookingServiceItemUpdateManyMutationInput, BookingServiceItemUncheckedUpdateManyWithoutBookingRequestInput>
  }

  export type WorkspaceBookingUpsertWithWhereUniqueWithoutBookingRequestInput = {
    where: WorkspaceBookingWhereUniqueInput
    update: XOR<WorkspaceBookingUpdateWithoutBookingRequestInput, WorkspaceBookingUncheckedUpdateWithoutBookingRequestInput>
    create: XOR<WorkspaceBookingCreateWithoutBookingRequestInput, WorkspaceBookingUncheckedCreateWithoutBookingRequestInput>
  }

  export type WorkspaceBookingUpdateWithWhereUniqueWithoutBookingRequestInput = {
    where: WorkspaceBookingWhereUniqueInput
    data: XOR<WorkspaceBookingUpdateWithoutBookingRequestInput, WorkspaceBookingUncheckedUpdateWithoutBookingRequestInput>
  }

  export type WorkspaceBookingUpdateManyWithWhereWithoutBookingRequestInput = {
    where: WorkspaceBookingScalarWhereInput
    data: XOR<WorkspaceBookingUpdateManyMutationInput, WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestInput>
  }

  export type WorkspaceBookingScalarWhereInput = {
    AND?: WorkspaceBookingScalarWhereInput | WorkspaceBookingScalarWhereInput[]
    OR?: WorkspaceBookingScalarWhereInput[]
    NOT?: WorkspaceBookingScalarWhereInput | WorkspaceBookingScalarWhereInput[]
    id?: UuidFilter<"WorkspaceBooking"> | string
    bookingRequestId?: UuidFilter<"WorkspaceBooking"> | string
    startDate?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    endDate?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    preferredTimeSlot?: StringNullableFilter<"WorkspaceBooking"> | string | null
    specialEquipment?: JsonNullableFilter<"WorkspaceBooking">
    purpose?: StringNullableFilter<"WorkspaceBooking"> | string | null
    notes?: StringNullableFilter<"WorkspaceBooking"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceBooking"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceBooking"> | Date | string
  }

  export type ServiceFormUpsertWithWhereUniqueWithoutBookingRequestInput = {
    where: ServiceFormWhereUniqueInput
    update: XOR<ServiceFormUpdateWithoutBookingRequestInput, ServiceFormUncheckedUpdateWithoutBookingRequestInput>
    create: XOR<ServiceFormCreateWithoutBookingRequestInput, ServiceFormUncheckedCreateWithoutBookingRequestInput>
  }

  export type ServiceFormUpdateWithWhereUniqueWithoutBookingRequestInput = {
    where: ServiceFormWhereUniqueInput
    data: XOR<ServiceFormUpdateWithoutBookingRequestInput, ServiceFormUncheckedUpdateWithoutBookingRequestInput>
  }

  export type ServiceFormUpdateManyWithWhereWithoutBookingRequestInput = {
    where: ServiceFormScalarWhereInput
    data: XOR<ServiceFormUpdateManyMutationInput, ServiceFormUncheckedUpdateManyWithoutBookingRequestInput>
  }

  export type BookingRequestCreateWithoutServiceItemsInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutServiceItemsInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutServiceItemsInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutServiceItemsInput, BookingRequestUncheckedCreateWithoutServiceItemsInput>
  }

  export type ServiceCreateWithoutBookingItemsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: ServicePricingCreateNestedManyWithoutServiceInput
    addOnMappings?: ServiceAddOnMappingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingItemsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: ServicePricingUncheckedCreateNestedManyWithoutServiceInput
    addOnMappings?: ServiceAddOnMappingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingItemsInput, ServiceUncheckedCreateWithoutBookingItemsInput>
  }

  export type SampleEquipmentUsageCreateWithoutBookedItemInput = {
    id?: string
    createdAt?: Date | string
    equipment: LabEquipmentCreateNestedOneWithoutSampleUsagesInput
  }

  export type SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput = {
    id?: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type SampleEquipmentUsageCreateOrConnectWithoutBookedItemInput = {
    where: SampleEquipmentUsageWhereUniqueInput
    create: XOR<SampleEquipmentUsageCreateWithoutBookedItemInput, SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput>
  }

  export type SampleEquipmentUsageCreateManyBookedItemInputEnvelope = {
    data: SampleEquipmentUsageCreateManyBookedItemInput | SampleEquipmentUsageCreateManyBookedItemInput[]
    skipDuplicates?: boolean
  }

  export type SampleModificationCreateWithoutBookingServiceItemInput = {
    id?: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdAt?: Date | string
    approvedAt?: Date | string | null
    createdByUser: UserCreateNestedOneWithoutCreatedModificationsInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedModificationsInput
  }

  export type SampleModificationUncheckedCreateWithoutBookingServiceItemInput = {
    id?: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type SampleModificationCreateOrConnectWithoutBookingServiceItemInput = {
    where: SampleModificationWhereUniqueInput
    create: XOR<SampleModificationCreateWithoutBookingServiceItemInput, SampleModificationUncheckedCreateWithoutBookingServiceItemInput>
  }

  export type SampleModificationCreateManyBookingServiceItemInputEnvelope = {
    data: SampleModificationCreateManyBookingServiceItemInput | SampleModificationCreateManyBookingServiceItemInput[]
    skipDuplicates?: boolean
  }

  export type SampleTrackingCreateWithoutBookingServiceItemInput = {
    id?: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedByUser?: UserCreateNestedOneWithoutSampleTrackingInput
    analysisResults?: AnalysisResultCreateNestedManyWithoutSampleTrackingInput
  }

  export type SampleTrackingUncheckedCreateWithoutBookingServiceItemInput = {
    id?: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    analysisResults?: AnalysisResultUncheckedCreateNestedManyWithoutSampleTrackingInput
  }

  export type SampleTrackingCreateOrConnectWithoutBookingServiceItemInput = {
    where: SampleTrackingWhereUniqueInput
    create: XOR<SampleTrackingCreateWithoutBookingServiceItemInput, SampleTrackingUncheckedCreateWithoutBookingServiceItemInput>
  }

  export type SampleTrackingCreateManyBookingServiceItemInputEnvelope = {
    data: SampleTrackingCreateManyBookingServiceItemInput | SampleTrackingCreateManyBookingServiceItemInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAddOnCreateWithoutBookingServiceItemInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
    workspaceBooking?: WorkspaceBookingCreateNestedOneWithoutServiceAddOnsInput
    addOnCatalog: GlobalAddOnCatalogCreateNestedOneWithoutServiceAddOnsInput
  }

  export type ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput = {
    id?: string
    workspaceBookingId?: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnCreateOrConnectWithoutBookingServiceItemInput = {
    where: ServiceAddOnWhereUniqueInput
    create: XOR<ServiceAddOnCreateWithoutBookingServiceItemInput, ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput>
  }

  export type ServiceAddOnCreateManyBookingServiceItemInputEnvelope = {
    data: ServiceAddOnCreateManyBookingServiceItemInput | ServiceAddOnCreateManyBookingServiceItemInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestUpsertWithoutServiceItemsInput = {
    update: XOR<BookingRequestUpdateWithoutServiceItemsInput, BookingRequestUncheckedUpdateWithoutServiceItemsInput>
    create: XOR<BookingRequestCreateWithoutServiceItemsInput, BookingRequestUncheckedCreateWithoutServiceItemsInput>
    where?: BookingRequestWhereInput
  }

  export type BookingRequestUpdateToOneWithWhereWithoutServiceItemsInput = {
    where?: BookingRequestWhereInput
    data: XOR<BookingRequestUpdateWithoutServiceItemsInput, BookingRequestUncheckedUpdateWithoutServiceItemsInput>
  }

  export type BookingRequestUpdateWithoutServiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutServiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type ServiceUpsertWithoutBookingItemsInput = {
    update: XOR<ServiceUpdateWithoutBookingItemsInput, ServiceUncheckedUpdateWithoutBookingItemsInput>
    create: XOR<ServiceCreateWithoutBookingItemsInput, ServiceUncheckedCreateWithoutBookingItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingItemsInput, ServiceUncheckedUpdateWithoutBookingItemsInput>
  }

  export type ServiceUpdateWithoutBookingItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: ServicePricingUpdateManyWithoutServiceNestedInput
    addOnMappings?: ServiceAddOnMappingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: ServicePricingUncheckedUpdateManyWithoutServiceNestedInput
    addOnMappings?: ServiceAddOnMappingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type SampleEquipmentUsageUpsertWithWhereUniqueWithoutBookedItemInput = {
    where: SampleEquipmentUsageWhereUniqueInput
    update: XOR<SampleEquipmentUsageUpdateWithoutBookedItemInput, SampleEquipmentUsageUncheckedUpdateWithoutBookedItemInput>
    create: XOR<SampleEquipmentUsageCreateWithoutBookedItemInput, SampleEquipmentUsageUncheckedCreateWithoutBookedItemInput>
  }

  export type SampleEquipmentUsageUpdateWithWhereUniqueWithoutBookedItemInput = {
    where: SampleEquipmentUsageWhereUniqueInput
    data: XOR<SampleEquipmentUsageUpdateWithoutBookedItemInput, SampleEquipmentUsageUncheckedUpdateWithoutBookedItemInput>
  }

  export type SampleEquipmentUsageUpdateManyWithWhereWithoutBookedItemInput = {
    where: SampleEquipmentUsageScalarWhereInput
    data: XOR<SampleEquipmentUsageUpdateManyMutationInput, SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemInput>
  }

  export type SampleEquipmentUsageScalarWhereInput = {
    AND?: SampleEquipmentUsageScalarWhereInput | SampleEquipmentUsageScalarWhereInput[]
    OR?: SampleEquipmentUsageScalarWhereInput[]
    NOT?: SampleEquipmentUsageScalarWhereInput | SampleEquipmentUsageScalarWhereInput[]
    id?: UuidFilter<"SampleEquipmentUsage"> | string
    bookingServiceItemId?: UuidFilter<"SampleEquipmentUsage"> | string
    equipmentId?: UuidFilter<"SampleEquipmentUsage"> | string
    createdAt?: DateTimeFilter<"SampleEquipmentUsage"> | Date | string
  }

  export type SampleModificationUpsertWithWhereUniqueWithoutBookingServiceItemInput = {
    where: SampleModificationWhereUniqueInput
    update: XOR<SampleModificationUpdateWithoutBookingServiceItemInput, SampleModificationUncheckedUpdateWithoutBookingServiceItemInput>
    create: XOR<SampleModificationCreateWithoutBookingServiceItemInput, SampleModificationUncheckedCreateWithoutBookingServiceItemInput>
  }

  export type SampleModificationUpdateWithWhereUniqueWithoutBookingServiceItemInput = {
    where: SampleModificationWhereUniqueInput
    data: XOR<SampleModificationUpdateWithoutBookingServiceItemInput, SampleModificationUncheckedUpdateWithoutBookingServiceItemInput>
  }

  export type SampleModificationUpdateManyWithWhereWithoutBookingServiceItemInput = {
    where: SampleModificationScalarWhereInput
    data: XOR<SampleModificationUpdateManyMutationInput, SampleModificationUncheckedUpdateManyWithoutBookingServiceItemInput>
  }

  export type SampleTrackingUpsertWithWhereUniqueWithoutBookingServiceItemInput = {
    where: SampleTrackingWhereUniqueInput
    update: XOR<SampleTrackingUpdateWithoutBookingServiceItemInput, SampleTrackingUncheckedUpdateWithoutBookingServiceItemInput>
    create: XOR<SampleTrackingCreateWithoutBookingServiceItemInput, SampleTrackingUncheckedCreateWithoutBookingServiceItemInput>
  }

  export type SampleTrackingUpdateWithWhereUniqueWithoutBookingServiceItemInput = {
    where: SampleTrackingWhereUniqueInput
    data: XOR<SampleTrackingUpdateWithoutBookingServiceItemInput, SampleTrackingUncheckedUpdateWithoutBookingServiceItemInput>
  }

  export type SampleTrackingUpdateManyWithWhereWithoutBookingServiceItemInput = {
    where: SampleTrackingScalarWhereInput
    data: XOR<SampleTrackingUpdateManyMutationInput, SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemInput>
  }

  export type ServiceAddOnUpsertWithWhereUniqueWithoutBookingServiceItemInput = {
    where: ServiceAddOnWhereUniqueInput
    update: XOR<ServiceAddOnUpdateWithoutBookingServiceItemInput, ServiceAddOnUncheckedUpdateWithoutBookingServiceItemInput>
    create: XOR<ServiceAddOnCreateWithoutBookingServiceItemInput, ServiceAddOnUncheckedCreateWithoutBookingServiceItemInput>
  }

  export type ServiceAddOnUpdateWithWhereUniqueWithoutBookingServiceItemInput = {
    where: ServiceAddOnWhereUniqueInput
    data: XOR<ServiceAddOnUpdateWithoutBookingServiceItemInput, ServiceAddOnUncheckedUpdateWithoutBookingServiceItemInput>
  }

  export type ServiceAddOnUpdateManyWithWhereWithoutBookingServiceItemInput = {
    where: ServiceAddOnScalarWhereInput
    data: XOR<ServiceAddOnUpdateManyMutationInput, ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemInput>
  }

  export type ServiceAddOnScalarWhereInput = {
    AND?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
    OR?: ServiceAddOnScalarWhereInput[]
    NOT?: ServiceAddOnScalarWhereInput | ServiceAddOnScalarWhereInput[]
    id?: UuidFilter<"ServiceAddOn"> | string
    bookingServiceItemId?: UuidNullableFilter<"ServiceAddOn"> | string | null
    workspaceBookingId?: UuidNullableFilter<"ServiceAddOn"> | string | null
    addOnCatalogId?: UuidFilter<"ServiceAddOn"> | string
    name?: StringFilter<"ServiceAddOn"> | string
    amount?: DecimalFilter<"ServiceAddOn"> | Decimal | DecimalJsLike | number | string
    taxable?: BoolFilter<"ServiceAddOn"> | boolean
    description?: StringNullableFilter<"ServiceAddOn"> | string | null
    createdAt?: DateTimeFilter<"ServiceAddOn"> | Date | string
  }

  export type BookingServiceItemCreateWithoutModificationsInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceItemsInput
    service: ServiceCreateNestedOneWithoutBookingItemsInput
    equipmentUsages?: SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateWithoutModificationsInput = {
    id?: string
    bookingRequestId: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemCreateOrConnectWithoutModificationsInput = {
    where: BookingServiceItemWhereUniqueInput
    create: XOR<BookingServiceItemCreateWithoutModificationsInput, BookingServiceItemUncheckedCreateWithoutModificationsInput>
  }

  export type UserCreateWithoutCreatedModificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedModificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedModificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedModificationsInput, UserUncheckedCreateWithoutCreatedModificationsInput>
  }

  export type UserCreateWithoutApprovedModificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutApprovedModificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutApprovedModificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedModificationsInput, UserUncheckedCreateWithoutApprovedModificationsInput>
  }

  export type BookingServiceItemUpsertWithoutModificationsInput = {
    update: XOR<BookingServiceItemUpdateWithoutModificationsInput, BookingServiceItemUncheckedUpdateWithoutModificationsInput>
    create: XOR<BookingServiceItemCreateWithoutModificationsInput, BookingServiceItemUncheckedCreateWithoutModificationsInput>
    where?: BookingServiceItemWhereInput
  }

  export type BookingServiceItemUpdateToOneWithWhereWithoutModificationsInput = {
    where?: BookingServiceItemWhereInput
    data: XOR<BookingServiceItemUpdateWithoutModificationsInput, BookingServiceItemUncheckedUpdateWithoutModificationsInput>
  }

  export type BookingServiceItemUpdateWithoutModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingItemsNestedInput
    equipmentUsages?: SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateWithoutModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type UserUpsertWithoutCreatedModificationsInput = {
    update: XOR<UserUpdateWithoutCreatedModificationsInput, UserUncheckedUpdateWithoutCreatedModificationsInput>
    create: XOR<UserCreateWithoutCreatedModificationsInput, UserUncheckedCreateWithoutCreatedModificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedModificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedModificationsInput, UserUncheckedUpdateWithoutCreatedModificationsInput>
  }

  export type UserUpdateWithoutCreatedModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUpsertWithoutApprovedModificationsInput = {
    update: XOR<UserUpdateWithoutApprovedModificationsInput, UserUncheckedUpdateWithoutApprovedModificationsInput>
    create: XOR<UserCreateWithoutApprovedModificationsInput, UserUncheckedCreateWithoutApprovedModificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedModificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedModificationsInput, UserUncheckedUpdateWithoutApprovedModificationsInput>
  }

  export type UserUpdateWithoutApprovedModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type BookingRequestCreateWithoutServiceFormsInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutServiceFormsInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    workspaceBookings?: WorkspaceBookingUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutServiceFormsInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutServiceFormsInput, BookingRequestUncheckedCreateWithoutServiceFormsInput>
  }

  export type UserCreateWithoutServiceFormsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutServiceFormsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutServiceFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceFormsInput, UserUncheckedCreateWithoutServiceFormsInput>
  }

  export type InvoiceCreateWithoutServiceFormInput = {
    id?: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedByUser: UserCreateNestedOneWithoutUploadedInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutServiceFormInput = {
    id?: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutServiceFormInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutServiceFormInput, InvoiceUncheckedCreateWithoutServiceFormInput>
  }

  export type InvoiceCreateManyServiceFormInputEnvelope = {
    data: InvoiceCreateManyServiceFormInput | InvoiceCreateManyServiceFormInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestUpsertWithoutServiceFormsInput = {
    update: XOR<BookingRequestUpdateWithoutServiceFormsInput, BookingRequestUncheckedUpdateWithoutServiceFormsInput>
    create: XOR<BookingRequestCreateWithoutServiceFormsInput, BookingRequestUncheckedCreateWithoutServiceFormsInput>
    where?: BookingRequestWhereInput
  }

  export type BookingRequestUpdateToOneWithWhereWithoutServiceFormsInput = {
    where?: BookingRequestWhereInput
    data: XOR<BookingRequestUpdateWithoutServiceFormsInput, BookingRequestUncheckedUpdateWithoutServiceFormsInput>
  }

  export type BookingRequestUpdateWithoutServiceFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutServiceFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type UserUpsertWithoutServiceFormsInput = {
    update: XOR<UserUpdateWithoutServiceFormsInput, UserUncheckedUpdateWithoutServiceFormsInput>
    create: XOR<UserCreateWithoutServiceFormsInput, UserUncheckedCreateWithoutServiceFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceFormsInput, UserUncheckedUpdateWithoutServiceFormsInput>
  }

  export type UserUpdateWithoutServiceFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceFormsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutServiceFormInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutServiceFormInput, InvoiceUncheckedUpdateWithoutServiceFormInput>
    create: XOR<InvoiceCreateWithoutServiceFormInput, InvoiceUncheckedCreateWithoutServiceFormInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutServiceFormInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutServiceFormInput, InvoiceUncheckedUpdateWithoutServiceFormInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutServiceFormInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutServiceFormInput>
  }

  export type ServiceFormCreateWithoutInvoicesInput = {
    id?: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceFormsInput
    generatedByUser: UserCreateNestedOneWithoutServiceFormsInput
  }

  export type ServiceFormUncheckedCreateWithoutInvoicesInput = {
    id?: string
    bookingRequestId: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    generatedBy: string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceFormCreateOrConnectWithoutInvoicesInput = {
    where: ServiceFormWhereUniqueInput
    create: XOR<ServiceFormCreateWithoutInvoicesInput, ServiceFormUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutUploadedInvoicesInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutUploadedInvoicesInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutUploadedInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedInvoicesInput, UserUncheckedCreateWithoutUploadedInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedByUser: UserCreateNestedOneWithoutUploadedPaymentsInput
    verifiedByUser?: UserCreateNestedOneWithoutVerifiedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceFormUpsertWithoutInvoicesInput = {
    update: XOR<ServiceFormUpdateWithoutInvoicesInput, ServiceFormUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ServiceFormCreateWithoutInvoicesInput, ServiceFormUncheckedCreateWithoutInvoicesInput>
    where?: ServiceFormWhereInput
  }

  export type ServiceFormUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ServiceFormWhereInput
    data: XOR<ServiceFormUpdateWithoutInvoicesInput, ServiceFormUncheckedUpdateWithoutInvoicesInput>
  }

  export type ServiceFormUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceFormsNestedInput
    generatedByUser?: UserUpdateOneRequiredWithoutServiceFormsNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUploadedInvoicesInput = {
    update: XOR<UserUpdateWithoutUploadedInvoicesInput, UserUncheckedUpdateWithoutUploadedInvoicesInput>
    create: XOR<UserCreateWithoutUploadedInvoicesInput, UserUncheckedCreateWithoutUploadedInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedInvoicesInput, UserUncheckedUpdateWithoutUploadedInvoicesInput>
  }

  export type UserUpdateWithoutUploadedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceForm: ServiceFormCreateNestedOneWithoutInvoicesInput
    uploadedByUser: UserCreateNestedOneWithoutUploadedInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    serviceFormId: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutUploadedPaymentsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
  }

  export type UserUncheckedCreateWithoutUploadedPaymentsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
  }

  export type UserCreateOrConnectWithoutUploadedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedPaymentsInput, UserUncheckedCreateWithoutUploadedPaymentsInput>
  }

  export type UserCreateWithoutVerifiedPaymentsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutVerifiedPaymentsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutVerifiedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerifiedPaymentsInput, UserUncheckedCreateWithoutVerifiedPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceForm?: ServiceFormUpdateOneRequiredWithoutInvoicesNestedInput
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUploadedPaymentsInput = {
    update: XOR<UserUpdateWithoutUploadedPaymentsInput, UserUncheckedUpdateWithoutUploadedPaymentsInput>
    create: XOR<UserCreateWithoutUploadedPaymentsInput, UserUncheckedCreateWithoutUploadedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedPaymentsInput, UserUncheckedUpdateWithoutUploadedPaymentsInput>
  }

  export type UserUpdateWithoutUploadedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
  }

  export type UserUpsertWithoutVerifiedPaymentsInput = {
    update: XOR<UserUpdateWithoutVerifiedPaymentsInput, UserUncheckedUpdateWithoutVerifiedPaymentsInput>
    create: XOR<UserCreateWithoutVerifiedPaymentsInput, UserUncheckedCreateWithoutVerifiedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerifiedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerifiedPaymentsInput, UserUncheckedUpdateWithoutVerifiedPaymentsInput>
  }

  export type UserUpdateWithoutVerifiedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerifiedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type BookingServiceItemCreateWithoutSampleTrackingInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceItemsInput
    service: ServiceCreateNestedOneWithoutBookingItemsInput
    equipmentUsages?: SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateWithoutSampleTrackingInput = {
    id?: string
    bookingRequestId: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemCreateOrConnectWithoutSampleTrackingInput = {
    where: BookingServiceItemWhereUniqueInput
    create: XOR<BookingServiceItemCreateWithoutSampleTrackingInput, BookingServiceItemUncheckedCreateWithoutSampleTrackingInput>
  }

  export type UserCreateWithoutSampleTrackingInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutSampleTrackingInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutSampleTrackingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSampleTrackingInput, UserUncheckedCreateWithoutSampleTrackingInput>
  }

  export type AnalysisResultCreateWithoutSampleTrackingInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedByUser: UserCreateNestedOneWithoutUploadedResultsInput
  }

  export type AnalysisResultUncheckedCreateWithoutSampleTrackingInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisResultCreateOrConnectWithoutSampleTrackingInput = {
    where: AnalysisResultWhereUniqueInput
    create: XOR<AnalysisResultCreateWithoutSampleTrackingInput, AnalysisResultUncheckedCreateWithoutSampleTrackingInput>
  }

  export type AnalysisResultCreateManySampleTrackingInputEnvelope = {
    data: AnalysisResultCreateManySampleTrackingInput | AnalysisResultCreateManySampleTrackingInput[]
    skipDuplicates?: boolean
  }

  export type BookingServiceItemUpsertWithoutSampleTrackingInput = {
    update: XOR<BookingServiceItemUpdateWithoutSampleTrackingInput, BookingServiceItemUncheckedUpdateWithoutSampleTrackingInput>
    create: XOR<BookingServiceItemCreateWithoutSampleTrackingInput, BookingServiceItemUncheckedCreateWithoutSampleTrackingInput>
    where?: BookingServiceItemWhereInput
  }

  export type BookingServiceItemUpdateToOneWithWhereWithoutSampleTrackingInput = {
    where?: BookingServiceItemWhereInput
    data: XOR<BookingServiceItemUpdateWithoutSampleTrackingInput, BookingServiceItemUncheckedUpdateWithoutSampleTrackingInput>
  }

  export type BookingServiceItemUpdateWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingItemsNestedInput
    equipmentUsages?: SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type UserUpsertWithoutSampleTrackingInput = {
    update: XOR<UserUpdateWithoutSampleTrackingInput, UserUncheckedUpdateWithoutSampleTrackingInput>
    create: XOR<UserCreateWithoutSampleTrackingInput, UserUncheckedCreateWithoutSampleTrackingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSampleTrackingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSampleTrackingInput, UserUncheckedUpdateWithoutSampleTrackingInput>
  }

  export type UserUpdateWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type AnalysisResultUpsertWithWhereUniqueWithoutSampleTrackingInput = {
    where: AnalysisResultWhereUniqueInput
    update: XOR<AnalysisResultUpdateWithoutSampleTrackingInput, AnalysisResultUncheckedUpdateWithoutSampleTrackingInput>
    create: XOR<AnalysisResultCreateWithoutSampleTrackingInput, AnalysisResultUncheckedCreateWithoutSampleTrackingInput>
  }

  export type AnalysisResultUpdateWithWhereUniqueWithoutSampleTrackingInput = {
    where: AnalysisResultWhereUniqueInput
    data: XOR<AnalysisResultUpdateWithoutSampleTrackingInput, AnalysisResultUncheckedUpdateWithoutSampleTrackingInput>
  }

  export type AnalysisResultUpdateManyWithWhereWithoutSampleTrackingInput = {
    where: AnalysisResultScalarWhereInput
    data: XOR<AnalysisResultUpdateManyMutationInput, AnalysisResultUncheckedUpdateManyWithoutSampleTrackingInput>
  }

  export type BookingRequestCreateWithoutWorkspaceBookingsInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    user: UserCreateNestedOneWithoutBookingRequestsInput
    reviewedByUser?: UserCreateNestedOneWithoutApprovedBookingsInput
    companyRelation?: CompanyCreateNestedOneWithoutBookingsInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutBookingsInput
    serviceItems?: BookingServiceItemCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestUncheckedCreateWithoutWorkspaceBookingsInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    serviceItems?: BookingServiceItemUncheckedCreateNestedManyWithoutBookingRequestInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutBookingRequestInput
  }

  export type BookingRequestCreateOrConnectWithoutWorkspaceBookingsInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutWorkspaceBookingsInput, BookingRequestUncheckedCreateWithoutWorkspaceBookingsInput>
  }

  export type WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput = {
    id?: string
    createdAt?: Date | string
    equipment: LabEquipmentCreateNestedOneWithoutWorkspaceUsagesInput
  }

  export type WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput = {
    id?: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type WorkspaceEquipmentUsageCreateOrConnectWithoutWorkspaceBookingInput = {
    where: WorkspaceEquipmentUsageWhereUniqueInput
    create: XOR<WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput>
  }

  export type WorkspaceEquipmentUsageCreateManyWorkspaceBookingInputEnvelope = {
    data: WorkspaceEquipmentUsageCreateManyWorkspaceBookingInput | WorkspaceEquipmentUsageCreateManyWorkspaceBookingInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAddOnCreateWithoutWorkspaceBookingInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
    bookingServiceItem?: BookingServiceItemCreateNestedOneWithoutServiceAddOnsInput
    addOnCatalog: GlobalAddOnCatalogCreateNestedOneWithoutServiceAddOnsInput
  }

  export type ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput = {
    id?: string
    bookingServiceItemId?: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnCreateOrConnectWithoutWorkspaceBookingInput = {
    where: ServiceAddOnWhereUniqueInput
    create: XOR<ServiceAddOnCreateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput>
  }

  export type ServiceAddOnCreateManyWorkspaceBookingInputEnvelope = {
    data: ServiceAddOnCreateManyWorkspaceBookingInput | ServiceAddOnCreateManyWorkspaceBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestUpsertWithoutWorkspaceBookingsInput = {
    update: XOR<BookingRequestUpdateWithoutWorkspaceBookingsInput, BookingRequestUncheckedUpdateWithoutWorkspaceBookingsInput>
    create: XOR<BookingRequestCreateWithoutWorkspaceBookingsInput, BookingRequestUncheckedCreateWithoutWorkspaceBookingsInput>
    where?: BookingRequestWhereInput
  }

  export type BookingRequestUpdateToOneWithWhereWithoutWorkspaceBookingsInput = {
    where?: BookingRequestWhereInput
    data: XOR<BookingRequestUpdateWithoutWorkspaceBookingsInput, BookingRequestUncheckedUpdateWithoutWorkspaceBookingsInput>
  }

  export type BookingRequestUpdateWithoutWorkspaceBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutWorkspaceBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutWorkspaceBookingInput = {
    where: WorkspaceEquipmentUsageWhereUniqueInput
    update: XOR<WorkspaceEquipmentUsageUpdateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedUpdateWithoutWorkspaceBookingInput>
    create: XOR<WorkspaceEquipmentUsageCreateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedCreateWithoutWorkspaceBookingInput>
  }

  export type WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutWorkspaceBookingInput = {
    where: WorkspaceEquipmentUsageWhereUniqueInput
    data: XOR<WorkspaceEquipmentUsageUpdateWithoutWorkspaceBookingInput, WorkspaceEquipmentUsageUncheckedUpdateWithoutWorkspaceBookingInput>
  }

  export type WorkspaceEquipmentUsageUpdateManyWithWhereWithoutWorkspaceBookingInput = {
    where: WorkspaceEquipmentUsageScalarWhereInput
    data: XOR<WorkspaceEquipmentUsageUpdateManyMutationInput, WorkspaceEquipmentUsageUncheckedUpdateManyWithoutWorkspaceBookingInput>
  }

  export type WorkspaceEquipmentUsageScalarWhereInput = {
    AND?: WorkspaceEquipmentUsageScalarWhereInput | WorkspaceEquipmentUsageScalarWhereInput[]
    OR?: WorkspaceEquipmentUsageScalarWhereInput[]
    NOT?: WorkspaceEquipmentUsageScalarWhereInput | WorkspaceEquipmentUsageScalarWhereInput[]
    id?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    workspaceBookingId?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    equipmentId?: UuidFilter<"WorkspaceEquipmentUsage"> | string
    createdAt?: DateTimeFilter<"WorkspaceEquipmentUsage"> | Date | string
  }

  export type ServiceAddOnUpsertWithWhereUniqueWithoutWorkspaceBookingInput = {
    where: ServiceAddOnWhereUniqueInput
    update: XOR<ServiceAddOnUpdateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedUpdateWithoutWorkspaceBookingInput>
    create: XOR<ServiceAddOnCreateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedCreateWithoutWorkspaceBookingInput>
  }

  export type ServiceAddOnUpdateWithWhereUniqueWithoutWorkspaceBookingInput = {
    where: ServiceAddOnWhereUniqueInput
    data: XOR<ServiceAddOnUpdateWithoutWorkspaceBookingInput, ServiceAddOnUncheckedUpdateWithoutWorkspaceBookingInput>
  }

  export type ServiceAddOnUpdateManyWithWhereWithoutWorkspaceBookingInput = {
    where: ServiceAddOnScalarWhereInput
    data: XOR<ServiceAddOnUpdateManyMutationInput, ServiceAddOnUncheckedUpdateManyWithoutWorkspaceBookingInput>
  }

  export type WorkspaceEquipmentUsageCreateWithoutEquipmentInput = {
    id?: string
    createdAt?: Date | string
    workspaceBooking: WorkspaceBookingCreateNestedOneWithoutEquipmentUsagesInput
  }

  export type WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput = {
    id?: string
    workspaceBookingId: string
    createdAt?: Date | string
  }

  export type WorkspaceEquipmentUsageCreateOrConnectWithoutEquipmentInput = {
    where: WorkspaceEquipmentUsageWhereUniqueInput
    create: XOR<WorkspaceEquipmentUsageCreateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput>
  }

  export type WorkspaceEquipmentUsageCreateManyEquipmentInputEnvelope = {
    data: WorkspaceEquipmentUsageCreateManyEquipmentInput | WorkspaceEquipmentUsageCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type SampleEquipmentUsageCreateWithoutEquipmentInput = {
    id?: string
    createdAt?: Date | string
    bookedItem: BookingServiceItemCreateNestedOneWithoutEquipmentUsagesInput
  }

  export type SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput = {
    id?: string
    bookingServiceItemId: string
    createdAt?: Date | string
  }

  export type SampleEquipmentUsageCreateOrConnectWithoutEquipmentInput = {
    where: SampleEquipmentUsageWhereUniqueInput
    create: XOR<SampleEquipmentUsageCreateWithoutEquipmentInput, SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput>
  }

  export type SampleEquipmentUsageCreateManyEquipmentInputEnvelope = {
    data: SampleEquipmentUsageCreateManyEquipmentInput | SampleEquipmentUsageCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: WorkspaceEquipmentUsageWhereUniqueInput
    update: XOR<WorkspaceEquipmentUsageUpdateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedUpdateWithoutEquipmentInput>
    create: XOR<WorkspaceEquipmentUsageCreateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedCreateWithoutEquipmentInput>
  }

  export type WorkspaceEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: WorkspaceEquipmentUsageWhereUniqueInput
    data: XOR<WorkspaceEquipmentUsageUpdateWithoutEquipmentInput, WorkspaceEquipmentUsageUncheckedUpdateWithoutEquipmentInput>
  }

  export type WorkspaceEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput = {
    where: WorkspaceEquipmentUsageScalarWhereInput
    data: XOR<WorkspaceEquipmentUsageUpdateManyMutationInput, WorkspaceEquipmentUsageUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type SampleEquipmentUsageUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: SampleEquipmentUsageWhereUniqueInput
    update: XOR<SampleEquipmentUsageUpdateWithoutEquipmentInput, SampleEquipmentUsageUncheckedUpdateWithoutEquipmentInput>
    create: XOR<SampleEquipmentUsageCreateWithoutEquipmentInput, SampleEquipmentUsageUncheckedCreateWithoutEquipmentInput>
  }

  export type SampleEquipmentUsageUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: SampleEquipmentUsageWhereUniqueInput
    data: XOR<SampleEquipmentUsageUpdateWithoutEquipmentInput, SampleEquipmentUsageUncheckedUpdateWithoutEquipmentInput>
  }

  export type SampleEquipmentUsageUpdateManyWithWhereWithoutEquipmentInput = {
    where: SampleEquipmentUsageScalarWhereInput
    data: XOR<SampleEquipmentUsageUpdateManyMutationInput, SampleEquipmentUsageUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type WorkspaceBookingCreateWithoutEquipmentUsagesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutWorkspaceBookingsInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingUncheckedCreateWithoutEquipmentUsagesInput = {
    id?: string
    bookingRequestId: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingCreateOrConnectWithoutEquipmentUsagesInput = {
    where: WorkspaceBookingWhereUniqueInput
    create: XOR<WorkspaceBookingCreateWithoutEquipmentUsagesInput, WorkspaceBookingUncheckedCreateWithoutEquipmentUsagesInput>
  }

  export type LabEquipmentCreateWithoutWorkspaceUsagesInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sampleUsages?: SampleEquipmentUsageCreateNestedManyWithoutEquipmentInput
  }

  export type LabEquipmentUncheckedCreateWithoutWorkspaceUsagesInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sampleUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type LabEquipmentCreateOrConnectWithoutWorkspaceUsagesInput = {
    where: LabEquipmentWhereUniqueInput
    create: XOR<LabEquipmentCreateWithoutWorkspaceUsagesInput, LabEquipmentUncheckedCreateWithoutWorkspaceUsagesInput>
  }

  export type WorkspaceBookingUpsertWithoutEquipmentUsagesInput = {
    update: XOR<WorkspaceBookingUpdateWithoutEquipmentUsagesInput, WorkspaceBookingUncheckedUpdateWithoutEquipmentUsagesInput>
    create: XOR<WorkspaceBookingCreateWithoutEquipmentUsagesInput, WorkspaceBookingUncheckedCreateWithoutEquipmentUsagesInput>
    where?: WorkspaceBookingWhereInput
  }

  export type WorkspaceBookingUpdateToOneWithWhereWithoutEquipmentUsagesInput = {
    where?: WorkspaceBookingWhereInput
    data: XOR<WorkspaceBookingUpdateWithoutEquipmentUsagesInput, WorkspaceBookingUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type WorkspaceBookingUpdateWithoutEquipmentUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutWorkspaceBookingsNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type WorkspaceBookingUncheckedUpdateWithoutEquipmentUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type LabEquipmentUpsertWithoutWorkspaceUsagesInput = {
    update: XOR<LabEquipmentUpdateWithoutWorkspaceUsagesInput, LabEquipmentUncheckedUpdateWithoutWorkspaceUsagesInput>
    create: XOR<LabEquipmentCreateWithoutWorkspaceUsagesInput, LabEquipmentUncheckedCreateWithoutWorkspaceUsagesInput>
    where?: LabEquipmentWhereInput
  }

  export type LabEquipmentUpdateToOneWithWhereWithoutWorkspaceUsagesInput = {
    where?: LabEquipmentWhereInput
    data: XOR<LabEquipmentUpdateWithoutWorkspaceUsagesInput, LabEquipmentUncheckedUpdateWithoutWorkspaceUsagesInput>
  }

  export type LabEquipmentUpdateWithoutWorkspaceUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleUsages?: SampleEquipmentUsageUpdateManyWithoutEquipmentNestedInput
  }

  export type LabEquipmentUncheckedUpdateWithoutWorkspaceUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type BookingServiceItemCreateWithoutEquipmentUsagesInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceItemsInput
    service: ServiceCreateNestedOneWithoutBookingItemsInput
    modifications?: SampleModificationCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateWithoutEquipmentUsagesInput = {
    id?: string
    bookingRequestId: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modifications?: SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemCreateOrConnectWithoutEquipmentUsagesInput = {
    where: BookingServiceItemWhereUniqueInput
    create: XOR<BookingServiceItemCreateWithoutEquipmentUsagesInput, BookingServiceItemUncheckedCreateWithoutEquipmentUsagesInput>
  }

  export type LabEquipmentCreateWithoutSampleUsagesInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceUsages?: WorkspaceEquipmentUsageCreateNestedManyWithoutEquipmentInput
  }

  export type LabEquipmentUncheckedCreateWithoutSampleUsagesInput = {
    id?: string
    name: string
    description?: string | null
    isAvailable?: boolean
    maintenanceNotes?: string | null
    expectedMaintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceUsages?: WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type LabEquipmentCreateOrConnectWithoutSampleUsagesInput = {
    where: LabEquipmentWhereUniqueInput
    create: XOR<LabEquipmentCreateWithoutSampleUsagesInput, LabEquipmentUncheckedCreateWithoutSampleUsagesInput>
  }

  export type BookingServiceItemUpsertWithoutEquipmentUsagesInput = {
    update: XOR<BookingServiceItemUpdateWithoutEquipmentUsagesInput, BookingServiceItemUncheckedUpdateWithoutEquipmentUsagesInput>
    create: XOR<BookingServiceItemCreateWithoutEquipmentUsagesInput, BookingServiceItemUncheckedCreateWithoutEquipmentUsagesInput>
    where?: BookingServiceItemWhereInput
  }

  export type BookingServiceItemUpdateToOneWithWhereWithoutEquipmentUsagesInput = {
    where?: BookingServiceItemWhereInput
    data: XOR<BookingServiceItemUpdateWithoutEquipmentUsagesInput, BookingServiceItemUncheckedUpdateWithoutEquipmentUsagesInput>
  }

  export type BookingServiceItemUpdateWithoutEquipmentUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingItemsNestedInput
    modifications?: SampleModificationUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateWithoutEquipmentUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifications?: SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type LabEquipmentUpsertWithoutSampleUsagesInput = {
    update: XOR<LabEquipmentUpdateWithoutSampleUsagesInput, LabEquipmentUncheckedUpdateWithoutSampleUsagesInput>
    create: XOR<LabEquipmentCreateWithoutSampleUsagesInput, LabEquipmentUncheckedCreateWithoutSampleUsagesInput>
    where?: LabEquipmentWhereInput
  }

  export type LabEquipmentUpdateToOneWithWhereWithoutSampleUsagesInput = {
    where?: LabEquipmentWhereInput
    data: XOR<LabEquipmentUpdateWithoutSampleUsagesInput, LabEquipmentUncheckedUpdateWithoutSampleUsagesInput>
  }

  export type LabEquipmentUpdateWithoutSampleUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceUsages?: WorkspaceEquipmentUsageUpdateManyWithoutEquipmentNestedInput
  }

  export type LabEquipmentUncheckedUpdateWithoutSampleUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    maintenanceNotes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedMaintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceUsages?: WorkspaceEquipmentUsageUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type SampleTrackingCreateWithoutAnalysisResultsInput = {
    id?: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingServiceItem: BookingServiceItemCreateNestedOneWithoutSampleTrackingInput
    updatedByUser?: UserCreateNestedOneWithoutSampleTrackingInput
  }

  export type SampleTrackingUncheckedCreateWithoutAnalysisResultsInput = {
    id?: string
    bookingServiceItemId: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleTrackingCreateOrConnectWithoutAnalysisResultsInput = {
    where: SampleTrackingWhereUniqueInput
    create: XOR<SampleTrackingCreateWithoutAnalysisResultsInput, SampleTrackingUncheckedCreateWithoutAnalysisResultsInput>
  }

  export type UserCreateWithoutUploadedResultsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutUploadedResultsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutUploadedResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedResultsInput, UserUncheckedCreateWithoutUploadedResultsInput>
  }

  export type SampleTrackingUpsertWithoutAnalysisResultsInput = {
    update: XOR<SampleTrackingUpdateWithoutAnalysisResultsInput, SampleTrackingUncheckedUpdateWithoutAnalysisResultsInput>
    create: XOR<SampleTrackingCreateWithoutAnalysisResultsInput, SampleTrackingUncheckedCreateWithoutAnalysisResultsInput>
    where?: SampleTrackingWhereInput
  }

  export type SampleTrackingUpdateToOneWithWhereWithoutAnalysisResultsInput = {
    where?: SampleTrackingWhereInput
    data: XOR<SampleTrackingUpdateWithoutAnalysisResultsInput, SampleTrackingUncheckedUpdateWithoutAnalysisResultsInput>
  }

  export type SampleTrackingUpdateWithoutAnalysisResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingServiceItem?: BookingServiceItemUpdateOneRequiredWithoutSampleTrackingNestedInput
    updatedByUser?: UserUpdateOneWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingUncheckedUpdateWithoutAnalysisResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUploadedResultsInput = {
    update: XOR<UserUpdateWithoutUploadedResultsInput, UserUncheckedUpdateWithoutUploadedResultsInput>
    create: XOR<UserCreateWithoutUploadedResultsInput, UserUncheckedCreateWithoutUploadedResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedResultsInput, UserUncheckedUpdateWithoutUploadedResultsInput>
  }

  export type UserUpdateWithoutUploadedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facultyRelation?: FacultyCreateNestedOneWithoutUsersInput
    departmentRelation?: DepartmentCreateNestedOneWithoutUsersInput
    ikohza?: IkohzaCreateNestedOneWithoutUsersInput
    companyRelation?: CompanyCreateNestedOneWithoutUsersInput
    companyBranch?: CompanyBranchCreateNestedOneWithoutUsersInput
    approvedByUser?: UserCreateNestedOneWithoutApprovedUsersInput
    approvedUsers?: UserCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
    approvedUsers?: UserUncheckedCreateNestedManyWithoutApprovedByUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    bookingRequests?: BookingRequestUncheckedCreateNestedManyWithoutUserInput
    approvedBookings?: BookingRequestUncheckedCreateNestedManyWithoutReviewedByUserInput
    serviceForms?: ServiceFormUncheckedCreateNestedManyWithoutGeneratedByUserInput
    uploadedInvoices?: InvoiceUncheckedCreateNestedManyWithoutUploadedByUserInput
    verifiedPayments?: PaymentUncheckedCreateNestedManyWithoutVerifiedByUserInput
    uploadedResults?: AnalysisResultUncheckedCreateNestedManyWithoutUploadedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdModifications?: SampleModificationUncheckedCreateNestedManyWithoutCreatedByUserInput
    approvedModifications?: SampleModificationUncheckedCreateNestedManyWithoutApprovedByUserInput
    uploadedPayments?: PaymentUncheckedCreateNestedManyWithoutUploadedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type ServiceAddOnMappingCreateWithoutAddOnCatalogInput = {
    id?: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutAddOnMappingsInput
  }

  export type ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput = {
    id?: string
    serviceId: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnMappingCreateOrConnectWithoutAddOnCatalogInput = {
    where: ServiceAddOnMappingWhereUniqueInput
    create: XOR<ServiceAddOnMappingCreateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnMappingCreateManyAddOnCatalogInputEnvelope = {
    data: ServiceAddOnMappingCreateManyAddOnCatalogInput | ServiceAddOnMappingCreateManyAddOnCatalogInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAddOnCreateWithoutAddOnCatalogInput = {
    id?: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
    bookingServiceItem?: BookingServiceItemCreateNestedOneWithoutServiceAddOnsInput
    workspaceBooking?: WorkspaceBookingCreateNestedOneWithoutServiceAddOnsInput
  }

  export type ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput = {
    id?: string
    bookingServiceItemId?: string | null
    workspaceBookingId?: string | null
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnCreateOrConnectWithoutAddOnCatalogInput = {
    where: ServiceAddOnWhereUniqueInput
    create: XOR<ServiceAddOnCreateWithoutAddOnCatalogInput, ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnCreateManyAddOnCatalogInputEnvelope = {
    data: ServiceAddOnCreateManyAddOnCatalogInput | ServiceAddOnCreateManyAddOnCatalogInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAddOnMappingUpsertWithWhereUniqueWithoutAddOnCatalogInput = {
    where: ServiceAddOnMappingWhereUniqueInput
    update: XOR<ServiceAddOnMappingUpdateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedUpdateWithoutAddOnCatalogInput>
    create: XOR<ServiceAddOnMappingCreateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedCreateWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnMappingUpdateWithWhereUniqueWithoutAddOnCatalogInput = {
    where: ServiceAddOnMappingWhereUniqueInput
    data: XOR<ServiceAddOnMappingUpdateWithoutAddOnCatalogInput, ServiceAddOnMappingUncheckedUpdateWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnMappingUpdateManyWithWhereWithoutAddOnCatalogInput = {
    where: ServiceAddOnMappingScalarWhereInput
    data: XOR<ServiceAddOnMappingUpdateManyMutationInput, ServiceAddOnMappingUncheckedUpdateManyWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnUpsertWithWhereUniqueWithoutAddOnCatalogInput = {
    where: ServiceAddOnWhereUniqueInput
    update: XOR<ServiceAddOnUpdateWithoutAddOnCatalogInput, ServiceAddOnUncheckedUpdateWithoutAddOnCatalogInput>
    create: XOR<ServiceAddOnCreateWithoutAddOnCatalogInput, ServiceAddOnUncheckedCreateWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnUpdateWithWhereUniqueWithoutAddOnCatalogInput = {
    where: ServiceAddOnWhereUniqueInput
    data: XOR<ServiceAddOnUpdateWithoutAddOnCatalogInput, ServiceAddOnUncheckedUpdateWithoutAddOnCatalogInput>
  }

  export type ServiceAddOnUpdateManyWithWhereWithoutAddOnCatalogInput = {
    where: ServiceAddOnScalarWhereInput
    data: XOR<ServiceAddOnUpdateManyMutationInput, ServiceAddOnUncheckedUpdateManyWithoutAddOnCatalogInput>
  }

  export type ServiceCreateWithoutAddOnMappingsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: ServicePricingCreateNestedManyWithoutServiceInput
    bookingItems?: BookingServiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAddOnMappingsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: $Enums.service_category_enum
    isActive?: boolean
    requiresSample?: boolean
    minSampleMass?: Decimal | DecimalJsLike | number | string | null
    operatingHours?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: ServicePricingUncheckedCreateNestedManyWithoutServiceInput
    bookingItems?: BookingServiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAddOnMappingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAddOnMappingsInput, ServiceUncheckedCreateWithoutAddOnMappingsInput>
  }

  export type GlobalAddOnCatalogCreateWithoutServiceMappingsInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceAddOns?: ServiceAddOnCreateNestedManyWithoutAddOnCatalogInput
  }

  export type GlobalAddOnCatalogUncheckedCreateWithoutServiceMappingsInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceAddOns?: ServiceAddOnUncheckedCreateNestedManyWithoutAddOnCatalogInput
  }

  export type GlobalAddOnCatalogCreateOrConnectWithoutServiceMappingsInput = {
    where: GlobalAddOnCatalogWhereUniqueInput
    create: XOR<GlobalAddOnCatalogCreateWithoutServiceMappingsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceMappingsInput>
  }

  export type ServiceUpsertWithoutAddOnMappingsInput = {
    update: XOR<ServiceUpdateWithoutAddOnMappingsInput, ServiceUncheckedUpdateWithoutAddOnMappingsInput>
    create: XOR<ServiceCreateWithoutAddOnMappingsInput, ServiceUncheckedCreateWithoutAddOnMappingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAddOnMappingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAddOnMappingsInput, ServiceUncheckedUpdateWithoutAddOnMappingsInput>
  }

  export type ServiceUpdateWithoutAddOnMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: ServicePricingUpdateManyWithoutServiceNestedInput
    bookingItems?: BookingServiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAddOnMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: Enumservice_category_enumFieldUpdateOperationsInput | $Enums.service_category_enum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresSample?: BoolFieldUpdateOperationsInput | boolean
    minSampleMass?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    operatingHours?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: ServicePricingUncheckedUpdateManyWithoutServiceNestedInput
    bookingItems?: BookingServiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type GlobalAddOnCatalogUpsertWithoutServiceMappingsInput = {
    update: XOR<GlobalAddOnCatalogUpdateWithoutServiceMappingsInput, GlobalAddOnCatalogUncheckedUpdateWithoutServiceMappingsInput>
    create: XOR<GlobalAddOnCatalogCreateWithoutServiceMappingsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceMappingsInput>
    where?: GlobalAddOnCatalogWhereInput
  }

  export type GlobalAddOnCatalogUpdateToOneWithWhereWithoutServiceMappingsInput = {
    where?: GlobalAddOnCatalogWhereInput
    data: XOR<GlobalAddOnCatalogUpdateWithoutServiceMappingsInput, GlobalAddOnCatalogUncheckedUpdateWithoutServiceMappingsInput>
  }

  export type GlobalAddOnCatalogUpdateWithoutServiceMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAddOns?: ServiceAddOnUpdateManyWithoutAddOnCatalogNestedInput
  }

  export type GlobalAddOnCatalogUncheckedUpdateWithoutServiceMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutAddOnCatalogNestedInput
  }

  export type BookingServiceItemCreateWithoutServiceAddOnsInput = {
    id?: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutServiceItemsInput
    service: ServiceCreateNestedOneWithoutBookingItemsInput
    equipmentUsages?: SampleEquipmentUsageCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemUncheckedCreateWithoutServiceAddOnsInput = {
    id?: string
    bookingRequestId: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedCreateNestedManyWithoutBookedItemInput
    modifications?: SampleModificationUncheckedCreateNestedManyWithoutBookingServiceItemInput
    sampleTracking?: SampleTrackingUncheckedCreateNestedManyWithoutBookingServiceItemInput
  }

  export type BookingServiceItemCreateOrConnectWithoutServiceAddOnsInput = {
    where: BookingServiceItemWhereUniqueInput
    create: XOR<BookingServiceItemCreateWithoutServiceAddOnsInput, BookingServiceItemUncheckedCreateWithoutServiceAddOnsInput>
  }

  export type WorkspaceBookingCreateWithoutServiceAddOnsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingRequest: BookingRequestCreateNestedOneWithoutWorkspaceBookingsInput
    equipmentUsages?: WorkspaceEquipmentUsageCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingUncheckedCreateWithoutServiceAddOnsInput = {
    id?: string
    bookingRequestId: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUncheckedCreateNestedManyWithoutWorkspaceBookingInput
  }

  export type WorkspaceBookingCreateOrConnectWithoutServiceAddOnsInput = {
    where: WorkspaceBookingWhereUniqueInput
    create: XOR<WorkspaceBookingCreateWithoutServiceAddOnsInput, WorkspaceBookingUncheckedCreateWithoutServiceAddOnsInput>
  }

  export type GlobalAddOnCatalogCreateWithoutServiceAddOnsInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceMappings?: ServiceAddOnMappingCreateNestedManyWithoutAddOnCatalogInput
  }

  export type GlobalAddOnCatalogUncheckedCreateWithoutServiceAddOnsInput = {
    id?: string
    name: string
    description?: string | null
    defaultAmount: Decimal | DecimalJsLike | number | string
    applicableTo: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceMappings?: ServiceAddOnMappingUncheckedCreateNestedManyWithoutAddOnCatalogInput
  }

  export type GlobalAddOnCatalogCreateOrConnectWithoutServiceAddOnsInput = {
    where: GlobalAddOnCatalogWhereUniqueInput
    create: XOR<GlobalAddOnCatalogCreateWithoutServiceAddOnsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceAddOnsInput>
  }

  export type BookingServiceItemUpsertWithoutServiceAddOnsInput = {
    update: XOR<BookingServiceItemUpdateWithoutServiceAddOnsInput, BookingServiceItemUncheckedUpdateWithoutServiceAddOnsInput>
    create: XOR<BookingServiceItemCreateWithoutServiceAddOnsInput, BookingServiceItemUncheckedCreateWithoutServiceAddOnsInput>
    where?: BookingServiceItemWhereInput
  }

  export type BookingServiceItemUpdateToOneWithWhereWithoutServiceAddOnsInput = {
    where?: BookingServiceItemWhereInput
    data: XOR<BookingServiceItemUpdateWithoutServiceAddOnsInput, BookingServiceItemUncheckedUpdateWithoutServiceAddOnsInput>
  }

  export type BookingServiceItemUpdateWithoutServiceAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingItemsNestedInput
    equipmentUsages?: SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateWithoutServiceAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type WorkspaceBookingUpsertWithoutServiceAddOnsInput = {
    update: XOR<WorkspaceBookingUpdateWithoutServiceAddOnsInput, WorkspaceBookingUncheckedUpdateWithoutServiceAddOnsInput>
    create: XOR<WorkspaceBookingCreateWithoutServiceAddOnsInput, WorkspaceBookingUncheckedCreateWithoutServiceAddOnsInput>
    where?: WorkspaceBookingWhereInput
  }

  export type WorkspaceBookingUpdateToOneWithWhereWithoutServiceAddOnsInput = {
    where?: WorkspaceBookingWhereInput
    data: XOR<WorkspaceBookingUpdateWithoutServiceAddOnsInput, WorkspaceBookingUncheckedUpdateWithoutServiceAddOnsInput>
  }

  export type WorkspaceBookingUpdateWithoutServiceAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutWorkspaceBookingsNestedInput
    equipmentUsages?: WorkspaceEquipmentUsageUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type WorkspaceBookingUncheckedUpdateWithoutServiceAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUncheckedUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type GlobalAddOnCatalogUpsertWithoutServiceAddOnsInput = {
    update: XOR<GlobalAddOnCatalogUpdateWithoutServiceAddOnsInput, GlobalAddOnCatalogUncheckedUpdateWithoutServiceAddOnsInput>
    create: XOR<GlobalAddOnCatalogCreateWithoutServiceAddOnsInput, GlobalAddOnCatalogUncheckedCreateWithoutServiceAddOnsInput>
    where?: GlobalAddOnCatalogWhereInput
  }

  export type GlobalAddOnCatalogUpdateToOneWithWhereWithoutServiceAddOnsInput = {
    where?: GlobalAddOnCatalogWhereInput
    data: XOR<GlobalAddOnCatalogUpdateWithoutServiceAddOnsInput, GlobalAddOnCatalogUncheckedUpdateWithoutServiceAddOnsInput>
  }

  export type GlobalAddOnCatalogUpdateWithoutServiceAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceMappings?: ServiceAddOnMappingUpdateManyWithoutAddOnCatalogNestedInput
  }

  export type GlobalAddOnCatalogUncheckedUpdateWithoutServiceAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    applicableTo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceMappings?: ServiceAddOnMappingUncheckedUpdateManyWithoutAddOnCatalogNestedInput
  }

  export type BetterAuthSessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthAccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthVerificationCreateManyUserInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BetterAuthSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetterAuthVerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyFacultyInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IkohzaCreateManyFacultyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    isActive?: boolean
    leaderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyFacultyRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
  }

  export type DepartmentUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentRelationNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentRelationNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IkohzaUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutIkohzaNestedInput
  }

  export type IkohzaUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutIkohzaNestedInput
  }

  export type IkohzaUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    leaderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutFacultyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFacultyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFacultyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyDepartmentRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
  }

  export type UserUpdateWithoutDepartmentRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyIkohzaInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
  }

  export type UserUpdateWithoutIkohzaInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIkohzaInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutIkohzaInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyBranchCreateManyCompanyInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyCompanyRelationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
  }

  export type BookingRequestCreateManyCompanyRelationInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyBranchId?: string | null
  }

  export type CompanyBranchUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyBranchNestedInput
    bookings?: BookingRequestUpdateManyWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyBranchNestedInput
    bookings?: BookingRequestUncheckedUpdateManyWithoutCompanyBranchNestedInput
  }

  export type CompanyBranchUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCompanyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUpdateWithoutCompanyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutCompanyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateManyWithoutCompanyRelationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyCompanyBranchInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: string | null
  }

  export type BookingRequestCreateManyCompanyBranchInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
  }

  export type UserUpdateWithoutCompanyBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUpdateWithoutCompanyBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutCompanyBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateManyWithoutCompanyBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyApprovedByUserInput = {
    id?: string
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    phone?: string | null
    userType: $Enums.user_type_enum
    status?: $Enums.user_status_enum
    academicType?: $Enums.academic_type_enum
    userIdentifier?: string | null
    supervisorName?: string | null
    facultyId?: string | null
    departmentId?: string | null
    ikohzaId?: string | null
    companyId?: string | null
    companyBranchId?: string | null
    UTM?: $Enums.UTM | null
    address?: string | null
    email: string
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderCreateManyUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    passwordHash?: string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BookingRequestCreateManyUserInput = {
    id?: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
  }

  export type BookingRequestCreateManyReviewedByUserInput = {
    id?: string
    userId: string
    referenceNumber: string
    projectDescription?: string | null
    preferredStartDate?: Date | string | null
    preferredEndDate?: Date | string | null
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.booking_status_enum
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    companyId?: string | null
    companyBranchId?: string | null
  }

  export type ServiceFormCreateManyGeneratedByUserInput = {
    id?: string
    bookingRequestId: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyUploadedByUserInput = {
    id?: string
    serviceFormId: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyVerifiedByUserInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisResultCreateManyUploadedByUserInput = {
    id?: string
    sampleTrackingId: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.notification_type_enum
    relatedEntityType?: string | null
    relatedEntityId?: string | null
    title: string
    message: string
    emailSent?: boolean
    emailSentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleTrackingCreateManyUpdatedByUserInput = {
    id?: string
    bookingServiceItemId: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleModificationCreateManyCreatedByUserInput = {
    id?: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type SampleModificationCreateManyApprovedByUserInput = {
    id?: string
    bookingServiceItemId: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type PaymentCreateManyUploadedByUserInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facultyRelation?: FacultyUpdateOneWithoutUsersNestedInput
    departmentRelation?: DepartmentUpdateOneWithoutUsersNestedInput
    ikohza?: IkohzaUpdateOneWithoutUsersNestedInput
    companyRelation?: CompanyUpdateOneWithoutUsersNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutUsersNestedInput
    approvedUsers?: UserUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedUsers?: UserUncheckedUpdateManyWithoutApprovedByUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    bookingRequests?: BookingRequestUncheckedUpdateManyWithoutUserNestedInput
    approvedBookings?: BookingRequestUncheckedUpdateManyWithoutReviewedByUserNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutGeneratedByUserNestedInput
    uploadedInvoices?: InvoiceUncheckedUpdateManyWithoutUploadedByUserNestedInput
    verifiedPayments?: PaymentUncheckedUpdateManyWithoutVerifiedByUserNestedInput
    uploadedResults?: AnalysisResultUncheckedUpdateManyWithoutUploadedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdModifications?: SampleModificationUncheckedUpdateManyWithoutCreatedByUserNestedInput
    approvedModifications?: SampleModificationUncheckedUpdateManyWithoutApprovedByUserNestedInput
    uploadedPayments?: PaymentUncheckedUpdateManyWithoutUploadedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    status?: Enumuser_status_enumFieldUpdateOperationsInput | $Enums.user_status_enum
    academicType?: Enumacademic_type_enumFieldUpdateOperationsInput | $Enums.academic_type_enum
    userIdentifier?: NullableStringFieldUpdateOperationsInput | string | null
    supervisorName?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    ikohzaId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    UTM?: NullableEnumUTMFieldUpdateOperationsInput | $Enums.UTM | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    oauthData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUser?: UserUpdateOneWithoutApprovedBookingsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUpdateWithoutReviewedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingRequestsNestedInput
    companyRelation?: CompanyUpdateOneWithoutBookingsNestedInput
    companyBranch?: CompanyBranchUpdateOneWithoutBookingsNestedInput
    serviceItems?: BookingServiceItemUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateWithoutReviewedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceItems?: BookingServiceItemUncheckedUpdateManyWithoutBookingRequestNestedInput
    workspaceBookings?: WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestNestedInput
    serviceForms?: ServiceFormUncheckedUpdateManyWithoutBookingRequestNestedInput
  }

  export type BookingRequestUncheckedUpdateManyWithoutReviewedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    preferredStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferredEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumbooking_status_enumFieldUpdateOperationsInput | $Enums.booking_status_enum
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    companyBranchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceFormUpdateWithoutGeneratedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceFormsNestedInput
    invoices?: InvoiceUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutGeneratedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateManyWithoutGeneratedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceForm?: ServiceFormUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceFormId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutVerifiedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutVerifiedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutVerifiedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultUpdateWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleTracking?: SampleTrackingUpdateOneRequiredWithoutAnalysisResultsNestedInput
  }

  export type AnalysisResultUncheckedUpdateWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleTrackingId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultUncheckedUpdateManyWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleTrackingId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumnotification_type_enumFieldUpdateOperationsInput | $Enums.notification_type_enum
    relatedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleTrackingUpdateWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingServiceItem?: BookingServiceItemUpdateOneRequiredWithoutSampleTrackingNestedInput
    analysisResults?: AnalysisResultUpdateManyWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingUncheckedUpdateWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisResults?: AnalysisResultUncheckedUpdateManyWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingUncheckedUpdateManyWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleModificationUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingServiceItem?: BookingServiceItemUpdateOneRequiredWithoutModificationsNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedModificationsNestedInput
  }

  export type SampleModificationUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleModificationUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleModificationUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingServiceItem?: BookingServiceItemUpdateOneRequiredWithoutModificationsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutCreatedModificationsNestedInput
  }

  export type SampleModificationUncheckedUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SampleModificationUncheckedUpdateManyWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    verifiedByUser?: UserUpdateOneWithoutVerifiedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUploadedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingCreateManyServiceInput = {
    id?: string
    userType: $Enums.user_type_enum
    price: Decimal | DecimalJsLike | number | string
    unit: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingServiceItemCreateManyServiceInput = {
    id?: string
    bookingRequestId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAddOnMappingCreateManyServiceInput = {
    id?: string
    addOnId: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServicePricingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: Enumuser_type_enumFieldUpdateOperationsInput | $Enums.user_type_enum
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingServiceItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingRequest?: BookingRequestUpdateOneRequiredWithoutServiceItemsNestedInput
    equipmentUsages?: SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingRequestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addOnCatalog?: GlobalAddOnCatalogUpdateOneRequiredWithoutServiceMappingsNestedInput
  }

  export type ServiceAddOnMappingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    addOnId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingServiceItemCreateManyBookingRequestInput = {
    id?: string
    serviceId: string
    quantity?: number
    durationMonths?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    sampleName?: string | null
    sampleDetails?: string | null
    sampleType?: string | null
    sampleHazard?: string | null
    testingMethod?: string | null
    degasConditions?: string | null
    solventSystem?: string | null
    solvents?: string | null
    solventComposition?: string | null
    columnType?: string | null
    flowRate?: Decimal | DecimalJsLike | number | string | null
    wavelength?: number | null
    expectedRetentionTime?: Decimal | DecimalJsLike | number | string | null
    samplePreparation?: string | null
    notes?: string | null
    expectedCompletionDate?: Date | string | null
    actualCompletionDate?: Date | string | null
    turnaroundEstimate?: string | null
    hplcPreparationRequired?: boolean
    temperatureControlled?: boolean
    lightSensitive?: boolean
    hazardousMaterial?: boolean
    inertAtmosphere?: boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceBookingCreateManyBookingRequestInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    preferredTimeSlot?: string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceFormCreateManyBookingRequestInput = {
    id?: string
    formNumber: string
    costCentre?: string | null
    facilityLab?: string
    staffPicName?: string | null
    staffPicEmail?: string | null
    staffPicPhone?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    validUntil: Date | string
    status?: $Enums.form_status_enum
    serviceFormUnsignedPdfPath: string
    serviceFormSignedPdfPath?: string | null
    requiresWorkingAreaAgreement?: boolean
    workingAreaAgreementUnsignedPdfPath?: string | null
    workingAreaAgreementSignedPdfPath?: string | null
    generatedAt?: Date | string
    generatedBy: string
    downloadedAt?: Date | string | null
    signedFormsUploadedAt?: Date | string | null
    signedFormsUploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingServiceItemUpdateWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutBookingItemsNestedInput
    equipmentUsages?: SampleEquipmentUsageUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemNestedInput
    modifications?: SampleModificationUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    sampleTracking?: SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemNestedInput
  }

  export type BookingServiceItemUncheckedUpdateManyWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    durationMonths?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sampleName?: NullableStringFieldUpdateOperationsInput | string | null
    sampleDetails?: NullableStringFieldUpdateOperationsInput | string | null
    sampleType?: NullableStringFieldUpdateOperationsInput | string | null
    sampleHazard?: NullableStringFieldUpdateOperationsInput | string | null
    testingMethod?: NullableStringFieldUpdateOperationsInput | string | null
    degasConditions?: NullableStringFieldUpdateOperationsInput | string | null
    solventSystem?: NullableStringFieldUpdateOperationsInput | string | null
    solvents?: NullableStringFieldUpdateOperationsInput | string | null
    solventComposition?: NullableStringFieldUpdateOperationsInput | string | null
    columnType?: NullableStringFieldUpdateOperationsInput | string | null
    flowRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wavelength?: NullableIntFieldUpdateOperationsInput | number | null
    expectedRetentionTime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    samplePreparation?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    turnaroundEstimate?: NullableStringFieldUpdateOperationsInput | string | null
    hplcPreparationRequired?: BoolFieldUpdateOperationsInput | boolean
    temperatureControlled?: BoolFieldUpdateOperationsInput | boolean
    lightSensitive?: BoolFieldUpdateOperationsInput | boolean
    hazardousMaterial?: BoolFieldUpdateOperationsInput | boolean
    inertAtmosphere?: BoolFieldUpdateOperationsInput | boolean
    otherEquipmentRequests?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceBookingUpdateWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUpdateManyWithoutWorkspaceBookingNestedInput
    serviceAddOns?: ServiceAddOnUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type WorkspaceBookingUncheckedUpdateWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentUsages?: WorkspaceEquipmentUsageUncheckedUpdateManyWithoutWorkspaceBookingNestedInput
    serviceAddOns?: ServiceAddOnUncheckedUpdateManyWithoutWorkspaceBookingNestedInput
  }

  export type WorkspaceBookingUncheckedUpdateManyWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    preferredTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    specialEquipment?: NullableJsonNullValueInput | InputJsonValue
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFormUpdateWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedByUser?: UserUpdateOneRequiredWithoutServiceFormsNestedInput
    invoices?: InvoiceUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutServiceFormNestedInput
  }

  export type ServiceFormUncheckedUpdateManyWithoutBookingRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    formNumber?: StringFieldUpdateOperationsInput | string
    costCentre?: NullableStringFieldUpdateOperationsInput | string | null
    facilityLab?: StringFieldUpdateOperationsInput | string
    staffPicName?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicEmail?: NullableStringFieldUpdateOperationsInput | string | null
    staffPicPhone?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumform_status_enumFieldUpdateOperationsInput | $Enums.form_status_enum
    serviceFormUnsignedPdfPath?: StringFieldUpdateOperationsInput | string
    serviceFormSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    requiresWorkingAreaAgreement?: BoolFieldUpdateOperationsInput | boolean
    workingAreaAgreementUnsignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    workingAreaAgreementSignedPdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signedFormsUploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageCreateManyBookedItemInput = {
    id?: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type SampleModificationCreateManyBookingServiceItemInput = {
    id?: string
    originalQuantity: number
    newQuantity: number
    originalDurationMonths?: number
    newDurationMonths?: number
    originalTotalPrice: Decimal | DecimalJsLike | number | string
    newTotalPrice: Decimal | DecimalJsLike | number | string
    reason: string
    status?: $Enums.modification_status_enum
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    approvedBy?: string | null
  }

  export type SampleTrackingCreateManyBookingServiceItemInput = {
    id?: string
    sampleIdentifier: string
    status?: $Enums.sample_status_enum
    receivedAt?: Date | string | null
    analysisStartAt?: Date | string | null
    analysisCompleteAt?: Date | string | null
    returnRequestedAt?: Date | string | null
    returnedAt?: Date | string | null
    notes?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAddOnCreateManyBookingServiceItemInput = {
    id?: string
    workspaceBookingId?: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type SampleEquipmentUsageUpdateWithoutBookedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: LabEquipmentUpdateOneRequiredWithoutSampleUsagesNestedInput
  }

  export type SampleEquipmentUsageUncheckedUpdateWithoutBookedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageUncheckedUpdateManyWithoutBookedItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleModificationUpdateWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneRequiredWithoutCreatedModificationsNestedInput
    approvedByUser?: UserUpdateOneWithoutApprovedModificationsNestedInput
  }

  export type SampleModificationUncheckedUpdateWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleModificationUncheckedUpdateManyWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalQuantity?: IntFieldUpdateOperationsInput | number
    newQuantity?: IntFieldUpdateOperationsInput | number
    originalDurationMonths?: IntFieldUpdateOperationsInput | number
    newDurationMonths?: IntFieldUpdateOperationsInput | number
    originalTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newTotalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: Enummodification_status_enumFieldUpdateOperationsInput | $Enums.modification_status_enum
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleTrackingUpdateWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUser?: UserUpdateOneWithoutSampleTrackingNestedInput
    analysisResults?: AnalysisResultUpdateManyWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingUncheckedUpdateWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analysisResults?: AnalysisResultUncheckedUpdateManyWithoutSampleTrackingNestedInput
  }

  export type SampleTrackingUncheckedUpdateManyWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdentifier?: StringFieldUpdateOperationsInput | string
    status?: Enumsample_status_enumFieldUpdateOperationsInput | $Enums.sample_status_enum
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUpdateWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceBooking?: WorkspaceBookingUpdateOneWithoutServiceAddOnsNestedInput
    addOnCatalog?: GlobalAddOnCatalogUpdateOneRequiredWithoutServiceAddOnsNestedInput
  }

  export type ServiceAddOnUncheckedUpdateWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnCatalogId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUncheckedUpdateManyWithoutBookingServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnCatalogId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyServiceFormInput = {
    id?: string
    invoiceNumber: string
    invoiceDate?: Date | string
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.invoice_status_enum
    filePath: string
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutServiceFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutServiceFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutServiceFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enuminvoice_status_enumFieldUpdateOperationsInput | $Enums.invoice_status_enum
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    paymentMethod: $Enums.payment_method_enum
    paymentDate: Date | string
    referenceNumber?: string | null
    receiptFilePath: string
    status?: $Enums.payment_status_enum
    uploadedBy: string
    uploadedAt?: Date | string
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedPaymentsNestedInput
    verifiedByUser?: UserUpdateOneWithoutVerifiedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethod?: Enumpayment_method_enumFieldUpdateOperationsInput | $Enums.payment_method_enum
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    receiptFilePath?: StringFieldUpdateOperationsInput | string
    status?: Enumpayment_status_enumFieldUpdateOperationsInput | $Enums.payment_status_enum
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultCreateManySampleTrackingInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    fileType: string
    description?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalysisResultUpdateWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedByUser?: UserUpdateOneRequiredWithoutUploadedResultsNestedInput
  }

  export type AnalysisResultUncheckedUpdateWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalysisResultUncheckedUpdateManyWithoutSampleTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageCreateManyWorkspaceBookingInput = {
    id?: string
    equipmentId: string
    createdAt?: Date | string
  }

  export type ServiceAddOnCreateManyWorkspaceBookingInput = {
    id?: string
    bookingServiceItemId?: string | null
    addOnCatalogId: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type WorkspaceEquipmentUsageUpdateWithoutWorkspaceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: LabEquipmentUpdateOneRequiredWithoutWorkspaceUsagesNestedInput
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateWithoutWorkspaceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateManyWithoutWorkspaceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUpdateWithoutWorkspaceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingServiceItem?: BookingServiceItemUpdateOneWithoutServiceAddOnsNestedInput
    addOnCatalog?: GlobalAddOnCatalogUpdateOneRequiredWithoutServiceAddOnsNestedInput
  }

  export type ServiceAddOnUncheckedUpdateWithoutWorkspaceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnCatalogId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUncheckedUpdateManyWithoutWorkspaceBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    addOnCatalogId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageCreateManyEquipmentInput = {
    id?: string
    workspaceBookingId: string
    createdAt?: Date | string
  }

  export type SampleEquipmentUsageCreateManyEquipmentInput = {
    id?: string
    bookingServiceItemId: string
    createdAt?: Date | string
  }

  export type WorkspaceEquipmentUsageUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceBooking?: WorkspaceBookingUpdateOneRequiredWithoutEquipmentUsagesNestedInput
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceBookingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceEquipmentUsageUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceBookingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedItem?: BookingServiceItemUpdateOneRequiredWithoutEquipmentUsagesNestedInput
  }

  export type SampleEquipmentUsageUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleEquipmentUsageUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingCreateManyAddOnCatalogInput = {
    id?: string
    serviceId: string
    isEnabled?: boolean
    customAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnCreateManyAddOnCatalogInput = {
    id?: string
    bookingServiceItemId?: string | null
    workspaceBookingId?: string | null
    name: string
    amount: Decimal | DecimalJsLike | number | string
    taxable?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type ServiceAddOnMappingUpdateWithoutAddOnCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutAddOnMappingsNestedInput
  }

  export type ServiceAddOnMappingUncheckedUpdateWithoutAddOnCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnMappingUncheckedUpdateManyWithoutAddOnCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    customAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUpdateWithoutAddOnCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingServiceItem?: BookingServiceItemUpdateOneWithoutServiceAddOnsNestedInput
    workspaceBooking?: WorkspaceBookingUpdateOneWithoutServiceAddOnsNestedInput
  }

  export type ServiceAddOnUncheckedUpdateWithoutAddOnCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAddOnUncheckedUpdateManyWithoutAddOnCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingServiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxable?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}